E:\ML\ML_projects\Practic\engageAI_v2\engageai_core\curriculum\models\assessment\assessment_result.py
from dataclasses import dataclass
from typing import Optional, List, Dict, Any


@dataclass(frozen=True)
class AssessmentResult:
    """
    Чистый доменный объект результата оценки.
    Не зависит от Django или базы данных.
    Хранит результаты по навыкам и краткое резюме с советами.
    """
    task_id: int
    is_correct: bool
    cefr_target: str
    skill_evaluation: Dict[str, Dict[str, Any]]
    summary: Dict[str, Any]
    error_tags: List[str] = None
    metadata: Dict[str, Any] = None

    def __post_init__(self):
        # Проверяем ключи skill_evaluation
        expected_skills = ["grammar", "vocabulary", "reading", "listening", "writing", "speaking"]
        for skill in expected_skills:
            if skill not in self.skill_evaluation:
                raise ValueError(f"Missing skill evaluation for '{skill}'")
            eval_data = self.skill_evaluation[skill]
            # Проверка score и confidence
            score = eval_data.get("score")
            confidence = eval_data.get("confidence")
            if score is not None and not (0.0 <= score <= 1.0):
                raise ValueError(f"Score for '{skill}' must be between 0.0 and 1.0")
            if confidence is not None and not (0.0 <= confidence <= 1.0):
                raise ValueError(f"Confidence for '{skill}' must be between 0.0 and 1.0")
            # Инициализация пустых списков
            if "evidence" not in eval_data or eval_data["evidence"] is None:
                eval_data["evidence"] = []

        # Проверка summary
        if not isinstance(self.summary, dict):
            raise ValueError("Summary must be a dictionary")
        if "text" not in self.summary or "advice" not in self.summary:
            raise ValueError("Summary must contain 'text' and 'advice'")
        if not isinstance(self.summary["advice"], list):
            raise ValueError("'advice' in summary must be a list")

        # Инициализация дополнительных полей
        if self.error_tags is None:
            object.__setattr__(self, "error_tags", [])
        if self.metadata is None:
            object.__setattr__(self, "metadata", {})


#######

E:\ML\ML_projects\Practic\engageAI_v2\engageai_core\curriculum\models\assessment\lesson_assesment.py
from django.db import models

from curriculum.models.content.lesson import Lesson
from curriculum.models.student.enrollment import Enrollment


class AssessmentStatus(models.TextChoices):
    PENDING = "PENDING", "Ожидание оценки"
    PROCESSING = "PROCESSING", "Оценка в процессе"
    COMPLETED = "COMPLETED", "Оценка завершена"
    ERROR = "ERROR", "Ошибка оценки"


class LessonAssessmentResult(models.Model):
    enrollment = models.ForeignKey(Enrollment, on_delete=models.CASCADE, related_name='assessment_results')
    lesson = models.ForeignKey(Lesson, on_delete=models.SET_NULL, null=True)
    started_at = models.DateTimeField(auto_now_add=True)
    completed_at = models.DateTimeField(null=True, blank=True)
    overall_score = models.FloatField(null=True, blank=True)  # 0.0–1.0
    structured_feedback = models.JSONField(default=dict)  # {'grammar': 0.85, 'speaking': 0.62, ...}
    llm_summary = models.TextField(blank=True)  # Итоговое резюме LLM
    llm_recommendations = models.TextField(blank=True)  # "Рекомендуем больше практики speaking"
    status = models.CharField(max_length=20, default=AssessmentStatus.PENDING, choices=AssessmentStatus)
    error_message = models.TextField(blank=True, null=True)

    class Meta:
        unique_together = ['enrollment', 'lesson']


#######

E:\ML\ML_projects\Practic\engageAI_v2\engageai_core\curriculum\models\assessment\task_assessment.py
from django.db import models

from curriculum.models.content.task import Task
from curriculum.models.student.enrollment import Enrollment
from curriculum.models.student.student_response import StudentTaskResponse


class TaskAssessmentResult(models.Model):
    """
    Результат оценки конкретного задания студента в рамках урока.
    Хранит score, фидбек и метаданные для каждого задания отдельно.
    """
    enrollment = models.ForeignKey(Enrollment, on_delete=models.CASCADE, related_name='task_assessments')
    task = models.ForeignKey(Task, on_delete=models.CASCADE, )
    response = models.OneToOneField(StudentTaskResponse, on_delete=models.SET_NULL, null=True, related_name='assessment')

    score = models.FloatField(null=True, blank=True, help_text="0.0–1.0")
    is_correct = models.BooleanField(null=True, blank=True, help_text="Для closed-заданий")
    feedback = models.TextField(blank=True, help_text="Краткий комментарий LLM или правила")
    structured_feedback = models.JSONField(default=dict, blank=True, help_text="{'grammar_error': 'Past Simple', 'confidence': 0.92}")
    evaluated_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = ['enrollment', 'task']  # Один результат на задание в enrollment
        indexes = [
            models.Index(fields=['enrollment', 'task']),
            models.Index(fields=['score']),
        ]

    def __str__(self):
        return f"Task {self.task.id} для enrollment {self.enrollment.id} — score {self.score}"

#######

E:\ML\ML_projects\Practic\engageAI_v2\engageai_core\curriculum\models\content\balance.py
from django.core.exceptions import ValidationError
from django.db import models

from curriculum.models.content.course import Course

DEFAULT_COURSE_BALANCE = {
    "levels": {
        "A2": 0.25,
        "B1": 0.30,
        "B2": 0.25,
        "C1": 0.15,
        "C2": 0.05,
    },
    "skills": {
        "grammar": 0.2,
        "vocabulary": 0.2,
        "reading": 0.15,
        "listening": 0.15,
        "writing": 0.15,
        "speaking": 0.15,
    },
    "total_lessons": 60
}


class CourseBalance(models.Model):
    """
    Контракт баланса базовой генерации курса.
    """
    course = models.OneToOneField(Course, on_delete=models.CASCADE)

    total_lessons = models.PositiveIntegerField(default=120)

    level_distribution = models.JSONField(
        default=dict,
        help_text="Процентное распределение уровней"
    )

    skill_distribution = models.JSONField(
        default=dict,
        help_text="Баланс навыков"
    )

    frozen = models.BooleanField(
        default=True,
        help_text="Запрещает изменение после инициализации"
    )

    class Meta:
        verbose_name = "Course balance"
        verbose_name_plural = "Course balances"

    def clean(self):
        if self.frozen and self.pk:
            raise ValidationError("Frozen CourseBalance cannot be modified")

    def __str__(self):
        return f"CourseBalance<{self.code}>"


#######

E:\ML\ML_projects\Practic\engageAI_v2\engageai_core\curriculum\models\content\course.py
from django.db import models
from django.utils.translation import gettext_lazy as _


class Course(models.Model):
    """
    Учебный курс — структурированная последовательность уроков.
    Может быть диагностическим (is_diagnostic=True) или обучающим.

    Назначение:
    - Диагностический курс: содержит 8 блоков из плана.
    - Обучающий курс: тематический путь (например, "English for Backend Engineers").

    Поля:
    - title: название курса
    - estimated_duration: общая длительность в минутах
    - learning_objectives: цели, которые покрывает курс
    - required_skills: список навыков/уровней, необходимых для старта (JSON)
    """
    objects = models.Manager()

    title = models.CharField(max_length=200, verbose_name=_("Title"))
    description = models.TextField(verbose_name=_("Description"))
    professional_tags = models.ManyToManyField(
        "curriculum.ProfessionalTag",
        blank=True,
        verbose_name=_("Professional Tags"),
        help_text=_("Теги профессий, для которых курс релевантен (e.g., 'backend', 'qa')")
    )

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    is_active = models.BooleanField(default=True, verbose_name=_("Is Active"))

    class Meta:
        verbose_name = _("Course")
        verbose_name_plural = _("Courses")

    def __str__(self):
        return f"{self.title}"


#######

E:\ML\ML_projects\Practic\engageAI_v2\engageai_core\curriculum\models\content\lesson.py
from django.core.validators import MaxValueValidator, MinValueValidator
from django.db import models
from django.utils.translation import gettext_lazy as _

from curriculum.models.content.course import Course
from curriculum.models.systematization.learning_objective import LearningObjective

from curriculum.validators import validate_skill_focus
from users.models import CEFRLevel


class Lesson(models.Model):
    """
    Урок — логическая единица внутри курса (например, "Listening: Stand-up Meetings").

    Назначение:
    - Соответствует одному из 8 блоков диагностики или теме в обучении.
    - Содержит задания (Tasks).

    Поля:
    - duration_minutes: сколько времени займёт
    - skill_focus: навыки, на которые направлен (["listening", "vocabulary"])
    - adaptive_parameters: правила адаптации (например, пороги для усложнения)
    """
    objects = models.Manager()

    course = models.ForeignKey(Course, on_delete=models.CASCADE, related_name='lessons', verbose_name=_("Course"))
    title = models.CharField(max_length=200, verbose_name=_("Title"))
    description = models.TextField(verbose_name=_("Description"))
    order = models.PositiveIntegerField(verbose_name=_("Order"))
    content = models.TextField(verbose_name=_("Content"),
                               help_text=_("Optional structured lesson instructions or narrative for AI"))
    content_ru = models.TextField(verbose_name=_("Content"),
                               help_text=_("Field 'content' in Russian lang"), blank=True)
    theory_content = models.TextField(verbose_name=_("Theory Content"), blank=True,
                                      help_text=_("HTML content with theory and explanations"))
    duration_minutes = models.PositiveIntegerField(validators=[MinValueValidator(1), MaxValueValidator(120)],
                                                   verbose_name=_("Duration (minutes)"))
    required_cefr = models.CharField(max_length=2, choices=CEFRLevel, verbose_name=_("Required CEFR"))
    learning_objectives = models.ManyToManyField(LearningObjective, verbose_name=_("Learning Objectives"))
    skill_focus = models.JSONField(default=list, validators=[validate_skill_focus], verbose_name=_("Skill Focus"),
                                   help_text=_("e.g., ['listening', 'vocabulary']")
                                   )
    adaptive_parameters = models.JSONField(default=dict, verbose_name=_("Adaptive Parameters"),
                                           help_text=_("e.g., {'min_correct_ratio': 0.7, 'max_items': 10}")
                                           )
    is_remedial = models.BooleanField(verbose_name="дополнительные, корректирующие уроки", default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    is_active = models.BooleanField(default=True, verbose_name=_("Is Active"))
    metadata = models.JSONField(default=dict, verbose_name=_("Metadata"))

    class Meta:
        verbose_name = _("Lesson")
        verbose_name_plural = _("Lessons")
        ordering = ['course', 'order']
        indexes = [models.Index(fields=['course', 'order'])]

    def __str__(self):
        return f"{self.course.title} → {self.title}"


#######

E:\ML\ML_projects\Practic\engageAI_v2\engageai_core\curriculum\models\content\methodological_plan.py
# curriculum/models/content/learning_plan.py
from django.db import models
from django.core.exceptions import ValidationError
from curriculum.models.content.course import Course


class MethodologicalPlan(models.Model):
    """
    Кэш методологического плана для курса + состояние генерации.
    Позволяет восстановить генерацию после сбоев.
    """
    course = models.OneToOneField(
        Course,
        on_delete=models.CASCADE,
        related_name='learning_plan'
    )

    # Методплан
    plan_data = models.JSONField()  # Полная структура {level: {skill: [units]}}
    total_units = models.PositiveIntegerField()
    generated_units = models.PositiveIntegerField(default=0)

    # Статистика
    levels = models.JSONField(default=dict)  # {level: unit_count}
    skills = models.JSONField(default=dict)  # {skill: unit_count}

    # Состояние
    is_complete = models.BooleanField(default=False)
    last_lesson_order = models.PositiveIntegerField(default=0)

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = "Learning plan"
        verbose_name_plural = "Learning plans"

    def clean(self):
        if self.total_units > 0 and self.generated_units > self.total_units:
            raise ValidationError("Generated units cannot exceed total")

    def __str__(self):
        return f"LearningPlan({self.course.title}): {self.generated_units}/{self.total_units}"


#######

E:\ML\ML_projects\Practic\engageAI_v2\engageai_core\curriculum\models\content\response_format.py
from django.db import models
from django.utils.translation import gettext_lazy as _


class ResponseFormat(models.TextChoices):
    """Типы ответов"""

    MULTIPLE_CHOICE = ('multiple_choice', _('Multiple Choice – выбор одного или нескольких вариантов'))
    SINGLE_CHOICE = ('single_choice', _('Single Choice – выбор одного варианта'))
    SHORT_TEXT = ('short_text', _('Short Text – краткий текстовый ответ, 1–3 слова'))
    FREE_TEXT = ('free_text', _('Free Text – развёрнутый ответ, абзац или текст'))
    AUDIO = ('audio', _('Audio – голосовое сообщение'))


#######

E:\ML\ML_projects\Practic\engageAI_v2\engageai_core\curriculum\models\content\task.py
from django.db import models
from django.utils.translation import gettext_lazy as _

from curriculum.models import LearningObjective
from curriculum.models.content.response_format import ResponseFormat
from curriculum.models.systematization.professional_tag import ProfessionalTag
from users.models import CEFRLevel
from curriculum.models.content.lesson import Lesson
from curriculum.validators import validate_task_content_schema, validate_skill_focus


class TaskType(models.TextChoices):
    """Типы вопросов."""
    GRAMMAR = ('grammar', _('Grammar'))
    VOCABULARY = ('vocabulary', _('Vocabulary'))
    READING = ('reading', _('Reading'))
    LISTENING = ('listening', _('Listening'))
    WRITING = ('writing', _('Writing'))
    SPEAKING = ('speaking', _('Speaking'))


class Task(models.Model):
    """
    Задание — самая мелкая единица взаимодействия.
    Полностью покрывает все 8 блоков диагностики.

    Назначение:
    - Закрытые вопросы: MCQ по грамматике, reading comprehension.
    - Открытые: writing warm-up, speaking probe.

    Ключевые поля:
    - task_type: тип навыка (грамматика, listening и т.д.)
    - response_format: как отвечает студент (выбор, текст, аудио)
    - content: структурированное содержимое (см. примеры ниже)
    - professional_tags: релевантность роли студента
    - is_diagnostic: используется ли в диагностике

    Примеры content:

    1. Multiple Choice (Grammar):
    {
      "prompt": "Which sentence is correct?",
      "options": ["I have went...", "I went...", "I have go..."],
      "correct_idx": 1,
      "explanation": "Past Simple for completed past actions."
    }

    2. Short Text (Listening):
    {
      "prompt": "What was the main issue mentioned in the audio?",
      "correct": ["deployment failed", "build error"],
      "case_sensitive": false
    }

    3. Free Text (Writing Warm-up):
    {
      "prompt": "What did you do at work yesterday?",
      "max_length_words": 50,
      "expected_skills": ["past_simple", "work_vocabulary"]
    }

    4. Audio (Speaking):
    {
      "prompt": "Record 20–30 seconds about your current task.",
      "max_duration_sec": 30
    }
    """
    objects = models.Manager()

    lesson = models.ForeignKey(Lesson, on_delete=models.CASCADE, null=True, blank=True, verbose_name=_("Lesson"),
                               related_name="tasks")
    task_type = models.CharField(max_length=20, choices=TaskType, verbose_name=_("Task Type"))
    response_format = models.CharField(max_length=20, choices=ResponseFormat, verbose_name=_("Response Format"))
    content = models.JSONField(verbose_name=_("Content"))
    # схема задается в engageai_core/curriculum/schemas.py:TASK_CONTENT_SCHEMAS
    content_schema_version = models.CharField(default="v1", verbose_name=_("Content Schema"))
    difficulty_cefr = models.CharField(max_length=2, choices=CEFRLevel, verbose_name=_("Difficulty CEFR"))
    learning_objectives = models.ManyToManyField(
        LearningObjective,
        related_name="tasks",
        help_text="Какие учебные цели проверяет задание"
    )
    # skill_focus = models.JSONField(default=list, validators=[validate_skill_focus], verbose_name=_("Skill Focus"),
    #                                help_text=_("e.g., ['listening', 'vocabulary']")
    #                                ) # TODO это если надо будет оценивать скилы точечно
    is_diagnostic = models.BooleanField(default=False, verbose_name=_("Used in Diagnostic"))
    professional_tags = models.ManyToManyField(ProfessionalTag, blank=True, verbose_name=_("Professional Tags"))
    is_active = models.BooleanField(default=True, verbose_name=_("Задание актуально"))
    order = models.PositiveIntegerField(
        default=0,
        verbose_name=_("Порядок задачи в уроке"),
        help_text=_("Порядок задания в уроке (чем меньше число, тем раньше задание)")
    )

    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        verbose_name = _("Task")
        verbose_name_plural = _("Tasks")
        ordering = ['lesson', 'order']
        indexes = [
            models.Index(fields=['lesson', 'order']),
            models.Index(fields=['task_type']),
            models.Index(fields=['response_format']),
            models.Index(fields=['lesson', 'is_active', 'order'],
                         name='task_lesson_active_order_idx'),
        ]

    def __str__(self):
        return f"{self.get_task_type_display()} ({self.get_response_format_display()}) — {self.difficulty_cefr}"

    def clean(self):
        validate_task_content_schema(
            self.content,
            self.content_schema_version
        )

    def save(self, *args, **kwargs):
        """Автоматическая установка порядка при создании"""
        if not self.pk and self.order == 0:
            # Получаем максимальный order в этом уроке и добавляем 1
            max_order = Task.objects.filter(lesson=self.lesson).aggregate(
                max_order=models.Max('order')
            )['max_order'] or 0
            self.order = max_order + 1
        super().save(*args, **kwargs)


#######

E:\ML\ML_projects\Practic\engageAI_v2\engageai_core\curriculum\models\content\task_media.py
from django.db import models
from django.utils.translation import gettext_lazy as _

from curriculum.models.content.task import Task


class MediaType(models.TextChoices):
    """Тип медиа файла"""

    TEXT = ('text', _('Raw text snippet or prompt'))
    AUDIO = ('audio', _('Audio file (e.g., MP3, WAV)'))
    VIDEO = ('video', _('Video file (e.g AVI, MP4)'))
    IMAGE = ('image', _('Image (e.g., diagram, screenshot)'))
    DOC = ('document', _('PDF, DOC, or other document'))


class TaskMedia(models.Model):
    """
    Медиафайл, прикреплённый к заданию.

    Назначение:
    - Аудио для listening (блок 6),
    - Изображение для reading (например, скрин тикета),
    - Текстовый фрагмент.

    Поля:
    - file: путь к файлу
    - media_type: тип контента
    - order: порядок, если файлов несколько
    """
    task = models.ForeignKey(Task, on_delete=models.CASCADE, related_name='media_files', verbose_name=_("Task"))
    file = models.FileField(upload_to='task_media/', verbose_name=_("File"))
    media_type = models.CharField(max_length=20, choices=MediaType, verbose_name=_("Media Type"))
    order = models.PositiveSmallIntegerField(default=0, verbose_name=_("Order"))

    class Meta:
        verbose_name = _("Task Media")
        verbose_name_plural = _("Task Media")
        indexes = [
            models.Index(fields=['task']),
            models.Index(fields=['media_type']),
        ]

    def __str__(self):
        return f"{self.get_media_type_display()} for {self.task}"


#######

E:\ML\ML_projects\Practic\engageAI_v2\engageai_core\curriculum\models\learning_process\learning_path.py
from django.db import models
from django.utils.translation import gettext_lazy as _
from django.utils import timezone


class LearningPath(models.Model):
    """
    Персонализированный учебный путь студента в рамках зачисления.

    структура узла в nodes
        {
            "node_id": "remedial-grammar-B1-02-9f3a2c",
            "lesson_id": null,
            "learning_objective": "grammar-B1-02",
            "title": "Повтор: Past Simple vs Present Perfect",
            "type": "remedial",
            "status": "locked",
            "prerequisites": ["lesson-42"],
            "created_at": "2026-02-04T10:12:00Z",
            "completed_at": null,
            "metadata": {
                "source": "auto",
                "trigger": "multiple_failures"
            }
        }

    node_id : string Уникальный идентификатор узла внутри LearningPath. {node_type}-{lesson_or_objective}-{uuid4}
        Примеры:
            lesson-42
            remedial-grammar-B1-02-9f3a2c
            diagnostic-speaking-B2-7b12f9

    lesson_id : int | null ID урока, если узел привязан к Lesson.
        int → обычный урок курса
        null → виртуальный узел (remedial, diagnostic, practice)

    title : string Отображаемое название узла:
        берётся из Lesson
        либо генерируется (remedial)

    type : string Тип узла.
        Допустимые значения v1:
        type	Назначение
        core	Основной урок курса
        remedial	Повтор / восстановление
        diagnostic	Проверка уровня
        practice	Практика без теории

    status : string Текущее состояние узла.
        Допустимые значения
        status	Значение
        locked	Недоступен, нельзя начинать
        in_progress	Текущий активный узел
        completed	Успешно завершён
        skipped	Пропущен осознанно
        recommended	Рекомендован (не блокирует путь)

    prerequisites : list[str]
        Список node_id, которые должны быть:
        completed или skipped
        Используется:
        для remedial
        для сложных ветвлений

    triggers : list[object]
        Будущая точка расширения.
        Примеры:
        {
          "condition": "objective.grammar-B1-02 < 0.6",
          "action": "insert_remedial"
        }

    created_at : ISO datetime Когда узел был добавлен в путь.

    metadata : object
        Свободное поле:
        explainability
        source ("auto", "teacher", "diagnostic")
        confidence, reason и т.д.
    """

    enrollment = models.OneToOneField(
        "Enrollment",
        on_delete=models.CASCADE,
        related_name="learning_path",
        verbose_name=_("Зачисление"),
        help_text=_("Один путь на одно зачисление")
    )

    path_type = models.CharField(
        max_length=20,
        choices=[
            ("LINEAR", _("Линейный (по порядку уроков курса)")),
            ("ADAPTIVE", _("Адаптивный (с ветвлениями по SkillDelta)")),
            ("PERSONALIZED", _("Персонализированный (AI-генерированный под цели/профессию)")),
        ],
        default="LINEAR",
        verbose_name=_("Тип пути")
    )

    # JSON-структура пути: список узлов с условиями
    nodes = models.JSONField(
        verbose_name=_("Узлы пути"),
        default=list,
        help_text=_("""
        Пример структуры:
        [
            {
                "node_id": "remedial-grammar-B1-02-9f3a2c",
                "lesson_id": null,
                "learning_objective": "grammar-B1-02",
                "title": "Повтор: Past Simple vs Present Perfect",
                "type": "remedial",
                "status": "locked",
                "prerequisites": ["lesson-42"],
                "created_at": "2026-02-04T10:12:00Z",
                "completed_at": null,
                "metadata": {
                    "source": "auto",
                    "trigger": "multiple_failures"
                }
            },
            ...
        ]
        """)
    )

    current_node_index = models.PositiveIntegerField(
        default=0,
        verbose_name=_("Индекс текущего узла"),
        help_text=_("Позиция в массиве nodes")
    )

    generated_at = models.DateTimeField(
        default=timezone.now,
        verbose_name=_("Время генерации пути")
    )

    updated_at = models.DateTimeField(
        auto_now=True,
        verbose_name=_("Время последнего обновления")
    )

    metadata = models.JSONField(
        default=dict,
        blank=True,
        verbose_name=_("Метаданные"),
        help_text=_(
            "e.g., {'generated_by': 'gpt-4o-mini', 'based_on_profile': {'level': 'B1', 'goal': 'IT_interview'}}")
    )

    class Meta:
        verbose_name = _("Учебный путь")
        verbose_name_plural = _("Учебные пути")

    def __str__(self):
        return f"{self.enrollment.student} — {self.get_path_type_display()} путь в курсе {self.enrollment.course.title}"

    @property
    def current_node(self):
        """Текущий узел для удобства в сервисах и views"""
        if self.nodes and self.current_node_index < len(self.nodes):
            return self.nodes[self.current_node_index]
        return None

    @property
    def next_node(self):
        """Следующий узел (для preview в боте и дашборде)"""
        next_index = self.current_node_index + 1
        if next_index < len(self.nodes):
            return self.nodes[next_index]
        return None

    def advance_to_next_node(self):
        """Переход к следующему узлу после завершения урока"""
        if self.current_node_index + 1 < len(self.nodes):
            self.current_node_index += 1
            self.save(update_fields=["current_node_index", "updated_at"])

#######

E:\ML\ML_projects\Practic\engageAI_v2\engageai_core\curriculum\models\learning_process\lesson_event_log.py
from django.db import models
from django.utils import timezone
from django.utils.translation import gettext_lazy as _
from django.contrib.auth import get_user_model

from curriculum.models.content.lesson import Lesson
from curriculum.models.student.enrollment import Enrollment
from users.models import Student

User = get_user_model()


class LessonEventType(models.TextChoices):
    """
    Типы событий урока — основа для событийного подхода.
    Расширяемо под будущие сценарии (PAUSE, RESUME, ABANDON).
    """
    START = "START", _("Начало урока")
    COMPLETE = "COMPLETE", _("Завершение урока")
    PAUSE = "PAUSE", _("Пауза в уроке")
    RESUME = "RESUME", _("Возобновление урока")
    ABANDON = "ABANDON", _("Покинул урок без завершения")
    ASSESSMENT_START = "ASSESSMENT_START", _("Начало оценки урока")
    ASSESSMENT_COMPLETE = "ASSESSMENT_COMPLETE", _("Завершение оценки урока")
    ASSESSMENT_ERROR = "ASSESSMENT_ERROR", _("Ошибка оценки урока")
    LEARNING_PATH_ADJUSTED = "LEARNING_PATH_ADJUSTED", _("Сформирован следующий шаг учебного плана")


class LessonEventLog(models.Model):
    """
    Лог событий урока для конкретного студента в рамках зачисления.

    Ключевые возможности:
    - Фиксация точного времени начала/завершения урока
    - Расчёт длительности занятия (duration_minutes)
    - Основа для streaks, геймификации (баллы за timely completion)
    - Аналитика вовлечённости (drop-off на PAUSE/ABANDON)
    - Синхронизация между веб и Telegram-ботом
    - Интеграция с AI: триггер для генерации nudges при ABANDON > 24h
    """

    student = models.ForeignKey(
        Student,
        on_delete=models.CASCADE,
        verbose_name=_("Студент"),
        related_name="lesson_events",
        help_text=_("Ссылка на профиль студента с уровнем, целями и профессией")
    )

    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        verbose_name=_("Зачисление"),
        related_name="lesson_events",
        help_text=_("Контекст курса и текущего прогресса")
    )

    lesson = models.ForeignKey(
        Lesson,
        on_delete=models.CASCADE,
        verbose_name=_("Урок"),
        related_name="events",
        null=True,
        blank=True,
        help_text=_("Конкретный урок, к которому относится событие")
    )

    event_type = models.CharField(
        max_length=32,
        choices=LessonEventType.choices,
        verbose_name=_("Тип события")
    )

    timestamp = models.DateTimeField(
        default=timezone.now,
        verbose_name=_("Время события"),
        db_index=True  # Для быстрой аналитики по времени
    )

    channel = models.CharField(
        max_length=20,
        choices=[
            ("WEB", _("Веб-приложение")),
            ("BOT", _("Telegram-бот")),
            ("API", _("Внешний API")),
        ],
        default="WEB",
        verbose_name=_("Канал"),
        help_text=_("Откуда пришло событие — для кросс-канальной аналитики")
    )

    duration_minutes = models.DecimalField(
        max_digits=6,
        decimal_places=2,
        null=True,
        blank=True,
        verbose_name=_("Длительность (мин)"),
        help_text=_("Автоматически рассчитывается для COMPLETE по разнице с START")
    )

    metadata = models.JSONField(
        default=dict,
        blank=True,
        verbose_name=_("Метаданные"),
        help_text=_("Дополнительные данные: e.g., {'completed_tasks': 8, 'total_tasks': 10, 'score': 0.92}")
    )

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = _("Событие урока")
        verbose_name_plural = _("События уроков")
        ordering = ["-timestamp"]
        indexes = [
            models.Index(fields=["student", "-timestamp"]),
            models.Index(fields=["enrollment", "lesson"]),
            models.Index(fields=["event_type", "timestamp"]),
            models.Index(fields=["channel"]),
        ]

    def __str__(self):
        return f"{self.student} — {self.get_event_type_display()} — {self.lesson.title} [{self.timestamp:%Y-%m-%d %H:%M}]"

    def save(self, *args, **kwargs):
        """
        Автоматический расчёт duration_minutes при COMPLETE.
        """
        if self.event_type == LessonEventType.COMPLETE and not self.duration_minutes:
            start_event = LessonEventLog.objects.filter(
                student=self.student,
                enrollment=self.enrollment,
                lesson=self.lesson,
                event_type=LessonEventType.START
            ).order_by("-timestamp").first()

            if start_event:
                duration = (self.timestamp - start_event.timestamp).total_seconds() / 60
                self.duration_minutes = round(duration, 2)

        super().save(*args, **kwargs)

    @staticmethod
    def create_event(student, enrollment, lesson, event_type, channel="WEB", metadata=None):
        return LessonEventLog.objects.create(
            student=student,
            enrollment=enrollment,
            lesson=lesson,
            event_type=event_type,
            channel=channel,
            metadata=metadata or {}
        )

#######

E:\ML\ML_projects\Practic\engageAI_v2\engageai_core\curriculum\models\student\enrollment.py
from django.db import models
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.utils import timezone
from django.utils.translation import gettext_lazy as _

from curriculum.models.content.course import Course
from curriculum.models.content.lesson import Lesson
from curriculum.models.learning_process.learning_path import LearningPath

from curriculum.services.path_generation_service import PathGenerationService
from users.models import Student


class LessonStatus(models.TextChoices):
    ACTIVE = 'ACTIVE', _('Active')
    COMPLETED_TASKS = 'COMPLETED_TASKS', _('All tasks completed')
    PENDING_ASSESSMENT = 'PENDING_ASSESSMENT', _('Pending assessment')
    ASSESSMENT_ERROR = 'ASSESSMENT_ERROR', _('Assessment error')
    COMPLETED = 'COMPLETED', _('Lesson completed')


class Enrollment(models.Model):
    """
    Зачисление студента на курс с полным отслеживанием прогресса.
    """
    objects = models.Manager()

    student = models.ForeignKey(Student, on_delete=models.CASCADE, verbose_name=_("Student"))
    course = models.ForeignKey(Course, on_delete=models.CASCADE, verbose_name=_("Course"))
    adaptive_path_enabled = models.BooleanField(default=False, verbose_name=_("Адаптивный путь активен"))

    started_at = models.DateTimeField(auto_now_add=True, verbose_name=_("Started At"))
    completed_at = models.DateTimeField(null=True, blank=True, verbose_name=_("Completed At"))

    # Текущее состояние обучения
    current_lesson = models.ForeignKey(
        Lesson,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        verbose_name=_("Current Lesson"),
        related_name="active_enrollments"
    )

    lesson_status = models.CharField(
        max_length=20,
        choices=LessonStatus.choices,
        default=LessonStatus.ACTIVE,
        verbose_name=_("Lesson Status"),
    )
    assessment_job_id = models.CharField(
        max_length=255,
        blank=True,
        null=True,
        verbose_name=_("Assessment Job ID")
    )
    assessment_started_at = models.DateTimeField(
        null=True,
        blank=True,
        verbose_name=_("Assessment Started At")
    )
    is_active = models.BooleanField(default=True, verbose_name=_("Is Active"))
    last_activity = models.DateTimeField(auto_now=True, verbose_name=_("Last Activity"))

    class Meta:
        verbose_name = _("Enrollment")
        verbose_name_plural = _("Enrollments")
        indexes = [
            models.Index(fields=['student', 'course']),
            models.Index(fields=['is_active']),
            models.Index(fields=['last_activity']),
            models.Index(fields=['lesson_status']),
            models.Index(fields=['assessment_job_id'])
        ]
        constraints = [
            models.UniqueConstraint(
                fields=['student', 'course', 'is_active'],
                condition=models.Q(is_active=True),
                name='unique_active_enrollment'
            )
        ]

    def __str__(self):
        status = "active" if self.is_active else "completed"
        return f"{self.student} → {self.course} ({status})"


#######

E:\ML\ML_projects\Practic\engageAI_v2\engageai_core\curriculum\models\student\skill_delta.py
from django.db import models

from users.models import Student

from django.utils.translation import gettext_lazy as _


class SkillDelta(models.Model):
    student = models.ForeignKey(Student, on_delete=models.CASCADE, related_name="skill_deltas")
    enrollment = models.ForeignKey("Enrollment", on_delete=models.CASCADE, related_name="skill_deltas")
    lesson = models.ForeignKey("Lesson", on_delete=models.CASCADE, related_name="skill_deltas")

    pre_snapshot = models.ForeignKey(
        "SkillSnapshot", on_delete=models.SET_NULL, null=True, related_name="deltas_as_pre"
    )
    post_snapshot = models.ForeignKey(
        "SkillSnapshot", on_delete=models.SET_NULL, null=True, related_name="deltas_as_post"
    )

    deltas = models.JSONField(
        help_text=_("{'grammar': +0.10, 'speaking': -0.03, 'overall': +0.08}")
    )

    calculated_at = models.DateTimeField(auto_now_add=True)
    metadata = models.JSONField(default=dict, blank=True)

    class Meta:
        unique_together = ["student", "lesson"]

    def __str__(self):
        return f"{self.student} — Урок {self.lesson.order} — Δ {self.deltas.get('overall', 0):+.2f}"

#######

E:\ML\ML_projects\Practic\engageAI_v2\engageai_core\curriculum\models\student\skill_snapshot.py
from django.db import models

from users.models import Student

from django.utils.translation import gettext_lazy as _


class SkillSnapshot(models.Model):
    """
    Снимок навыков студента на определённый момент времени.
    """
    objects = models.Manager()

    student = models.ForeignKey(
        Student,
        on_delete=models.CASCADE,
        related_name="skill_snapshots",
        verbose_name=_("Студент")
    )

    enrollment = models.ForeignKey(
        "Enrollment",
        on_delete=models.CASCADE,
        related_name="skill_snapshots",
        verbose_name=_("Зачисление"),
        help_text=_("Контекст курса для адаптивных маршрутов"),
    )

    associated_lesson = models.ForeignKey(
        "Lesson",
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="skill_snapshots",
        verbose_name=_("Связанный урок"),
        help_text="Урок, после завершения которого сделан снимок (POST). Для PRE используем урок,"
                  " который студент собирается начать."
    )

    snapshot_context = models.CharField(
        max_length=20,
        choices=[
            ("POST_LESSON", _("После завершения урока")),
            ("PLACEMENT", _("Результат placement test")),
            ("WEEKLY_SUMMARY", _("Еженедельный")),
            ("MANUAL", _("Ручной")),
        ],
        default="POST_LESSON",
        verbose_name=_("Контекст снимка")
    )
    grammar = models.FloatField(default=0.0)
    vocabulary = models.FloatField(default=0.0)
    listening = models.FloatField(default=0.0)
    reading = models.FloatField(default=0.0)
    writing = models.FloatField(default=0.0)
    speaking = models.FloatField(default=0.0)

    skills = models.JSONField(
        verbose_name=_("Навыки"),
        default=dict,
        help_text=_("{'grammar': 0.85, 'vocabulary': 0.78, 'speaking': 0.65, 'listening': 0.82, ...} — 0.0–1.0")

    )

    snapshot_at = models.DateTimeField(auto_now_add=True)

    metadata = models.JSONField(
        default=dict,
        blank=True,
        verbose_name=_("Метаданные"),
        help_text=_("e.g., {'source': 'assessment', 'lesson_score': 0.92, 'tasks_completed': 10}")
    )

    class Meta:
        verbose_name = _("Снимок навыков")
        verbose_name_plural = _("Снимки навыков")
        ordering = ["-snapshot_at"]
        indexes = [
            models.Index(fields=["student", "-snapshot_at"]),
            models.Index(fields=["enrollment", "associated_lesson"]),
            models.Index(fields=["snapshot_context"]),
        ]
        unique_together = ["enrollment", "associated_lesson"]  # Один POST-снимок на урок

    def to_dict(self):
        return {
            'grammar': self.grammar,
            'vocabulary': self.vocabulary,
            'listening': self.listening,
            'reading': self.reading,
            'writing': self.writing,
            'speaking': self.speaking,
            'metadata': self.metadata,
        }

    def __str__(self) -> str:
        return f"SkillSnapshot({self.student}, {self.snapshot_at})"


#######

E:\ML\ML_projects\Practic\engageAI_v2\engageai_core\curriculum\models\student\student_response.py
from django.db import models
from django.utils.translation import gettext_lazy as _

from curriculum.models.content.task import Task
from curriculum.models.student.enrollment import Enrollment
from users.models import Student


class StudentTaskResponse(models.Model):
    """
    Ответ студента на задание.

    Назначение:
    - Хранит как текст, так и аудио.
    - Используется для автоматической и LLM-оценки.

    Поля:
    - response_text: для writing, short_text
    - audio_file: для speaking
    - is_correct: True/False для закрытых, None для открытых
    """
    student = models.ForeignKey(Student, on_delete=models.CASCADE, verbose_name=_("Student"))
    task = models.ForeignKey(Task, on_delete=models.CASCADE, verbose_name=_("Task"), related_name="student_response")
    enrollment = models.ForeignKey(Enrollment, on_delete=models.CASCADE, null=True, blank=True)  # ← добавляем
    response_text = models.TextField(blank=True, verbose_name=_("Text Response"))
    audio_file = models.FileField(upload_to='responses/', blank=True, null=True, verbose_name=_("Audio Response"))
    transcript = models.TextField(blank=True, null=True, verbose_name=_("Audio Transcript"))
    submitted_at = models.DateTimeField(auto_now_add=True, verbose_name=_("Submitted At"))

    class Meta:
        verbose_name = _("Student Task Response")
        verbose_name_plural = _("Student Task Responses")
        indexes = [
            models.Index(fields=['student', 'task'],
                         name='response_student_task_idx'),
            models.Index(fields=['task']),
            models.Index(fields=['submitted_at']),
        ]
        unique_together = ['enrollment', 'task']  # Один ответ на задание в рамках enrollment

    def __str__(self):
        return f"Response by {self.student} to {self.task}"


#######

E:\ML\ML_projects\Practic\engageAI_v2\engageai_core\curriculum\models\systematization\learning_objective.py
from django.db import models
from django.utils.translation import gettext_lazy as _

from users.models import CEFRLevel


class LearningObjective(models.Model):
    """
    Учебная цель — педагогически сформулированное умение, которое должен развить студент.

    Вместо ручного кода (например, "B1-G-01") используется структурированное описание:
    - CEFR-уровень,
    - область навыка (грамматика, лексика и т.д.),
    - порядковый номер в рамках уровня и области.

    Идентификатор (`identifier`) генерируется автоматически и гарантирует уникальность.

    Примеры:
    - "Use Past Simple and Present Perfect correctly in work contexts" → grammar, B1, order=1 → identifier="grammar-B1-01"
    - "Understand technical stand-up meetings" → listening, B1, order=1 → identifier="listening-B1-01"
    """

    # === Структурированные поля ===
    cefr_level = models.CharField(
        max_length=2,
        choices=CEFRLevel,
        verbose_name=_("CEFR Level"),
        help_text=_("Уровень CEFR, на котором эта цель актуальна")
    )
    skill_domain = models.CharField(
        max_length=20,
        choices=[
            ('grammar', _('Grammar')),
            ('vocabulary', _('Vocabulary')),
            ('listening', _('Listening')),
            ('reading', _('Reading')),
            ('writing', _('Writing')),
            ('speaking', _('Speaking')),
        ],
        verbose_name=_("Skill Domain"),
        help_text=_("Область языкового навыка")
    )
    order_in_level = models.PositiveSmallIntegerField(
        default=1,
        verbose_name=_("Order within level and domain"),
        help_text=_("Порядковый номер цели в рамках уровня и области (для сортировки)")
    )

    # === Человекочитаемые поля ===
    name = models.CharField(
        max_length=200,
        verbose_name=_("Name"),
        help_text=_("Clear, actionable objective — e.g., 'Use Past Simple correctly in work emails'")
    )
    description = models.TextField(
        blank=True,
        verbose_name=_("Description"),
        help_text=_("Optional detailed explanation for methodologists")
    )

    # === Автоматически генерируемый идентификатор (для API, логики, LLM) ===
    identifier = models.SlugField(
        max_length=50,
        unique=True,
        editable=False,
        verbose_name=_("Machine Identifier"),
        help_text=_("Auto-generated unique ID like 'grammar-B1-01'")
    )

    # === Служебные поля ===
    is_active = models.BooleanField(default=True, verbose_name=_("Is Active"))
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        verbose_name = _("Learning Objective")
        verbose_name_plural = _("Learning Objectives")
        unique_together = [
            ['cefr_level', 'skill_domain', 'order_in_level']
        ]
        ordering = ['cefr_level', 'skill_domain', 'order_in_level']
        indexes = [
            models.Index(fields=['cefr_level', 'skill_domain']),
            models.Index(fields=['identifier']),
        ]

    def save(self, *args, **kwargs):
        # Генерируем идентификатор вида: grammar-B1-01
        self.identifier = f"{self.skill_domain}-{self.cefr_level}-{self.order_in_level:02d}"
        super().save(*args, **kwargs)

    def __str__(self):
        return f"[{self.identifier}] {self.name}"

#######

E:\ML\ML_projects\Practic\engageAI_v2\engageai_core\curriculum\models\systematization\professional_tag.py
from django.db import models
from django.utils.translation import gettext_lazy as _


class ProfessionalTag(models.Model):
    """
    Профессиональный тег — обозначает сферу или тип задач, релевантных заданию.
    Примеры: "backend", "qa", "incident-response", "technical-writing".

    Назначение:
    - Позволяет персонализировать диагностику и обучение под роль студента (из мини-анкеты).
    - Используется для фильтрации заданий по релевантности.

    Примеры наполнения:
    - "backend"
    - "qa"
    - "devops"
    - "product-interviews"
    - "api-documentation"
    - "standup-meetings"
    - "ticket-writing"

    Рекомендация:
    - Теги создаются кураторами/методистами.
    - Студент выбирает 1–3 тега при регистрации или в мини-анкете.
    """
    name = models.CharField(
        max_length=50,
        unique=True,
        verbose_name=_("Tag Name"),
        help_text=_("Short, machine-readable name (e.g., 'backend', 'standup-meetings')")
    )
    description = models.CharField(
        max_length=200,
        blank=True,
        verbose_name=_("Description"),
        help_text=_("Human-readable explanation for admins")
    )
    is_active = models.BooleanField(default=True, verbose_name=_("Is Active"))

    class Meta:
        verbose_name = _("Professional Tag")
        verbose_name_plural = _("Professional Tags")
        indexes = [models.Index(fields=['name'])]

    def __str__(self):
        return self.name


#######

