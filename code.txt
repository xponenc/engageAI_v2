D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\admin.py
from django.contrib import admin

# Register your models here.


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\apps.py
from django.apps import AppConfig


class CurriculumConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'curriculum'

    def ready(self):
        """
        Регистрируем сигналы и импортируем модули при загрузке приложения.
        """
        # Импортируем models для регистрации в Django
        import curriculum.models


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\exceptions.py
"""
Модуль кастомных исключений для учебного процесса.
Обеспечивает типизированную обработку ошибок с контекстом для:
- оценки ответов
- обновления навыков
- принятия решений
- работы с учебным контентом

ПРИНЦИПЫ:
1. Семантические имена (AssessmentError, not GenericError)
2. Возможность добавления контекста (enrollment_id, task_id)
3. Человекочитаемые сообщения + технические детали
4. Группировка по типам (validation, processing, system)
"""

from typing import Any, Dict, Optional
import json


class CurriculumBaseError(Exception):
    """
    Базовое исключение для всех ошибок учебного процесса.
    Добавляет сериализацию в JSON и контекст для логирования.
    """

    def __init__(self, message: str, context: Optional[Dict[str, Any]] = None):
        super().__init__(message)
        self.context = context or {}
        self.timestamp = None  # Будет заполнено в middleware/logger

    def to_dict(self) -> dict:
        """
        Сериализует исключение в словарь для логирования и API.
        """
        return {
            "error_type": self.__class__.__name__,
            "message": str(self),
            "context": self.context,
            "timestamp": self.timestamp.isoformat() if self.timestamp else None
        }

    def to_json(self) -> str:
        """Сериализует исключение в JSON"""
        return json.dumps(self.to_dict(), ensure_ascii=False)


class ValidationError(CurriculumBaseError):
    """Ошибка валидации данных"""
    pass


class ProcessingError(CurriculumBaseError):
    """Ошибка обработки бизнес-логики"""
    pass


class SystemError(CurriculumBaseError):
    """Критическая системная ошибка"""
    pass


# Assessment-исключения

class AssessmentError(Exception):
    """
    Базовое исключение для всех ошибок в процессе оценки ответов студентов.

    Используется в:
    - AssessmentService
    - AutoAssessorAdapter
    - LLMAssessmentAdapter

    Примеры использования:
    raise AssessmentError("Invalid assessment score: 1.5", task_id=123, response_id=456)
    """

    def __init__(self, message: str, task_id: int = None, response_id: int = None):
        super().__init__(message)
        self.task_id = task_id
        self.response_id = response_id
        self.context = {
            "task_id": task_id,
            "response_id": response_id
        }


class AssessmentValidationError(ValidationError):
    """
    Ошибка валидации результатов оценки.
    Возникает, когда AssessmentNormalizer обнаруживает некорректные данные.

    Примеры:
    - score за пределами [0.0, 1.0]
    - отсутствуют обязательные поля feedback
    - несовместимые типы данных
    """

    def __init__(self, message: str, assessment_id: Optional[int] = None, invalid_fields: list = None):
        context = {
            "assessment_id": assessment_id,
            "invalid_fields": invalid_fields or []
        }
        super().__init__(message, context)


class AssessmentProcessingError(ProcessingError):
    """
    Ошибка при обработке оценки студента.
    Возникает в AssessmentService при сбое оценки.

    Примеры:
    - сбой LLM-провайдера
    - таймаут обработки
    - недоступность внешних сервисов
    """

    def __init__(self, message: str, task_id: int, response_id: Optional[int] = None):
        context = {
            "task_id": task_id,
            "response_id": response_id
        }
        super().__init__(message, context)


class InvalidResponseError(ValidationError):
    """
    Некорректный формат ответа студента.
    Используется в LearningService при валидации входных данных.

    Примеры:
    - пустой текстовый ответ
    - отсутствует аудиофайл для speaking-задания
    - превышена длина ответа
    """

    def __init__(self, message: str, task_type: str, max_length: Optional[int] = None):
        context = {
            "task_type": task_type,
            "max_length": max_length
        }
        super().__init__(message, context)


# Skills-исключения

class SkillUpdateError(ProcessingError):
    """
    Ошибка обновления навыков студента.
    Возникает в SkillUpdateService при сбое расчета навыков.

    Примеры:
    - недостаточно данных для расчета тренда
    - сбой при обновлении SkillTrajectory
    - некорректные delta-значения
    """

    def __init__(self, message: str, student_id: int):
        context = {
            "student_id": student_id
        }
        super().__init__(message, context)


# Learning Process-исключения

class LearningProcessError(ProcessingError):
    """
    Общая ошибка в учебном процессе.
    Базовое исключение для ошибок в LearningService.
    """

    def __init__(self, message: str, enrollment_id: int):
        context = {
            "enrollment_id": enrollment_id
        }
        super().__init__(message, context)


class InvalidTaskError(ValidationError):
    """
    Задание не принадлежит текущему уроку или курсу.
    Проверяется в LearningService при обработке ответа.
    """

    def __init__(self, message: str, task_id: int, lesson_id: int, enrollment_id: int):
        context = {
            "task_id": task_id,
            "lesson_id": lesson_id,
            "enrollment_id": enrollment_id
        }
        super().__init__(message, context)


class EnrollmentError(SystemError):
    """
    Критическая ошибка с зачислением студента.
    Возникает, когда невозможно определить состояние обучения.

    Примеры:
    - несколько активных зачислений
    - отсутствует current_lesson
    - неконсистентные данные в Enrollment
    """

    def __init__(self, message: str, student_id: int, course_id: Optional[int] = None):
        context = {
            "student_id": student_id,
            "course_id": course_id
        }
        super().__init__(message, context)


# Decision-исключения

class DecisionError(ProcessingError):
    """
    Ошибка принятия решения в DecisionService.
    Используется для проблем с логикой adaptivity.
    """

    def __init__(self, message: str, decision_context: dict):
        super().__init__(message, decision_context)


class TeacherOverrideError(SystemError):
    """
    Ошибка при применении переопределения преподавателя.
    Возникает при некорректных данных в TeacherOverride.
    """

    def __init__(self, message: str, override_id: int):
        context = {
            "override_id": override_id
        }
        super().__init__(message, context)


# External Services-исключения

class LLMServiceError(SystemError):
    """
    Ошибка интеграции с LLM-провайдером.
    Используется в LLMAssessmentAdapter и LLMGateway.
    """

    def __init__(self, message: str, provider: str, model: str, status_code: Optional[int] = None):
        context = {
            "provider": provider,
            "model": model,
            "status_code": status_code
        }
        super().__init__(message, context)


class STTServiceError(SystemError):
    """
    Ошибка интеграции с Speech-to-Text сервисом.
    Используется в AutoAssessorAdapter при обработке аудио.
    """

    def __init__(self, message: str, file_size: Optional[int] = None, file_type: Optional[str] = None):
        context = {
            "file_size": file_size,
            "file_type": file_type
        }
        super().__init__(message, context)


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\permissions.py
from rest_framework import permissions
from django.contrib.auth import get_user_model

User = get_user_model()


class IsStudentOrTeacher(permissions.BasePermission):
    """
    Разрешает доступ только студентам и преподавателям.
    Проверяет наличие связанных объектов student или teacher у пользователя.
    """

    def has_permission(self, request, view):
        # Разрешаем доступ только для аутентифицированных пользователей
        if not request.user or not request.user.is_authenticated:
            return False

        # Проверяем наличие профиля студента или преподавателя
        return hasattr(request.user, 'student') or hasattr(request.user, 'teacher')

    def has_object_permission(self, request, view, obj):
        """
        Проверяет права на конкретный объект.
        Для студентов: могут видеть только свой прогресс
        Для преподавателей: могут видеть прогресс своих студентов
        """
        # Если пользователь - студент
        if hasattr(request.user, 'student'):
            student = request.user.student

            # Проверяем, относится ли объект к этому студенту
            if hasattr(obj, 'student'):
                return obj.student == student

            # Для enrollment
            if hasattr(obj, 'enrollment') and hasattr(obj.enrollment, 'student'):
                return obj.enrollment.student == student

            # По умолчанию разрешаем просмотр
            return True

        # Если пользователь - преподаватель
        if hasattr(request.user, 'teacher'):
            teacher = request.user.teacher

            # Преподаватели могут видеть всё в рамках своих курсов
            # Здесь можно добавить более сложную логику
            return True

        return False


class IsEnrolledStudent(permissions.BasePermission):
    """
    Разрешает доступ только зачисленным студентам на конкретный курс/урок
    """

    def has_permission(self, request, view):
        if not request.user.is_authenticated:
            return False

        # Проверяем наличие студента
        if not hasattr(request.user, 'student'):
            return False

        student = request.user.student

        # Получаем course_id из URL параметров или запроса
        course_id = view.kwargs.get('course_id') or request.query_params.get('course_id')

        if not course_id:
            return False

        # Проверяем зачисление
        from curriculum.models.student.enrollment import Enrollment
        return Enrollment.objects.filter(
            student=student,
            course_id=course_id,
            is_active=True
        ).exists()


class IsCourseTeacher(permissions.BasePermission):
    """
    Разрешает доступ только преподавателям, которые ведут конкретный курс
    """

    def has_permission(self, request, view):
        if not request.user.is_authenticated or not hasattr(request.user, 'teacher'):
            return False

        teacher = request.user.teacher
        course_id = view.kwargs.get('course_id') or request.query_params.get('course_id')

        if not course_id:
            return False

        from curriculum.models.content.course import Course
        return Course.objects.filter(
            id=course_id,
            author=teacher
        ).exists()


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\serializers.py


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\tests.py
from django.test import TestCase

# Create your tests here.


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\urls.py
from django.urls import path
from curriculum.views.course_views import (
    CourseListView, CourseDetailView, enroll_in_course
)
from curriculum.views.learning_session_views import (
    LearningSessionView, submit_task_response, LearningSessionTaskView,
    LessonHistoryView, CourseHistoryView
)


app_name = "curriculum"


urlpatterns = [
    path('', CourseListView.as_view(), name='course_list'),
    path('course/<int:pk>/', CourseDetailView.as_view(), name='course_detail'),
    path('enroll/<int:course_id>/', enroll_in_course, name='enroll_course'),

    # Learning Session views
    path('session/<int:pk>/', LearningSessionView.as_view(), name='learning_session'),
    path('session/<int:enrollment_id>/task/<int:task_id>/', LearningSessionTaskView.as_view(),
         name='learning_session_task'),
    path('session/<int:enrollment_id>/submit/', submit_task_response, name='submit_task_response'),

    # История обучения
    path('session/<int:enrollment_id>/lesson/<int:lesson_id>/history/',
         LessonHistoryView.as_view(), name='lesson_history'),
    path('session/<int:enrollment_id>/history/',
         CourseHistoryView.as_view(), name='course_history'),
]


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\urls_api.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from curriculum.views.course_views import enroll_in_course, course_list_api
from curriculum.views.api.course_api import CourseViewSet

app_name = "curriculum-api"

# API Router
router = DefaultRouter()
router.register(r'api/courses', CourseViewSet, basename='api-courses')

urlpatterns = [
    path('enroll/<int:course_id>/', enroll_in_course, name='api_enroll_course'),
    path('courses/', course_list_api, name='api_course_list'),

    # Include API router URLs
    path('', include(router.urls)),
]


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\validators.py
from django.core.exceptions import ValidationError
from django.db import models
from django.utils.translation import gettext_lazy as _

from curriculum.infrastructure.validation.task_schemas import TASK_CONTENT_SCHEMAS


class SkillDomain(models.TextChoices):
    """Области языковых навыков (Skill Domains)."""

    GRAMMAR = ("grammar", _("Грамматика"))
    VOCABULARY = ("vocabulary", _("Лексика"))
    READING = ("reading", _("Чтение"))
    LISTENING = ("listening", _("Аудирование"))
    WRITING = ("writing", _("Письмо"))
    SPEAKING = ("speaking", _("Говорение"))
    # PRONUNCIATION = ("pronunciation", _("Произношение"))
    # USE_OF_ENGLISH = ("use_of_english", _("Использование языка"))
    # DISCOURSE = ("discourse", _("Связность и логика речи"))
    # INTERACTION = ("interaction", _("Коммуникативное взаимодействие"))
    # FLUENCY = ("fluency", _("Беглость речи"))


def validate_skill_focus(value: list[str]) -> None:

    if not isinstance(value, list):
        raise ValidationError("skill_focus must be a list")

    allowed = {choice.value for choice in SkillDomain}

    invalid = set(value) - allowed
    if invalid:
        raise ValidationError(f"Invalid skill(s): {', '.join(invalid)}")


def validate_task_content_schema(content: dict, schema_version: str):
    schema = TASK_CONTENT_SCHEMAS.get(schema_version)
    if not schema:
        raise ValidationError(f"Unknown schema version: {schema_version}")

    missing = schema["required"] - content.keys()
    if missing:
        raise ValidationError(f"Missing fields: {missing}")


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\views.py
from django.shortcuts import render

# Create your views here.


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\application\ports\assessment_port.py
# curriculum/application/ports/assessment_port.py
from abc import ABC, abstractmethod

from curriculum.domain.value_objects.assessment_result import AssessmentResult
from curriculum.models.assessment.student_response import StudentTaskResponse
from curriculum.models.content.task import Task


class AssessmentPort(ABC):
    """Порт для оценки ответов студентов"""

    @abstractmethod
    def assess_task(self, task: Task, response: StudentTaskResponse) -> AssessmentResult:
        """Оценка заданий"""
        pass


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\config\dependency_factory.py
from ai.llm.llm_factory import llm_factory
from curriculum.services.assessment.assessment_service import AssessmentService
from curriculum.services.enrollment_service import EnrollmentService
from curriculum.services.skills.skill_update_service import SkillUpdateService
from curriculum.services.decisions.decision_service import DecisionService
from curriculum.services.progression.progression_service import ProgressionService
from curriculum.services.progression.transition_recorder import TransitionRecorder
from curriculum.services.curriculum_query import CurriculumQueryService
from curriculum.services.learning_service import LearningService
from curriculum.infrastructure.adapters.auto_assessment_adapter import AutoAssessorAdapter
from curriculum.infrastructure.adapters.llm_assessment_adapter import LLMAssessmentAdapter


class CurriculumServiceFactory:
    """
    Фабрика для создания и внедрения зависимостей
    Следует паттерну Singleton для обеспечения согласованности зависимостей
    """
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._initialize()
        return cls._instance

    def _initialize(self):
        """Инициализация всех сервисов и зависимостей"""

        # Speech-to-Text сервис (вместо ASR)
        # self.speech_to_text_service = SpeechToTextFactory().get_service()

        # AutoAssessorAdapter для закрытых заданий и аудио
        self.auto_adapter = AutoAssessorAdapter()

        # LLMAssessmentAdapter для открытых заданий
        self.llm_adapter = LLMAssessmentAdapter()

        # Assessment Service (с выбором адаптера в зависимости от типа задания)
        self.assessment_service = AssessmentService(
            auto_adapter=self.auto_adapter,
            llm_adapter=self.llm_adapter
        )

        # Основные сервисы учебного процесса
        self.curriculum_query = CurriculumQueryService()
        self.skill_update_service = SkillUpdateService()
        self.decision_service = DecisionService()
        self.progression_service = ProgressionService(
            curriculum_query=self.curriculum_query
        )
        self.transition_recorder = TransitionRecorder()

        # Enrollment Service для управления зачислениями
        self.enrollment_service = EnrollmentService(
            curriculum_query=self.curriculum_query
        )

    def create_learning_service(self) -> LearningService:
        """Создает LearningService со всеми зависимостями"""
        return LearningService(
            curriculum_query=self.curriculum_query,
            assessment_service=self.assessment_service,
            skill_update_service=self.skill_update_service,
            decision_service=self.decision_service,
            progression_service=self.progression_service,
            transition_recorder=self.transition_recorder,
            enrollment_service=self.enrollment_service
        )

    def create_enrollment_service(self) -> EnrollmentService:
        """Создает EnrollmentService с зависимостями"""
        return self.enrollment_service

    def get_assessment_service(self) -> AssessmentService:
        """Возвращает AssessmentService для прямого использования"""
        return self.assessment_service

    def get_llm_factory(self):
        """Возвращает глобальную фабрику LLM для специализированных операций"""
        return llm_factory

    def get_curriculum_query_service(self) -> CurriculumQueryService:
        """Возвращает CurriculumQueryService"""
        return self.curriculum_query

    @classmethod
    def reset_instance(cls):
        """Сбрасывает singleton инстанс (для тестирования)"""
        cls._instance = None

#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\domain\value_objects\assessment_result.py
from dataclasses import dataclass
from typing import Optional, List, Dict, Any
from enum import Enum


class AssessmentGrade(Enum):
    EXCELLENT = "excellent"  # 90-100%
    GOOD = "good"  # 70-89%
    SATISFACTORY = "satisfactory"  # 50-69%
    POOR = "poor"  # <50%


@dataclass(frozen=True)
class AssessmentResult:
    """
    Чистый доменный объект результата оценки.
    Не зависит от Django или базы данных!
    """
    score: float  # 0.0 - 1.0
    is_correct: Optional[bool] = None  # None для открытых заданий
    grade: AssessmentGrade = AssessmentGrade.POOR
    error_tags: List[str] = None
    feedback: Dict[str, Any] = None
    confidence: float = 1.0  # Для LLM-оценок

    def __post_init__(self):
        # Автоматический расчет grade на основе score
        object.__setattr__(self, 'grade', self._calculate_grade())

        # Защита от некорректных значений
        if not (0.0 <= self.score <= 1.0):
            raise ValueError("Score must be between 0.0 and 1.0")
        if not (0.0 <= self.confidence <= 1.0):
            raise ValueError("Confidence must be between 0.0 and 1.0")

        # Инициализация пустых списков/словарей
        if self.error_tags is None:
            object.__setattr__(self, 'error_tags', [])
        if self.feedback is None:
            object.__setattr__(self, 'feedback', {})

    def _calculate_grade(self) -> AssessmentGrade:
        if self.score >= 0.9:
            return AssessmentGrade.EXCELLENT
        elif self.score >= 0.7:
            return AssessmentGrade.GOOD
        elif self.score >= 0.5:
            return AssessmentGrade.SATISFACTORY
        return AssessmentGrade.POOR

    def to_persistence_dict(self) -> dict:
        """Конвертация в формат для сохранения в Django-модель"""
        return {
            'score': self.score,
            'is_correct': self.is_correct,
            'grade': self.grade.value,
            'error_tags': self.error_tags,
            'feedback': self.feedback,
            'confidence': self.confidence
        }

#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\infrastructure\adapters\auto_assessment_adapter.py
# import logging
#
# from curriculum.application.ports.assessment_port import AssessmentPort
# from curriculum.models.assessment.assessment import Assessment
# from curriculum.models.assessment.student_response import StudentTaskResponse
# from curriculum.models.content.task import Task, ResponseFormat
#
# logger = logging.getLogger(__name__)
#
#
# class AutoAssessorAdapter(AssessmentPort):
#     """
#     Адаптер для автоматической оценки закрытых заданий.
#     """
#
#     def __init__(self,):
#         """
#         Инициализация адаптера
#
#         Args:
#             asr_service: Сервис для распознавания речи (опционально, создается по умолчанию)
#         """
#         # self.speech_to_text_service = SpeechToTextFactory().get_service()
#
#     def assess_task(self, task: Task, response: StudentTaskResponse) -> Assessment:
#         """Единая точка входа, выбор стратегии внутри"""
#         if task.response_format in [ResponseFormat.SINGLE_CHOICE, ResponseFormat.MULTIPLE_CHOICE]:
#             return self._assess_closed_task(task, response)
#         elif task.response_format == ResponseFormat.SHORT_TEXT:
#             return self._assess_short_text(task, response)
#         elif task.response_format == ResponseFormat.AUDIO:
#             return self._assess_audio(task, response)  # обработка аудио внутри
#         else:
#             return self._create_fallback_assessment(task, response)
#
#     def _assess_audio(self, task: Task, response: StudentTaskResponse) -> Assessment:
#         """
#         Обработка аудио ответов с использованием ASR и правил
#         (без LLM, так как это Auto-ассессор)
#         """
#         try:
#             # Шаг 1: Проверка наличия аудио файла
#             if not response.audio_file:
#                 return self._create_error_assessment(task, response, "No audio file provided")
#
#             # Шаг 2: Анализ аудио через ASR
#             asr_result = self._analyze_audio_with_asr(response.audio_file)
#
#             # Шаг 3: Базовая оценка на основе ASR-результата
#             score = self._calculate_audio_score(asr_result)
#
#             # Шаг 4: Создание Assessment
#             assessment = Assessment.objects.create(
#                 task_response=response,
#                 llm_version="auto-audio-v1",
#                 raw_output={
#                     "asr_transcript": asr_result.get("transcript"),
#                     "asr_confidence": asr_result.get("confidence"),
#                     "duration_sec": asr_result.get("duration")
#                 },
#                 structured_feedback={
#                     "score": score,
#                     "is_correct": None,  # Для аудио нет бинарной корректности
#                     "error_tags": self._detect_audio_errors(asr_result),
#                     "feedback": self._generate_audio_feedback(asr_result, score)
#                 },
#                 score=score  # Прямое сохранение оценки в диапазоне 0.0-1.0
#             )
#
#             return assessment
#
#         except Exception as e:
#             return self._create_error_assessment(task, response, f"Audio processing failed: {str(e)}")
#
#     def _assess_closed_task(self, task: Task, response: StudentTaskResponse) -> Assessment:
#         """
#         Оценка закрытых заданий (MCQ) - только mcq_v1
#         """
#         if task.content_schema_version == "mcq_v1":
#             try:
#                 student_choice = int(response.response_text.strip())
#                 correct_idx = task.content["correct_idx"]
#                 is_correct = (student_choice == correct_idx)
#                 score = 1.0 if is_correct else 0.0
#
#                 # Создаем Assessment
#                 assessment = Assessment.objects.create(
#                     task_response=response,
#                     llm_version="auto-mcq-v1",
#                     raw_output={
#                         "student_choice": student_choice,
#                         "correct_idx": correct_idx,
#                         "task_content": task.content
#                     },
#                     structured_feedback={
#                         "score": score,
#                         "is_correct": is_correct,
#                         "error_tags": [] if is_correct else ["concept_gap"],
#                         "feedback": {
#                             "hint": "Правильный ответ" if is_correct else task.content.get("explanation",
#                                                                                            "Попробуйте ещё раз")
#                         }
#                     },
#                     score=score  # Прямое сохранение оценки
#                 )
#                 return assessment
#             except (ValueError, TypeError, KeyError) as e:
#                 return self._create_error_assessment(task, response, str(e))
#
#         # Если версия схемы не поддерживается
#         return self._create_error_assessment(
#             task,
#             response,
#             f"Unsupported schema version: {task.content_schema_version}"
#         )
#
#     def _assess_short_text(self, task: Task, response: StudentTaskResponse) -> Assessment:
#         """
#         Оценка кратких текстовых ответов
#         """
#         student_answer = response.response_text.strip().lower()
#         correct_answers = [ans.lower() for ans in task.content.get("correct", [])]
#         case_sensitive = task.content.get("case_sensitive", False)
#
#         if case_sensitive:
#             student_answer = response.response_text.strip()
#             correct_answers = task.content.get("correct", [])
#
#         # Простая проверка на совпадение
#         is_correct = any(self._fuzzy_match(student_answer, correct) for correct in correct_answers)
#         score = 1.0 if is_correct else 0.0
#
#         assessment = Assessment.objects.create(
#             task_response=response,
#             llm_version="auto-short-text-v1",
#             raw_output={
#                 "student_answer": student_answer,
#                 "correct_answers": correct_answers,
#                 "case_sensitive": case_sensitive
#             },
#             structured_feedback={
#                 "score": score,
#                 "is_correct": is_correct,
#                 "error_tags": [] if is_correct else ["concept_mismatch"],
#                 "feedback": {
#                     "hint": "Верный ответ!" if is_correct else "Попробуйте ещё раз"
#                 }
#             },
#             score=score  # Прямое сохранение оценки
#         )
#
#         return assessment
#
#     def _fuzzy_match(self, answer: str, correct_answer: str, threshold: float = 0.8) -> bool:
#         """
#         Простая fuzzy-проверка для неточных совпадений.
#         """
#         return answer.strip() == correct_answer.strip()
#
#     def _create_error_assessment(self, task: Task, response: StudentTaskResponse, error: str) -> Assessment:
#         """
#         Создает Assessment с информацией об ошибке обработки.
#         """
#         return Assessment.objects.create(
#             task_response=response,
#             llm_version="auto-error",
#             raw_output={"error": error},
#             structured_feedback={
#                 "score": 0.0,
#                 "is_correct": False,
#                 "error_tags": ["processing_error"],
#                 "feedback": {"error": f"Ошибка обработки: {error}"}
#             },
#             score=0.0  # Ошибка - минимальная оценка
#         )
#
#     def _create_fallback_assessment(self, task: Task, response: StudentTaskResponse) -> Assessment:
#         """
#         Заглушка для открытых форматов ответов.
#         """
#         return Assessment.objects.create(
#             task_response=response,
#             llm_version="auto-fallback",
#             raw_output={"message": "Требуется ручная оценка или интеграция с LLM"},
#             structured_feedback={
#                 "score": 0.7,
#                 "is_correct": None,
#                 "error_tags": [],
#                 "feedback": {
#                     "message": "Отличная попытка! Этот ответ будет дополнительно проверен.",
#                     "note": "Для полноценной оценки требуется интеграция с LLM"
#                 }
#             },
#             score=0.7  # Нейтральная оценка для заглушки
#         )
#
#     def _analyze_audio_with_asr(self, audio_file):
#         """
#         Интеграция с ASR сервисом
#         """
#         try:
#             result = self.speech_to_text_service.transcribe(audio_file)
#             return {
#                 'transcript': result.get('text', ''),
#                 'confidence': result.get('confidence', 0.0),
#                 'duration': result.get('duration', 0.0),
#                 'word_timings': result.get('word_timings', []),
#                 'audio_quality': result.get('audio_quality', 'good')
#             }
#         except Exception as e:
#             logger.error(f"ASR transcription failed: {str(e)}")
#             return {
#                 'transcript': "",
#                 'confidence': 0.0,
#                 'duration': 0.0,
#                 'word_timings': [],
#                 'audio_quality': 'poor'
#             }
#
#     def _calculate_audio_score(self, asr_result):
#         """
#         Расчет оценки для аудио ответа на основе:
#         - уверенности ASR
#         - длины ответа
#         - качества аудио
#         """
#         confidence = asr_result.get('confidence', 0.0)
#         duration = asr_result.get('duration', 0.0)
#         audio_quality = asr_result.get('audio_quality', 'good')
#
#         # Базовая оценка на основе уверенности ASR
#         base_score = confidence
#
#         # Штраф за слишком короткие ответы (менее 3 секунд)
#         if duration < 3.0:
#             base_score *= 0.7
#
#         # Штраф за плохое качество аудио
#         if audio_quality == 'poor':
#             base_score *= 0.6
#         elif audio_quality == 'medium':
#             base_score *= 0.8
#
#         # Нормализация в диапазон 0-1
#         return max(0.0, min(1.0, base_score * 0.9 + 0.1))
#
#     def _detect_audio_errors(self, asr_result):
#         """
#         Определение типов ошибок в устной речи
#         """
#         errors = []
#         confidence = asr_result.get('confidence', 0.0)
#         audio_quality = asr_result.get('audio_quality', 'good')
#         duration = asr_result.get('duration', 0.0)
#
#         if confidence < 0.3:
#             errors.append("unclear_speech")
#         if audio_quality == 'poor':
#             errors.append("audio_quality_issues")
#         if duration < 2.0:
#             errors.append("too_short_response")
#
#         return errors
#
#     def _generate_audio_feedback(self, asr_result, score):
#         """
#         Генерация обратной связи для аудио ответа
#         """
#         confidence = asr_result.get('confidence', 0.0)
#         duration = asr_result.get('duration', 0.0)
#         transcript = asr_result.get('transcript', '')
#
#         if score >= 0.8:
#             return {
#                 "message": "Отличное произношение! Ответ был четким и понятным.",
#                 "transcript": transcript,
#                 "confidence": confidence
#             }
#         elif score >= 0.6:
#             return {
#                 "message": "Хорошая попытка! Постарайтесь говорить немного четче и громче.",
#                 "transcript": transcript,
#                 "confidence": confidence
#             }
#         else:
#             feedback = "Нужно улучшить произношение. "
#             if confidence < 0.4:
#                 feedback += "Система не смогла распознать вашу речь. Попробуйте говорить четче. "
#             if duration < 3.0:
#                 feedback += "Ваш ответ был слишком коротким. Попробуйте ответить более развернуто."
#
#             return {
#                 "message": feedback.strip(),
#                 "transcript": transcript,
#                 "confidence": confidence
#             }

import logging
import traceback

from django.conf import settings
from django.utils import timezone

from curriculum.application.ports.assessment_port import AssessmentPort
from curriculum.models.assessment.assessment import Assessment
from curriculum.models.assessment.student_response import StudentTaskResponse
from curriculum.models.content.task import Task, ResponseFormat
from curriculum.infrastructure.validation.task_schemas import TASK_CONTENT_SCHEMAS

logger = logging.getLogger(__name__)


class SchemaValidationError(Exception):
    """Исключение для ошибок валидации схемы контента задания"""
    pass


class AutoAssessorAdapter(AssessmentPort):
    """
    Адаптер для автоматической оценки закрытых заданий.
    КОРРЕКТНАЯ АРХИТЕКТУРА С ПОДДЕРЖКОЙ СХЕМ ВАЛИДАЦИИ.

    Основные принципы:
    1. Поддерживаемые форматы и схемы:
       - SINGLE_CHOICE + scq_v1
       - MULTIPLE_CHOICE + mcq_v1 (заглушка)
       - SHORT_TEXT + short_text_v1
    2. Централизованная валидация через TASK_CONTENT_SCHEMAS
    3. Четкое соответствие схемам и форматам ответов
    4. Расширяемая архитектура для новых схем

    АРХИТЕКТУРНЫЕ ИСПРАВЛЕНИЯ:
    - ИСПРАВЛЕНА номенклатура схем (scq_v1 для одиночного выбора)
    - УДАЛЕНА обработка AUDIO (требует LLMAssessor)
    - ДОБАВЛЕНА валидация типов и диапазонов
    - РЕАЛИЗОВАНА поддержка множественных правильных ответов для SHORT_TEXT
    """

    def __init__(self):
        """Инициализация без зависимостей"""
        pass

    def assess_task(self, task: Task, response: StudentTaskResponse) -> Assessment:
        """
        Основной метод оценки с валидацией схемы.

        Алгоритм:
        1. Проверка соответствия формата задания и схемы
        2. Валидация контента по схеме
        3. Выбор стратегии оценки
        4. Обработка ошибок с информативными сообщениями

        Args:
            task: Задание для оценки
            response: Ответ студента

        Returns:
            Assessment: Результат оценки в правильном формате
        """
        try:
            # 1. Валидация соответствия формата и схемы
            self._validate_format_schema_compatibility(task)

            # 2. Валидация контента по схеме
            schema = self._get_schema_for_task(task)
            self._validate_task_content(task.content, schema)

            # 3. Выбор стратегии оценки
            if task.response_format == ResponseFormat.SINGLE_CHOICE:
                return self._assess_single_choice(task, response)
            elif task.response_format == ResponseFormat.MULTIPLE_CHOICE:
                return self._assess_multiple_choice(task, response)
            elif task.response_format == ResponseFormat.SHORT_TEXT:
                return self._assess_short_text(task, response)

        except SchemaValidationError as e:
            logger.error(f"Schema validation failed for task {task.pk}: {str(e)}")
            return self._create_schema_error_assessment(
                task, response,
                f"Schema validation error: {str(e)}",
                schema_name=task.content_schema_version
            )
        except Exception as e:
            logger.error(f"Critical error in assess_task: {str(e)}", exc_info=True)
            return self._create_critical_error_assessment(task, response, str(e))

    def _validate_format_schema_compatibility(self, task: Task) -> None:
        """
        Проверяет соответствие формата задания и схемы контента.

        Примеры корректных пар:
        - SINGLE_CHOICE + scq_v1
        - MULTIPLE_CHOICE + mcq_v1
        - SHORT_TEXT + short_text_v1

        Raises:
            SchemaValidationError: При несоответствии формата и схемы
        """
        schema_name = task.content_schema_version
        response_format = task.response_format

        if schema_name not in TASK_CONTENT_SCHEMAS:
            raise SchemaValidationError(f"Unknown schema: {schema_name}")

        schema = TASK_CONTENT_SCHEMAS[schema_name]
        supported_formats = schema.get("supported_formats", [])

        if response_format not in supported_formats:
            raise SchemaValidationError(
                f"Schema '{schema_name}' does not support response format '{response_format}'. "
                f"Supported formats: {supported_formats}"
            )

    def _get_schema_for_task(self, task: Task) -> dict:
        """
        Получает схему валидации для задания.

        Raises:
            SchemaValidationError: Если схема не найдена
        """
        schema_name = task.content_schema_version
        if schema_name not in TASK_CONTENT_SCHEMAS:
            raise SchemaValidationError(f"Schema not found: {schema_name}")
        return TASK_CONTENT_SCHEMAS[schema_name]

    def _validate_task_content(self, content: dict, schema: dict) -> None:
        """
        Валидация контента задания по схеме.

        Проверяет:
        1. Наличие обязательных полей
        2. Корректность типов данных
        3. Диапазоны значений
        4. Ссылочные ограничения (reference)

        Args:
            content: Контент задания
            schema: Схема валидации

        Raises:
            SchemaValidationError: При нарушении правил валидации
        """
        # 1. Проверка обязательных полей
        required_fields = schema.get("required", set())
        missing_fields = required_fields - set(content.keys())
        if missing_fields:
            raise SchemaValidationError(f"Missing required fields: {missing_fields}")

        # 2. Проверка правил валидации для каждого поля
        validation_rules = schema.get("validation_rules", {})
        for field_name, rules in validation_rules.items():
            if field_name not in content and field_name not in schema.get("optional", set()):
                continue

            field_value = content.get(field_name)
            if field_value is None:
                continue

            # Проверка типа
            expected_type = rules.get("type")
            if expected_type:
                if not self._validate_type(field_value, expected_type):
                    raise SchemaValidationError(
                        f"Field '{field_name}' must be {expected_type}, got {type(field_value).__name__}"
                    )

            # Специфические правила валидации
            if expected_type == "list":
                self._validate_list_field(field_value, rules, field_name)
            elif expected_type == "int":
                self._validate_int_field(field_value, rules, field_name)
            elif expected_type == "str":
                self._validate_str_field(field_value, rules, field_name)

    def _validate_type(self, value, expected_type: str) -> bool:
        """Проверка типа значения"""
        type_mapping = {
            "str": str,
            "int": int,
            "bool": bool,
            "list": list,
            "dict": dict
        }

        expected_python_type = type_mapping.get(expected_type)
        if not expected_python_type:
            return True  # Неизвестный тип - пропускаем проверку

        return isinstance(value, expected_python_type)

    def _validate_list_field(self, value: list, rules: dict, field_name: str) -> None:
        """Валидация поля типа list"""
        # Проверка длины списка
        min_items = rules.get("min_items")
        max_items = rules.get("max_items")

        if min_items is not None and len(value) < min_items:
            raise SchemaValidationError(f"Field '{field_name}' must have at least {min_items} items")
        if max_items is not None and len(value) > max_items:
            raise SchemaValidationError(f"Field '{field_name}' must have at most {max_items} items")

        # Проверка типа элементов
        item_type = rules.get("item_type")
        if item_type:
            for idx, item in enumerate(value):
                if not self._validate_type(item, item_type):
                    raise SchemaValidationError(
                        f"Item at index {idx} in field '{field_name}' must be {item_type}, "
                        f"got {type(item).__name__}"
                    )

    def _validate_int_field(self, value: int, rules: dict, field_name: str) -> None:
        """Валидация поля типа int"""
        # Проверка минимума
        min_value = rules.get("min")
        if min_value is not None and value < min_value:
            raise SchemaValidationError(f"Field '{field_name}' must be at least {min_value}")

        # Проверка максимума/ссылки
        reference = rules.get("reference")
        if reference:
            # Простая поддержка ссылок на длину списка
            if reference == "options.length - 1" and "options" in rules:
                max_value = len(rules["options"]) - 1
                if value > max_value:
                    raise SchemaValidationError(
                        f"Field '{field_name}' must be at most {max_value} (options length - 1)"
                    )
            elif reference == "options.length" and "options" in rules:
                max_value = len(rules["options"])
                if value > max_value:
                    raise SchemaValidationError(
                        f"Field '{field_name}' must be at most {max_value} (options length)"
                    )

    def _validate_str_field(self, value: str, rules: dict, field_name: str) -> None:
        """Валидация поля типа str"""
        min_length = rules.get("min_length")
        if min_length is not None and len(value) < min_length:
            raise SchemaValidationError(f"Field '{field_name}' must be at least {min_length} characters long")

    def _assess_single_choice(self, task: Task, response: StudentTaskResponse) -> Assessment:
        """
        Оценка заданий с одиночным выбором (scq_v1).

        Логика:
        1. Парсинг числового индекса или поиск по тексту
        2. Сравнение с correct_idx
        3. Формирование структурированной обратной связи
        """
        try:
            student_choice = self._parse_student_choice_scq(response.response_text, task)
            correct_idx = task.content["correct_idx"]
            is_correct = (student_choice == correct_idx)
            score = 1.0 if is_correct else 0.0

            # СТРУКТУРИРОВАННАЯ ОБРАТНАЯ СВЯЗЬ
            options = task.content["options"]
            explanation = task.content.get("explanation", "Попробуйте ещё раз")

            structured_feedback = {
                "score_grammar": score if task.task_type == "grammar" else 0.5,
                "score_vocabulary": score if task.task_type == "vocabulary" else 0.5,
                "errors": [] if is_correct else [{
                    "type": "concept_gap",
                    "example": f"Выбран вариант: {options[student_choice]}",
                    "correction": f"Правильный вариант: {options[correct_idx]}"
                }],
                "strengths": ["Правильный выбор варианта"] if is_correct else [],
                "suggestions": [] if is_correct else [explanation],
                "metadata": {
                    "overall_score": score,
                    "is_correct": is_correct,
                    "student_choice": student_choice,
                    "correct_idx": correct_idx,
                    "schema_version": task.content_schema_version
                }
            }

            return Assessment.objects.create(
                task_response=response,
                llm_version="auto-scq-v1",
                raw_output={
                    "student_input": response.response_text,
                    "student_idx": student_choice,
                    "correct_idx": correct_idx,
                    "task_content": task.content
                },
                structured_feedback=structured_feedback
            )

        except (ValueError, TypeError, KeyError) as e:
            return self._create_error_assessment(
                task, response,
                f"Single choice processing error: {str(e)}"
            )

    def _parse_student_choice_scq(self, response_text: str, task: Task) -> int:
        """
        Парсинг ответа для одиночного выбора.
        Поддерживает:
        - Числовые индексы (0, 1, 2...)
        - Точный текст варианта
        """
        response_text = response_text.strip()

        # 1. Попытка преобразовать в число
        if response_text.isdigit():
            choice_idx = int(response_text)
            if 0 <= choice_idx < len(task.content["options"]):
                return choice_idx

        # 2. Поиск по тексту варианта (регистронезависимый)
        student_text = response_text.lower()
        options = task.content["options"]

        for idx, option in enumerate(options):
            if student_text == option.lower().strip():
                return idx

        # 3. Частичное совпадение (только для отладки)
        for idx, option in enumerate(options):
            if student_text in option.lower():
                logger.debug(f"Partial match found: '{student_text}' in '{option}'")
                return idx

        raise ValueError(f"Invalid choice: '{response_text}' not found in options")

    def _assess_multiple_choice(self, task: Task, response: StudentTaskResponse) -> Assessment:
        """
        Оценка заданий с множественным выбором (mcq_v1).
        ТЕКУЩАЯ РЕАЛИЗАЦИЯ - ЗАГЛУШКА.

        В будущем будет реализовано сравнение списков индексов.
        """
        logger.warning(f"MULTIPLE_CHOICE task {task.pk} processed with stub. Full support coming soon.")

        return Assessment.objects.create(
            task_response=response,
            llm_version="auto-mcq-v1-stub",
            raw_output={"warning": "MULTIPLE_CHOICE not fully implemented in AutoAssessor"},
            structured_feedback={
                "score_grammar": 0.5,
                "score_vocabulary": 0.5,
                "errors": [{
                    "type": "feature_limitation",
                    "example": "MULTIPLE_CHOICE format",
                    "correction": "Полная поддержка будет добавлена в будущих версиях"
                }],
                "strengths": [],
                "suggestions": [
                    "Система пока не поддерживает множественный выбор с автоматической оценкой. "
                    "Используйте одиночный выбор или запросите ручную оценку."
                ],
                "metadata": {
                    "overall_score": 0.5,
                    "is_correct": None,
                    "feature_status": "planned",
                    "recommendation": "use_single_choice_or_llm"
                }
            }
        )

    def _assess_short_text(self, task: Task, response: StudentTaskResponse) -> Assessment:
        """
        Оценка кратких текстовых ответов (short_text_v1).

        Поддерживает:
        - Регистрозависимую/независимую проверку
        - Множественные правильные ответы
        - Ограничения по длине
        """
        content = task.content
        student_answer = response.response_text.strip()

        # 1. Валидация длины ответа
        min_length = content.get("min_length", 1)
        max_length = content.get("max_length", 100)

        if len(student_answer) < min_length:
            return self._create_error_assessment(
                task, response,
                f"Answer too short. Minimum {min_length} characters required."
            )
        if len(student_answer) > max_length:
            return self._create_error_assessment(
                task, response,
                f"Answer too long. Maximum {max_length} characters allowed."
            )

        # 2. Проверка правильных ответов
        correct_answers = content.get("correct_answers", [])
        case_sensitive = content.get("case_sensitive", False)

        if not correct_answers:
            # Если нет правильных ответов - считаем все ответы верными
            logger.warning(f"Task {task.pk} has no correct_answers defined. All responses will be accepted.")
            is_correct = True
            score = 1.0
        else:
            if case_sensitive:
                is_correct = student_answer in correct_answers
            else:
                student_lower = student_answer.lower()
                correct_lower = [ans.lower() for ans in correct_answers]
                is_correct = student_lower in correct_lower

            score = 1.0 if is_correct else 0.0

        # 3. Формирование обратной связи
        structured_feedback = {
            "score_grammar": 0.5,  # SHORT_TEXT не оценивает grammar напрямую
            "score_vocabulary": score if task.task_type == "vocabulary" else 0.5,
            "errors": [] if is_correct else [{
                "type": "spelling" if case_sensitive else "concept_mismatch",
                "example": student_answer,
                "correction": correct_answers[0] if correct_answers else "правильный ответ"
            }],
            "strengths": ["Точный ответ"] if is_correct else [],
            "suggestions": ["Отлично!"] if is_correct else ["Проверьте правильность написания"],
            "metadata": {
                "overall_score": score,
                "is_correct": is_correct,
                "case_sensitive": case_sensitive,
                "answer_length": len(student_answer),
                "schema_version": task.content_schema_version
            }
        }

        return Assessment.objects.create(
            task_response=response,
            llm_version="auto-short-text-v1",
            raw_output={
                "student_input": student_answer,
                "correct_answers": correct_answers,
                "case_sensitive": case_sensitive,
                "answer_length": len(student_answer)
            },
            structured_feedback=structured_feedback
        )

    # ================ ОБРАБОТКА ОШИБОК ================

    def _create_error_assessment(self, task: Task, response: StudentTaskResponse, error: str) -> Assessment:
        """Создает Assessment для обработки ошибок"""
        return Assessment.objects.create(
            task_response=response,
            llm_version="auto-error",
            raw_output={"error": error, "task_id": task.pk},
            structured_feedback={
                "score_grammar": 0.5,
                "score_vocabulary": 0.5,
                "errors": [{
                    "type": "processing_error",
                    "example": error,
                    "correction": "Ответ будет проверен преподавателем"
                }],
                "strengths": [],
                "suggestions": ["Произошла техническая ошибка. Ваш ответ сохранен и будет проверен вручную."],
                "metadata": {
                    "overall_score": 0.5,
                    "status": "requires_manual_review"
                }
            }
        )

    def _create_schema_error_assessment(
            self,
            task: Task,
            response: StudentTaskResponse,
            error: str,
            schema_name: str = None
    ) -> Assessment:
        """
        Создает Assessment для ошибок валидации схемы.

        Args:
            task: Задание с некорректной схемой
            response: Ответ студента
            error: Описание ошибки валидации
            schema_name: Имя схемы (опционально)

        Returns:
            Assessment: Результат с информацией об ошибке схемы
        """
        # Формируем детальное сообщение об ошибке
        error_details = {
            "validation_error": error,
            "task_id": task.pk,
            "schema_name": schema_name or task.content_schema_version,
            "submitted_schema_version": task.content_schema_version,
            "content_keys": list(task.content.keys()) if task.content else [],
            "timestamp": timezone.now().isoformat()
        }

        return Assessment.objects.create(
            task_response=response,
            llm_version="schema-error",
            raw_output=error_details,
            structured_feedback={
                "score_grammar": 0.5,
                "score_vocabulary": 0.5,
                "errors": [{
                    "type": "invalid_task_schema",
                    "example": f"Схема '{schema_name or task.content_schema_version}' не прошла валидацию",
                    "correction": "Задание содержит ошибку в конфигурации. Преподаватель будет уведомлен."
                }],
                "strengths": [],
                "suggestions": [
                    "Это задание содержит техническую ошибку и не может быть оценено автоматически.",
                    "Ваш ответ был сохранен и будет проверен преподавателем вручную.",
                    "Прогресс в обучении не будет потерян."
                ],
                "metadata": {
                    "overall_score": 0.5,
                    "schema_status": "invalid",
                    "schema_name": schema_name or task.content_schema_version,
                    "requires_manual_review": True,
                    "error_type": "schema_validation",
                    "admin_notification_sent": True
                }
            }
        )

    def _create_critical_error_assessment(
            self,
            task: Task,
            response: StudentTaskResponse,
            error: str
    ) -> Assessment:
        """
        Создает Assessment для критических ошибок системы.

        Используется для обработки непредвиденных исключений, которые
        могут нарушить учебный процесс. Обеспечивает graceful degradation.

        Args:
            task: Задание, при обработке которого произошла ошибка
            response: Ответ студента
            error: Описание критической ошибки

        Returns:
            Assessment: Результат с информацией о системном сбое
        """
        # Детальное логирование для администраторов
        admin_alert = {
            "critical_error": error,
            "task_id": task.pk,
            "student_id": response.student.id if response.student else None,
            "task_type": task.task_type,
            "response_format": task.response_format,
            "schema_version": task.content_schema_version,
            "timestamp": timezone.now().isoformat(),
            "traceback": traceback.format_exc() if settings.DEBUG else None
        }

        # Безопасное создание Assessment (обработка возможных ошибок)
        try:
            return Assessment.objects.create(
                task_response=response,
                llm_version="critical-error",
                raw_output=admin_alert,
                structured_feedback={
                    "score_grammar": 0.5,
                    "score_vocabulary": 0.5,
                    "errors": [{
                        "type": "system_failure",
                        "example": "Системная ошибка при обработке задания",
                        "correction": "Техническая поддержка уже работает над решением проблемы"
                    }],
                    "strengths": [],
                    "suggestions": [
                        "К сожалению, произошла временная техническая проблема.",
                        "Ваш ответ был сохранен и будет обработан автоматически позже.",
                        "Вы можете продолжить обучение с следующего задания.",
                        "Если проблема сохраняется, обратитесь в поддержку."
                    ],
                    "metadata": {
                        "overall_score": 0.0,
                        "status": "system_down",
                        "retry_after": "5 minutes",
                        "requires_manual_intervention": True,
                        "admin_notified": True,
                        "error_severity": "critical",
                        "fallback_applied": True
                    }
                }
            )
        except Exception as db_error:
            # Крайний случай: даже создание Assessment не удалось
            logger.critical(
                f"CRITICAL FAILURE: Could not create error assessment. Original error: {error}, DB error: {str(db_error)}")

            # Попытка минимального сохранения
            try:
                return Assessment.objects.create(
                    task_response=response,
                    llm_version="fallback-critical",
                    raw_output={"emergency_fallback": True, "original_error": str(error)},
                    structured_feedback={
                        "score_grammar": 0.5,
                        "score_vocabulary": 0.5,
                        "errors": [{"type": "emergency_fallback", "example": "System emergency",
                                    "correction": "Admin intervention required"}],
                        "strengths": [],
                        "suggestions": ["Система восстановлена в аварийном режиме. Обратитесь в поддержку."],
                        "metadata": {
                            "overall_score": 0.0,
                            "status": "emergency_fallback",
                            "admin_notified": False
                        }
                    }
                )
            except Exception as final_error:
                logger.critical(f"ABSOLUTE FAILURE: Could not create fallback assessment. Error: {str(final_error)}")
                raise RuntimeError("System in unrecoverable state") from final_error


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\infrastructure\adapters\llm_assessment_adapter.py
import json

from ai.llm.llm_factory import llm_factory
from curriculum.application.ports.assessment_port import AssessmentPort
from curriculum.domain.value_objects.assessment_result import AssessmentResult
from curriculum.models.assessment.student_response import StudentTaskResponse
from curriculum.models.content.task import Task, ResponseFormat


class LLMAssessmentAdapter(AssessmentPort):
    """
    Адаптер для оценки с использованием LLM через llm_factory
    """

    def __init__(self):
        # Используем глобальный экземпляр llm_factory
        self.llm_factory = llm_factory

    def assess_task(self, task: Task, response: StudentTaskResponse) -> AssessmentResult:
        """
        Единая точка входа для оценки через LLM
        """
        try:
            # Формируем системный промпт в зависимости от типа задания
            system_prompt = self._build_system_prompt(task)

            # Формируем пользовательское сообщение
            user_message = self._build_user_message(task, response)

            # Генерируем оценку через llm_factory
            return self._generate_llm_assessment(
                task=task,
                response=response,
                system_prompt=system_prompt,
                user_message=user_message
            )
        except Exception as e:
            return self._create_fallback_result(task, str(e))

    def _build_system_prompt(self, context: dict) -> str:
        """Формирование системного промпта для LLM на основе контекста"""
        task_type = context.get('task_type', 'writing')

        if task_type == "writing":
            return f"""
            TASK: Assess the student's written response for an IT professional learning English.

            Task Prompt: {context['task_prompt']}
            Student Response: {context['student_response']}
            Target CEFR Level: {context['cefr_level']}
            Professional Context: {', '.join(context['professional_context'])}

            ASSESSMENT CRITERIA:
            1. Grammar accuracy (subject-verb agreement, tenses, articles)
            2. Vocabulary appropriateness for IT context
            3. Relevance to the prompt
            4. Clarity and coherence

            OUTPUT FORMAT (JSON ONLY):
            {{
                "score": 0.0-1.0,
                "is_correct": null,
                "error_tags": ["grammar", "vocabulary", "coherence", ...],
                "feedback": {{
                    "strengths": ["list of strengths"],
                    "improvement_areas": ["list of areas to improve"],
                    "specific_examples": ["quote error", "suggestion"]
                }},
                "confidence": 0.0-1.0
            }}
            """
        elif task_type == "speaking":
            return f"""
            TASK: Assess the student's spoken response for an IT professional learning English.

            Task Prompt: {context['task_prompt']}
            Transcribed Response: {context['transcript']}
            ASR Confidence: {context.get('asr_confidence', 0.0):.2f}
            Duration: {context.get('duration', 0.0):.1f} seconds
            Target CEFR Level: {context['cefr_level']}
            Professional Context: {', '.join(context['professional_context'])}

            ASSESSMENT CRITERIA:
            1. Fluency (flow, pauses, rhythm)
            2. Pronunciation clarity
            3. Grammar accuracy in speech
            4. Vocabulary appropriateness
            5. Relevance to the prompt

            OUTPUT FORMAT (JSON ONLY):
            {{
                "score": 0.0-1.0,
                "is_correct": null,
                "error_tags": ["fluency", "pronunciation", "grammar", ...],
                "feedback": {{
                    "strengths": ["list of strengths"],
                    "improvement_areas": ["list of areas to improve"],
                    "pronunciation_tips": ["specific tips"]
                }},
                "fluency_score": 0.0-1.0,
                "pronunciation_score": 0.0-1.0,
                "confidence": 0.0-1.0
            }}
            """
        else:
            # Fallback для других типов заданий
            return """
            You are an expert English tutor for IT professionals.
            Assess the student's response according to the CEFR level and professional context.
            Provide structured feedback in JSON format with the following fields:
            - score: float (0.0-1.0) overall quality score
            - is_correct: null (for open-ended tasks)
            - error_tags: array of detected error types
            - feedback: detailed feedback object
            - confidence: float (0.0-1.0) assessment confidence
            """

    def _build_user_message(self, task: Task, response: StudentTaskResponse) -> str:
        """Формирование пользовательского сообщения"""
        prompt = task.content.get("prompt", "")
        student_response = response.response_text

        if task.response_format == ResponseFormat.AUDIO:
            # Для аудио используем транскрипцию (предполагаем, что она уже сделана)
            student_response = getattr(response, 'transcript', student_response)

        return f"""
        Task Prompt: {prompt}
        Student Response: {student_response}
        CEFR Level: {task.difficulty_cefr}
        Professional Context: {', '.join([tag.name for tag in task.professional_tags.all()])}
        """

    def _generate_llm_assessment(
            self,
            task: Task,
            response: StudentTaskResponse,
            system_prompt: str,
            user_message: str
    ) -> AssessmentResult:
        """
        Генерация оценки через llm_factory
        """
        import asyncio

        # Получаем результат от LLM
        loop = asyncio.new_event_loop()
        result = loop.run_until_complete(
            self.llm_factory.generate_json_response(
                system_prompt=system_prompt,
                user_message=user_message,
                conversation_history=[],
                media_context=self._get_media_context(task)
            )
        )

        # Конвертируем в AssessmentResult
        return self._parse_llm_response(result, task)

    def _parse_llm_response(self, result, task: Task) -> AssessmentResult:
        """Конвертация ответа LLM в AssessmentResult"""
        try:
            # result содержит GenerationResult
            llm_response = result.response  # LLMResponse

            # Извлекаем данные из LLMResponse
            response_data = json.loads(llm_response.message) if isinstance(llm_response.message,
                                                                           str) else llm_response.message

            return AssessmentResult(
                score=response_data.get("score", 0.5),
                is_correct=response_data.get("is_correct"),
                error_tags=response_data.get("error_tags", []),
                feedback=response_data.get("feedback", {}),
                confidence=response_data.get("confidence", 0.8)
            )
        except (json.JSONDecodeError, AttributeError, TypeError) as e:
            return self._create_fallback_result(
                task,
                f"Failed to parse LLM response: {str(e)}"
            )

    def _create_fallback_result(self, task: Task, error: str) -> AssessmentResult:
        """Создание результата для fallback-сценария"""
        fallback_score = 0.7 if task.task_type in ["writing", "speaking"] else 0.5

        return AssessmentResult(
            score=fallback_score,
            is_correct=None,
            error_tags=["llm_processing_error"],
            feedback={
                "message": "Ваш ответ получен и будет оценен дополнительно",
                "note": f"Произошла временная ошибка при автоматической оценке: {error}"
            },
            confidence=0.4
        )

    def _get_media_context(self, task: Task):
        """Получение контекста медиафайлов для задания"""
        media_files = task.media_files.all()
        context = []
        for media in media_files:
            context.append({
                "type": media.media_type,
                "url": media.file.url if hasattr(media.file, 'url') else None
            })
        return context


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\infrastructure\repositories\assessment_repository.py
# curriculum/infrastructure/repositories/assessment_repository.py
from django.utils import timezone

from curriculum.domain.value_objects.assessment_result import AssessmentResult
from curriculum.models.assessment.assessment import Assessment


class AssessmentRepository:
    @staticmethod
    def from_domain(assessment_result: AssessmentResult, task, enrollment):
        """Создает Django-модель из доменного объекта"""
        return Assessment(
            task=task,
            enrollment=enrollment,
            score=assessment_result.score,
            is_correct=assessment_result.is_correct,
            grade=assessment_result.grade.value,
            error_tags=assessment_result.error_tags,
            feedback=assessment_result.feedback,
            confidence=assessment_result.confidence,
            assessed_at=timezone.now()
        )

    @staticmethod
    def to_domain(assessment: Assessment) -> AssessmentResult:
        """Конвертирует Django-модель в доменный объект"""
        return AssessmentResult(
            score=assessment.score,
            is_correct=assessment.is_correct,
            error_tags=assessment.error_tags or [],
            feedback=assessment.feedback or {},
            confidence=assessment.confidence or 1.0
        )

#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\infrastructure\rule_engine\rule_engine.py
# curriculum/infrastructure/rule_engine/rule_engine.py
from curriculum.domain.value_objects.assessment_result import AssessmentResult


class RuleEngine:
    """
    Движок правил для автоматической оценки.
    Обеспечивает гибкость в стратегиях оценки без изменения основной логики.
    """

    def evaluate_mcq_v2(self, task, response):
        """Оценка MCQ версии 2 (множественный выбор)"""
        try:
            # Логика оценки для MCQ v2
            student_choices = [int(i) for i in response.response_text.split(",")]
            correct_ids = task.content["correct_ids"]
            correct_count = sum(1 for c in student_choices if c in correct_ids)
            total_correct = len(correct_ids)

            score = correct_count / total_correct
            is_correct = (correct_count == total_correct)

            return AssessmentResult(
                score=score,
                is_correct=is_correct,
                error_tags=["partial_understanding"] if not is_correct and correct_count > 0 else [],
                feedback={
                    "correct_count": correct_count,
                    "total_correct": total_correct
                }
            )
        except Exception as e:
            return AssessmentResult(
                score=0.0,
                is_correct=False,
                error_tags=["invalid_format"],
                feedback={"error": f"Ошибка обработки: {str(e)}"}
            )

    def evaluate_short_text(self, task, response):
        """Оценка кратких текстовых ответов"""
        student_answer = response.response_text.strip().lower()
        correct_answers = [ans.lower() for ans in task.content.get("correct", [])]
        case_sensitive = task.content.get("case_sensitive", False)

        # Если регистр важен, используем оригинальные значения
        if case_sensitive:
            student_answer = response.response_text.strip()
            correct_answers = task.content.get("correct", [])

        # Простая проверка на совпадение
        is_correct = any(self._fuzzy_match(student_answer, correct) for correct in correct_answers)
        score = 1.0 if is_correct else 0.0

        return AssessmentResult(
            score=score,
            is_correct=is_correct,
            error_tags=[] if is_correct else ["concept_mismatch"],
            feedback={
                "hint": "Верный ответ!" if is_correct else "Попробуйте ещё раз"
            }
        )

    def _fuzzy_match(self, answer, correct_answer, threshold=0.8):
        """
        Простая fuzzy-проверка для неточных совпадений
        """
        # В реальной системе здесь будет более сложная логика
        return answer.strip() == correct_answer.strip()

    def evaluate_default(self, task, response):
        """Стратегия оценки по умолчанию"""
        return AssessmentResult(
            score=0.5,
            feedback={"message": "Ответ получен. Оценка будет произведена позже."},
            confidence=0.3
        )

#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\infrastructure\validation\task_schemas.py
# curriculum/infrastructure/validation/task_schemas.py
"""
Схемы валидации контента заданий.

ПРИНЦИПЫ:
1. Имена схем соответствуют реальному содержанию:
   - scq_v1 = Single Choice Question (одиночный выбор)
   - mcq_v1 = Multiple Choice Question (множественный выбор)
   - short_text_v1 = Short Text Response (краткий текст)
2. Каждая схема имеет четкие правила валидации
3. Поддерживается расширение без нарушения обратной совместимости
4. Схемы документированы для разработчиков

АРХИТЕКТУРНЫЕ РЕШЕНИЯ:
- Для SHORT_TEXT: поддержка множественных правильных ответов
- Для MCQ/SCQ: единообразная структура options, но разная логика выбора
- Валидация типов и диапазонов на уровне схемы
"""
from curriculum.models.content.task import ResponseFormat

TASK_CONTENT_SCHEMAS = {
    "scq_v1": {
        "name": "Single Choice Question v1",
        "supported_formats": [ResponseFormat.SINGLE_CHOICE],
        "required": {"prompt", "options", "correct_idx"},
        "optional": {"explanation", "hint", "difficulty"},
        "validation_rules": {
            "options": {
                "type": "list",
                "item_type": "str",
                "min_items": 2,
                "max_items": 10
            },
            "correct_idx": {
                "type": "int",
                "min": 0,
                "reference": "options.length - 1"
            },
            "prompt": {
                "type": "str",
                "min_length": 5
            }
        },
        "description": "Задание с выбором одного правильного варианта из списка"
    },
    "mcq_v1": {
        "name": "Multiple Choice Question v1",
        "supported_formats": [ResponseFormat.MULTIPLE_CHOICE],
        "required": {"prompt", "options", "correct_indices"},
        "optional": {"explanation", "hint", "min_selections", "max_selections", "difficulty"},
        "validation_rules": {
            "options": {
                "type": "list",
                "item_type": "str",
                "min_items": 3,
                "max_items": 15
            },
            "correct_indices": {
                "type": "list",
                "item_type": "int",
                "min_items": 1,
                "reference": "options.length"
            },
            "min_selections": {
                "type": "int",
                "min": 1,
                "reference": "correct_indices.length"
            },
            "max_selections": {
                "type": "int",
                "min": 1,
                "reference": "options.length"
            },
            "prompt": {
                "type": "str",
                "min_length": 5
            }
        },
        "description": "Задание с выбором нескольких правильных вариантов из списка"
    },
    "short_text_v1": {
        "name": "Short Text Response v1",
        "supported_formats": [ResponseFormat.SHORT_TEXT],
        "required": {"prompt"},
        "optional": {"correct_answers", "case_sensitive", "min_length", "max_length", "allowed_characters"},
        "validation_rules": {
            "prompt": {
                "type": "str",
                "min_length": 5
            },
            "correct_answers": {
                "type": "list",
                "item_type": "str",
                "min_items": 1
            },
            "case_sensitive": {
                "type": "bool",
                "default": False
            },
            "min_length": {
                "type": "int",
                "min": 1,
                "default": 1
            },
            "max_length": {
                "type": "int",
                "min": 1,
                "default": 100
            }
        },
        "description": "Задание с кратким текстовым ответом (1-3 слова)"
    }
}

#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\management\commands\create_course.py
import json
from pathlib import Path

from django.core.management.base import BaseCommand, CommandError
from django.db import transaction

from curriculum.models.content.course import Course
from curriculum.models.content.lesson import Lesson
from curriculum.models.content.task import Task
from curriculum.models.systematization.learning_objective import LearningObjective
from curriculum.models.systematization.professional_tag import ProfessionalTag


class Command(BaseCommand):
    help = "Create course, lessons, objectives and tasks from JSON definition"

    def add_arguments(self, parser):
        parser.add_argument(
            "json_path",
            type=str,
            help="Path to course JSON file"
        )

    # -------------------------------------------------
    # Entry point
    # -------------------------------------------------

    def handle(self, *args, **options):
        json_path = Path(options["json_path"])

        if not json_path.exists():
            raise CommandError(f"File not found: {json_path}")

        try:
            with open(json_path, "r", encoding="utf-8") as f:
                payload = json.load(f)
        except json.JSONDecodeError as e:
            raise CommandError(f"Invalid JSON: {e}")

        self._validate_payload(payload)

        with transaction.atomic():
            # 0️⃣ professional tags
            self._ensure_professional_tags(payload)

            # 1️⃣ course
            course = self._create_course(payload["course"])
            self.stdout.write(self.style.SUCCESS(f"Course created: {course}"))

            # 2️⃣ lessons
            for lesson_data in payload["lessons"]:
                self._create_lesson(course, lesson_data)

        self.stdout.write(self.style.SUCCESS("Import completed successfully."))

    # -------------------------------------------------
    # Validation
    # -------------------------------------------------

    def _validate_payload(self, payload: dict):
        if "course" not in payload:
            raise CommandError("Missing 'course' section")

        if "lessons" not in payload or not isinstance(payload["lessons"], list):
            raise CommandError("'lessons' must be a list")

        for lesson in payload["lessons"]:
            if "tasks" not in lesson:
                raise CommandError("Each lesson must contain 'tasks'")

    # -------------------------------------------------
    # Professional tags
    # -------------------------------------------------

    def _ensure_professional_tags(self, payload: dict):
        """
        Создает все ProfessionalTag, упомянутые в JSON,
        если они еще не существуют.
        """
        tag_names: set[str] = set()

        for lesson in payload["lessons"]:
            for task in lesson["tasks"]:
                for tag in task.get("professional_tags", []):
                    tag_names.add(tag)

        for name in sorted(tag_names):
            ProfessionalTag.objects.get_or_create(name=name)

        self.stdout.write(f"Professional tags ensured: {', '.join(sorted(tag_names))}")

    # -------------------------------------------------
    # Creation logic
    # -------------------------------------------------

    def _create_course(self, data: dict) -> Course:
        course, created = Course.objects.get_or_create(
            title=data["title"],
            defaults={
                "description": data["description"],
                "target_cefr_from": data["target_cefr_from"],
                "target_cefr_to": data["target_cefr_to"],
                "estimated_duration": data["estimated_duration"],
            }
        )

        if not created:
            self.stdout.write(
                self.style.WARNING(
                    f"Course '{course.title}' already exists, reusing it"
                )
            )

        return course

    def _create_lesson(self, course: Course, data: dict):
        lesson = Lesson.objects.create(
            course=course,
            order=data["order"],
            title=data["title"],
            description=data["description"],
            duration_minutes=data["duration_minutes"],
            required_cefr=data["required_cefr"],
            skill_focus=data["skill_focus"],
            content=data["content"],
        )

        self.stdout.write(f"  Lesson {lesson.order}: {lesson.title}")

        objectives = self._create_objectives(data.get("learning_objectives", []))
        lesson.learning_objectives.set(objectives)

        for task_data in data["tasks"]:
            self._create_task(lesson, task_data)

    def _create_objectives(self, objectives_data: list):
        identifiers = [obj["identifier"] for obj in objectives_data]

        # 1️⃣ массово создаем (если нет)
        LearningObjective.objects.bulk_create(
            [
                LearningObjective(
                    identifier=obj["identifier"],
                    name=obj["name"],
                    cefr_level=obj["cefr_level"],
                    skill_domain=obj["skill_domain"],
                )
                for obj in objectives_data
            ],
            ignore_conflicts=True
        )

        # 2️⃣ гарантированно читаем существующие
        objs = list(
            LearningObjective.objects.filter(identifier__in=identifiers)
        )

        return objs

    def _create_task(self, lesson: Lesson, data: dict):
        task = Task.objects.create(
            lesson=lesson,
            task_type=data["task_type"],
            response_format=data["response_format"],
            difficulty_cefr=data["difficulty_cefr"],
            is_diagnostic=data["is_diagnostic"],
            content_schema_version=data["content_schema_version"],
            content=data["content"],
        )

        tags = ProfessionalTag.objects.filter(
            name__in=data.get("professional_tags", [])
        )

        task.professional_tags.set(tags)


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\migrations\0001_initial.py
# Generated by Django 5.2.8 on 2025-12-22 17:44

import curriculum.validators
import django.core.validators
import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='CurrentSkillProfile',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('grammar', models.FloatField(default=0.0, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)])),
                ('vocabulary', models.FloatField(default=0.0, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)])),
                ('listening', models.FloatField(default=0.0, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)])),
                ('reading', models.FloatField(default=0.0, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)])),
                ('writing', models.FloatField(default=0.0, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)])),
                ('speaking', models.FloatField(default=0.0, validators=[django.core.validators.MinValueValidator(0.0), django.core.validators.MaxValueValidator(1.0)])),
                ('last_updated', models.DateTimeField(auto_now=True)),
            ],
        ),
        migrations.CreateModel(
            name='LearningObjective',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('cefr_level', models.CharField(choices=[('A1', 'Beginner (A1)'), ('A2', 'Elementary (A2)'), ('B1', 'Intermediate (B1)'), ('B2', 'Upper Intermediate (B2)'), ('C1', 'Advanced (C1)'), ('C2', 'Proficiency (C2)')], help_text='Уровень CEFR, на котором эта цель актуальна', max_length=2, verbose_name='CEFR Level')),
                ('skill_domain', models.CharField(choices=[('grammar', 'Grammar'), ('vocabulary', 'Vocabulary'), ('listening', 'Listening'), ('reading', 'Reading'), ('writing', 'Writing'), ('speaking', 'Speaking')], help_text='Область языкового навыка', max_length=20, verbose_name='Skill Domain')),
                ('order_in_level', models.PositiveSmallIntegerField(default=1, help_text='Порядковый номер цели в рамках уровня и области (для сортировки)', verbose_name='Order within level and domain')),
                ('name', models.CharField(help_text="Clear, actionable objective — e.g., 'Use Past Simple correctly in work emails'", max_length=200, verbose_name='Name')),
                ('description', models.TextField(blank=True, help_text='Optional detailed explanation for methodologists', verbose_name='Description')),
                ('identifier', models.SlugField(editable=False, help_text="Auto-generated unique ID like 'grammar-B1-01'", unique=True, verbose_name='Machine Identifier')),
                ('is_active', models.BooleanField(default=True, verbose_name='Is Active')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
            ],
            options={
                'verbose_name': 'Learning Objective',
                'verbose_name_plural': 'Learning Objectives',
                'ordering': ['cefr_level', 'skill_domain', 'order_in_level'],
                'indexes': [models.Index(fields=['cefr_level', 'skill_domain'], name='curriculum__cefr_le_a4e68a_idx'), models.Index(fields=['identifier'], name='curriculum__identif_0ab93b_idx')],
                'unique_together': {('cefr_level', 'skill_domain', 'order_in_level')},
            },
        ),
        migrations.CreateModel(
            name='Course',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=200, verbose_name='Title')),
                ('description', models.TextField(verbose_name='Description')),
                ('target_cefr_from', models.CharField(choices=[('A1', 'Beginner (A1)'), ('A2', 'Elementary (A2)'), ('B1', 'Intermediate (B1)'), ('B2', 'Upper Intermediate (B2)'), ('C1', 'Advanced (C1)'), ('C2', 'Proficiency (C2)')], max_length=2, verbose_name='From CEFR')),
                ('target_cefr_to', models.CharField(choices=[('A1', 'Beginner (A1)'), ('A2', 'Elementary (A2)'), ('B1', 'Intermediate (B1)'), ('B2', 'Upper Intermediate (B2)'), ('C1', 'Advanced (C1)'), ('C2', 'Proficiency (C2)')], max_length=2, verbose_name='To CEFR')),
                ('estimated_duration', models.PositiveIntegerField(help_text='Total estimated time to complete the course', verbose_name='Estimated Duration (minutes)')),
                ('required_skills', models.JSONField(default=list, help_text="e.g., ['grammar:B1', 'listening:A2']", verbose_name='Required Skills')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('is_active', models.BooleanField(default=True, verbose_name='Is Active')),
                ('learning_objectives', models.ManyToManyField(to='curriculum.learningobjective', verbose_name='Learning Objectives')),
            ],
            options={
                'verbose_name': 'Course',
                'verbose_name_plural': 'Courses',
            },
        ),
        migrations.CreateModel(
            name='Lesson',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.CharField(max_length=200, verbose_name='Title')),
                ('description', models.TextField(verbose_name='Description')),
                ('order', models.PositiveIntegerField(verbose_name='Order')),
                ('content', models.JSONField(help_text='Optional structured lesson instructions or narrative for AI', verbose_name='Content')),
                ('duration_minutes', models.PositiveIntegerField(validators=[django.core.validators.MinValueValidator(1), django.core.validators.MaxValueValidator(120)], verbose_name='Duration (minutes)')),
                ('required_cefr', models.CharField(choices=[('A1', 'Beginner (A1)'), ('A2', 'Elementary (A2)'), ('B1', 'Intermediate (B1)'), ('B2', 'Upper Intermediate (B2)'), ('C1', 'Advanced (C1)'), ('C2', 'Proficiency (C2)')], max_length=2, verbose_name='Required CEFR')),
                ('skill_focus', models.JSONField(default=list, help_text="e.g., ['listening', 'vocabulary']", validators=[curriculum.validators.validate_skill_focus], verbose_name='Skill Focus')),
                ('adaptive_parameters', models.JSONField(default=dict, help_text="e.g., {'min_correct_ratio': 0.7, 'max_items': 10}", verbose_name='Adaptive Parameters')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('is_active', models.BooleanField(default=True, verbose_name='Is Active')),
                ('course', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='lessons', to='curriculum.course', verbose_name='Course')),
                ('learning_objectives', models.ManyToManyField(to='curriculum.learningobjective', verbose_name='Learning Objectives')),
            ],
            options={
                'verbose_name': 'Lesson',
                'verbose_name_plural': 'Lessons',
                'ordering': ['course', 'order'],
            },
        ),
        migrations.CreateModel(
            name='ProfessionalTag',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(help_text="Short, machine-readable name (e.g., 'backend', 'standup-meetings')", max_length=50, unique=True, verbose_name='Tag Name')),
                ('description', models.CharField(blank=True, help_text='Human-readable explanation for admins', max_length=200, verbose_name='Description')),
                ('is_active', models.BooleanField(default=True, verbose_name='Is Active')),
            ],
            options={
                'verbose_name': 'Professional Tag',
                'verbose_name_plural': 'Professional Tags',
                'indexes': [models.Index(fields=['name'], name='curriculum__name_f1db3d_idx')],
            },
        ),
        migrations.CreateModel(
            name='Student',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('cefr_level', models.CharField(blank=True, choices=[('A1', 'Beginner (A1)'), ('A2', 'Elementary (A2)'), ('B1', 'Intermediate (B1)'), ('B2', 'Upper Intermediate (B2)'), ('C1', 'Advanced (C1)'), ('C2', 'Proficiency (C2)')], max_length=2, null=True, verbose_name='Current CEFR Level')),
                ('professional_context', models.TextField(blank=True, help_text="e.g., 'Backend developer in fintech. Need English for stand-ups and documentation.'", verbose_name='Professional Context')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('user', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL, verbose_name='User')),
            ],
            options={
                'verbose_name': 'Student',
                'verbose_name_plural': 'Students',
            },
        ),
        migrations.CreateModel(
            name='SkillTrajectory',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('skill', models.CharField(choices=[('grammar', 'Грамматика'), ('vocabulary', 'Лексика'), ('reading', 'Чтение'), ('listening', 'Аудирование'), ('writing', 'Письмо'), ('speaking', 'Говорение')], max_length=32)),
                ('trend', models.FloatField(default=0.0)),
                ('stability', models.FloatField(default=0.0)),
                ('plateau_detected', models.BooleanField(default=False)),
                ('last_updated', models.DateTimeField(auto_now=True)),
                ('student', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='skill_trajectories', to='curriculum.student')),
            ],
        ),
        migrations.CreateModel(
            name='SkillSnapshot',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('grammar', models.FloatField(default=0.0)),
                ('vocabulary', models.FloatField(default=0.0)),
                ('listening', models.FloatField(default=0.0)),
                ('reading', models.FloatField(default=0.0)),
                ('writing', models.FloatField(default=0.0)),
                ('speaking', models.FloatField(default=0.0)),
                ('snapshot_at', models.DateTimeField(auto_now_add=True)),
                ('student', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='skill_snapshots', to='curriculum.student')),
            ],
        ),
        migrations.CreateModel(
            name='Enrollment',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('started_at', models.DateTimeField(auto_now_add=True, verbose_name='Started At')),
                ('completed_at', models.DateTimeField(blank=True, null=True, verbose_name='Completed At')),
                ('is_active', models.BooleanField(default=True, verbose_name='Is Active')),
                ('last_activity', models.DateTimeField(auto_now=True, verbose_name='Last Activity')),
                ('course', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='curriculum.course', verbose_name='Course')),
                ('current_lesson', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='active_enrollments', to='curriculum.lesson', verbose_name='Current Lesson')),
                ('progress_snapshot', models.ForeignKey(blank=True, help_text='Последний зафиксированный снимок навыков', null=True, on_delete=django.db.models.deletion.SET_NULL, to='curriculum.skillsnapshot', verbose_name='Progress Snapshot')),
                ('student', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='curriculum.student', verbose_name='Student')),
            ],
            options={
                'verbose_name': 'Enrollment',
                'verbose_name_plural': 'Enrollments',
            },
        ),
        migrations.CreateModel(
            name='DiagnosticSession',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('started_at', models.DateTimeField(auto_now_add=True, verbose_name='Started At')),
                ('completed_at', models.DateTimeField(blank=True, null=True, verbose_name='Completed At')),
                ('final_cefr', models.CharField(blank=True, choices=[('A1', 'Beginner (A1)'), ('A2', 'Elementary (A2)'), ('B1', 'Intermediate (B1)'), ('B2', 'Upper Intermediate (B2)'), ('C1', 'Advanced (C1)'), ('C2', 'Proficiency (C2)')], max_length=2, null=True, verbose_name='Final CEFR')),
                ('skill_profile', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to='curriculum.currentskillprofile', verbose_name='Skill Profile')),
                ('student', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='curriculum.student', verbose_name='Student')),
            ],
            options={
                'verbose_name': 'Diagnostic Session',
                'verbose_name_plural': 'Diagnostic Sessions',
            },
        ),
        migrations.AddField(
            model_name='currentskillprofile',
            name='student',
            field=models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='skill_profile', to='curriculum.student'),
        ),
        migrations.CreateModel(
            name='CurrentSkill',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('skill', models.CharField(choices=[('grammar', 'Грамматика'), ('vocabulary', 'Лексика'), ('reading', 'Чтение'), ('listening', 'Аудирование'), ('writing', 'Письмо'), ('speaking', 'Говорение')], max_length=32)),
                ('score', models.FloatField(default=0.0)),
                ('confidence', models.FloatField(default=0.0)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('student', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='current_skills', to='curriculum.student')),
            ],
        ),
        migrations.CreateModel(
            name='StudentTaskResponse',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('response_text', models.TextField(blank=True, verbose_name='Text Response')),
                ('audio_file', models.FileField(blank=True, null=True, upload_to='responses/', verbose_name='Audio Response')),
                ('submitted_at', models.DateTimeField(auto_now_add=True, verbose_name='Submitted At')),
                ('is_correct', models.BooleanField(blank=True, help_text='True/False for closed questions, None for open-ended', null=True, verbose_name='Is Correct (Auto)')),
                ('student', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='curriculum.student', verbose_name='Student')),
            ],
            options={
                'verbose_name': 'Student Task Response',
                'verbose_name_plural': 'Student Task Responses',
            },
        ),
        migrations.CreateModel(
            name='Assessment',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('llm_version', models.CharField(blank=True, max_length=50, verbose_name='LLM Version')),
                ('raw_output', models.JSONField(verbose_name='Raw LLM Output')),
                ('structured_feedback', models.JSONField(verbose_name='Structured Feedback')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Created At')),
                ('task_response', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, to='curriculum.studenttaskresponse', verbose_name='Task Response')),
            ],
            options={
                'verbose_name': 'Assessment',
                'verbose_name_plural': 'Assessments',
            },
        ),
        migrations.CreateModel(
            name='Task',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('task_type', models.CharField(choices=[('mcq', 'Multiple Choice'), ('vocabulary', 'Vocabulary'), ('reading', 'Reading'), ('listening', 'Listening'), ('writing', 'Writing'), ('speaking', 'Speaking')], max_length=20, verbose_name='Task Type')),
                ('response_format', models.CharField(choices=[('multiple_choice', 'Multiple Choice – выбор одного или нескольких вариантов'), ('single_choice', 'Single Choice – выбор одного варианта'), ('short_text', 'Short Text – краткий текстовый ответ, 1–3 слова'), ('free_text', 'Free Text – развёрнутый ответ, абзац или текст'), ('audio', 'Audio – голосовое сообщение')], max_length=20, verbose_name='Response Format')),
                ('content', models.JSONField(verbose_name='Content')),
                ('content_schema_version', models.CharField(default='v1', verbose_name='Content Schema')),
                ('difficulty_cefr', models.CharField(choices=[('A1', 'Beginner (A1)'), ('A2', 'Elementary (A2)'), ('B1', 'Intermediate (B1)'), ('B2', 'Upper Intermediate (B2)'), ('C1', 'Advanced (C1)'), ('C2', 'Proficiency (C2)')], max_length=2, verbose_name='Difficulty CEFR')),
                ('is_diagnostic', models.BooleanField(default=False, verbose_name='Used in Diagnostic')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('lesson', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='tasks', to='curriculum.lesson', verbose_name='Lesson')),
                ('professional_tags', models.ManyToManyField(blank=True, to='curriculum.professionaltag', verbose_name='Professional Tags')),
            ],
            options={
                'verbose_name': 'Task',
                'verbose_name_plural': 'Tasks',
            },
        ),
        migrations.AddField(
            model_name='studenttaskresponse',
            name='task',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='curriculum.task', verbose_name='Task'),
        ),
        migrations.CreateModel(
            name='LessonTransition',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('decision_code', models.CharField(help_text='Код решения decision engine (advance, repeat, remedial, etc.)', max_length=128)),
                ('teacher_override', models.BooleanField(default=False, help_text='Было ли решение переопределено преподавателем')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('assessment', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='lesson_transitions', to='curriculum.assessment')),
                ('enrollment', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='lesson_transitions', to='curriculum.enrollment')),
                ('from_lesson', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='outgoing_transitions', to='curriculum.lesson')),
                ('to_lesson', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.PROTECT, related_name='incoming_transitions', to='curriculum.lesson')),
                ('skill_snapshot', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='lesson_transitions', to='curriculum.skillsnapshot')),
                ('task', models.ForeignKey(blank=True, help_text='Task, на основании которого было принято решение (если применимо)', null=True, on_delete=django.db.models.deletion.PROTECT, related_name='lesson_transitions', to='curriculum.task')),
            ],
            options={
                'ordering': ['created_at'],
            },
        ),
        migrations.CreateModel(
            name='ErrorLog',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('error_type', models.CharField(max_length=30, verbose_name='Error Type')),
                ('example', models.TextField(verbose_name='Example')),
                ('correction', models.TextField(blank=True, verbose_name='Correction')),
                ('detected_at', models.DateTimeField(auto_now_add=True, verbose_name='Detected At')),
                ('resolved', models.BooleanField(default=False, verbose_name='Resolved')),
                ('student', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='curriculum.student', verbose_name='Student')),
                ('context_task', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to='curriculum.task', verbose_name='Context Task')),
            ],
            options={
                'verbose_name': 'Error Log',
                'verbose_name_plural': 'Error Logs',
            },
        ),
        migrations.AddField(
            model_name='enrollment',
            name='current_task',
            field=models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='active_enrollments', to='curriculum.task', verbose_name='Current Task'),
        ),
        migrations.CreateModel(
            name='TaskMedia',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('file', models.FileField(upload_to='task_media/', verbose_name='File')),
                ('media_type', models.CharField(choices=[('text', 'Raw text snippet or prompt'), ('audio', 'Audio file (e.g., MP3, WAV)'), ('video', 'Video file (e.g AVI, MP4)'), ('image', 'Image (e.g., diagram, screenshot)'), ('document', 'PDF, DOC, or other document')], max_length=20, verbose_name='Media Type')),
                ('order', models.PositiveSmallIntegerField(default=0, verbose_name='Order')),
                ('task', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='media_files', to='curriculum.task', verbose_name='Task')),
            ],
            options={
                'verbose_name': 'Task Media',
                'verbose_name_plural': 'Task Media',
            },
        ),
        migrations.CreateModel(
            name='Teacher',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('user', models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL, verbose_name='User')),
            ],
            options={
                'verbose_name': 'Учитель',
                'verbose_name_plural': 'Учителя',
            },
        ),
        migrations.CreateModel(
            name='TeacherOverride',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('original_decision', models.CharField(max_length=32)),
                ('overridden_decision', models.CharField(max_length=32)),
                ('reason', models.TextField(help_text='Объяснение преподавателя')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('lesson', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='curriculum.lesson')),
                ('student', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='teacher_overrides', to='curriculum.student')),
                ('teacher', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='overrides', to='curriculum.teacher')),
            ],
            options={
                'verbose_name': 'Teacher Override',
                'verbose_name_plural': 'Teacher Overrides',
            },
        ),
        migrations.AddIndex(
            model_name='lesson',
            index=models.Index(fields=['course', 'order'], name='curriculum__course__d8682d_idx'),
        ),
        migrations.AlterUniqueTogether(
            name='lesson',
            unique_together={('course', 'order')},
        ),
        migrations.AddIndex(
            model_name='student',
            index=models.Index(fields=['cefr_level'], name='curriculum__cefr_le_021c08_idx'),
        ),
        migrations.AlterUniqueTogether(
            name='skilltrajectory',
            unique_together={('student', 'skill')},
        ),
        migrations.AddIndex(
            model_name='diagnosticsession',
            index=models.Index(fields=['student'], name='curriculum__student_472051_idx'),
        ),
        migrations.AddIndex(
            model_name='diagnosticsession',
            index=models.Index(fields=['completed_at'], name='curriculum__complet_0bba40_idx'),
        ),
        migrations.AlterUniqueTogether(
            name='currentskill',
            unique_together={('student', 'skill')},
        ),
        migrations.AddIndex(
            model_name='assessment',
            index=models.Index(fields=['task_response'], name='curriculum__task_re_5a63bc_idx'),
        ),
        migrations.AddIndex(
            model_name='task',
            index=models.Index(fields=['task_type'], name='curriculum__task_ty_abb4ed_idx'),
        ),
        migrations.AddIndex(
            model_name='task',
            index=models.Index(fields=['response_format'], name='curriculum__respons_b586c8_idx'),
        ),
        migrations.AddIndex(
            model_name='task',
            index=models.Index(fields=['difficulty_cefr'], name='curriculum__difficu_21adcf_idx'),
        ),
        migrations.AddIndex(
            model_name='task',
            index=models.Index(fields=['is_diagnostic'], name='curriculum__is_diag_82f412_idx'),
        ),
        migrations.AddIndex(
            model_name='studenttaskresponse',
            index=models.Index(fields=['student'], name='curriculum__student_9f2af5_idx'),
        ),
        migrations.AddIndex(
            model_name='studenttaskresponse',
            index=models.Index(fields=['task'], name='curriculum__task_id_7a3265_idx'),
        ),
        migrations.AddIndex(
            model_name='studenttaskresponse',
            index=models.Index(fields=['submitted_at'], name='curriculum__submitt_2b5462_idx'),
        ),
        migrations.AddIndex(
            model_name='errorlog',
            index=models.Index(fields=['student'], name='curriculum__student_53532c_idx'),
        ),
        migrations.AddIndex(
            model_name='errorlog',
            index=models.Index(fields=['error_type'], name='curriculum__error_t_b02c70_idx'),
        ),
        migrations.AddIndex(
            model_name='errorlog',
            index=models.Index(fields=['resolved'], name='curriculum__resolve_3aae0b_idx'),
        ),
        migrations.AddIndex(
            model_name='enrollment',
            index=models.Index(fields=['student', 'course'], name='curriculum__student_e62215_idx'),
        ),
        migrations.AddIndex(
            model_name='enrollment',
            index=models.Index(fields=['is_active'], name='curriculum__is_acti_e42fe0_idx'),
        ),
        migrations.AddIndex(
            model_name='enrollment',
            index=models.Index(fields=['last_activity'], name='curriculum__last_ac_7ab071_idx'),
        ),
        migrations.AddConstraint(
            model_name='enrollment',
            constraint=models.UniqueConstraint(condition=models.Q(('is_active', True)), fields=('student', 'course', 'is_active'), name='unique_active_enrollment'),
        ),
        migrations.AddIndex(
            model_name='taskmedia',
            index=models.Index(fields=['task'], name='curriculum__task_id_36bd62_idx'),
        ),
        migrations.AddIndex(
            model_name='taskmedia',
            index=models.Index(fields=['media_type'], name='curriculum__media_t_ff8980_idx'),
        ),
        migrations.AddIndex(
            model_name='teacheroverride',
            index=models.Index(fields=['student'], name='curriculum__student_1184a6_idx'),
        ),
        migrations.AddIndex(
            model_name='teacheroverride',
            index=models.Index(fields=['lesson'], name='curriculum__lesson__594383_idx'),
        ),
    ]


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\migrations\0002_alter_errorlog_student_alter_skilltrajectory_student_and_more.py
# Generated by Django 5.2.8 on 2025-12-23 12:48

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('curriculum', '0001_initial'),
        ('users', '0009_student_teacher_delete_studyprofile_and_more'),
    ]

    operations = [
        migrations.AlterField(
            model_name='errorlog',
            name='student',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='users.student', verbose_name='Student'),
        ),
        migrations.AlterField(
            model_name='skilltrajectory',
            name='student',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='skill_trajectories', to='users.student'),
        ),
        migrations.AlterField(
            model_name='enrollment',
            name='student',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='users.student', verbose_name='Student'),
        ),
        migrations.AlterField(
            model_name='currentskill',
            name='student',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='current_skills', to='users.student'),
        ),
        migrations.AlterField(
            model_name='teacheroverride',
            name='student',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='teacher_overrides', to='users.student'),
        ),
        migrations.AlterField(
            model_name='currentskillprofile',
            name='student',
            field=models.OneToOneField(on_delete=django.db.models.deletion.CASCADE, related_name='skill_profile', to='users.student'),
        ),
        migrations.AlterField(
            model_name='skillsnapshot',
            name='student',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='skill_snapshots', to='users.student'),
        ),
        migrations.AlterField(
            model_name='studenttaskresponse',
            name='student',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='users.student', verbose_name='Student'),
        ),
        migrations.AlterField(
            model_name='diagnosticsession',
            name='student',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='users.student', verbose_name='Student'),
        ),
        migrations.RemoveField(
            model_name='teacher',
            name='user',
        ),
        migrations.AlterField(
            model_name='teacheroverride',
            name='teacher',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='overrides', to='users.teacher'),
        ),
        migrations.DeleteModel(
            name='Student',
        ),
        migrations.DeleteModel(
            name='Teacher',
        ),
    ]


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\migrations\0003_task_is_active.py
# Generated by Django 5.2.8 on 2025-12-23 16:25

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('curriculum', '0002_alter_errorlog_student_alter_skilltrajectory_student_and_more'),
    ]

    operations = [
        migrations.AddField(
            model_name='task',
            name='is_active',
            field=models.BooleanField(default=True, verbose_name='Задание актуально'),
        ),
    ]


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\migrations\0004_alter_task_options_and_more.py
# Generated by Django 5.2.8 on 2025-12-23 17:38

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('curriculum', '0003_task_is_active'),
    ]

    operations = [
        migrations.AlterModelOptions(
            name='task',
            options={'ordering': ['lesson', 'order'], 'verbose_name': 'Task', 'verbose_name_plural': 'Tasks'},
        ),
        migrations.RemoveIndex(
            model_name='task',
            name='curriculum__difficu_21adcf_idx',
        ),
        migrations.RemoveIndex(
            model_name='task',
            name='curriculum__is_diag_82f412_idx',
        ),
        migrations.AddField(
            model_name='task',
            name='order',
            field=models.PositiveIntegerField(default=0, help_text='Порядок задания в уроке (чем меньше число, тем раньше задание)', verbose_name='Порядок задачи в уроке'),
        ),
        migrations.AddIndex(
            model_name='task',
            index=models.Index(fields=['lesson', 'order'], name='curriculum__lesson__3a6e05_idx'),
        ),
    ]


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\models\MODELS.md
# curriculum.models — Domain models

Этот документ описывает **доменные модели** модуля `curriculum`

---

## 1. Общие принципы

### 1.1 Domain-driven, но pragmatic

Модели отражают **обучающий домен**, а не идеализированную DDD-схему.
Некоторые концепты (например, Skill) реализованы **не как отдельные сущности**, а как enum + числовые значения.

### 1.2 Audit-first

Ключевые модели (Assessment, LessonTransition, SkillSnapshot) проектируются так, чтобы:
- фиксировать факт
- не изменяться задним числом
- позволять объяснение и воспроизведение flow

---

## 2. Core learning models

### Course

**Назначение:** контейнер учебной программы.

**Ключевые поля (conceptually):**
- title
- description
- ordering

**Используется:**
- CurriculumQuery

---

### Lesson

**Назначение:** основная единица прогрессии.

**Связи:**
- Course → Lesson (1:N)
- Lesson → Task (1:N)
- Lesson → LearningObjective (M:N)

**Важно:**
- Lesson не знает, будет ли он пройден успешно
- переходы фиксируются в LessonTransition

---

### Task

**Назначение:** конкретное задание внутри урока.

**Связи:**
- Task → Lesson (N:1)
- Task → ProfessionalTag (M:N)

**Важно:**
- Task — основной источник skill-сигналов

---

### Enrollment

**Назначение:** связь студента с курсом.

**Инварианты:**
- один Enrollment = один учебный контекст
- все progress-сущности привязаны к Enrollment

---

### StudentTaskResponse

**Назначение:** ответ студента на Task.

**Используется:**
- AssessmentService

---

### Assessment

**Назначение:** результат оценки StudentResponse.

**Характеристики:**
- неизменяем после создания
- хранит структурированный feedback

**Используется:**
- DecisionService
- LessonExplainer

---

## 3. Skills (особый раздел)

### SkillSnapshot

**Назначение:** снимок навыков студента в момент принятия решения.

**Свойства:**
- создаётся часто
- не изменяется

**Используется:**
- LessonTransition
- Explainability

---

### SkillTrajectory

**Назначение:** агрегированная история изменения одного навыка.

**Свойства:**
- обновляется инкрементально
- хранит тренды и стабильность

**Используется:**
- DecisionService
- ExplainabilityEngine

---

## 4. Progress & audit

### LessonTransition

**Назначение:** неизменяемый факт перехода в обучении.

**Это ключевая модель для:**
- объяснимости
- дебага
- воспроизведения обучения

**Создаётся:**
- TransitionRecorder

---


## 5. TODO / точки развития

- Формализовать mapping Task → Skill
- Добавить uncertainty / confidence в SkillSnapshot
- Versioning LessonTransition
- Replay учебного процесса

---





#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\models\assessment\assessment.py
from django.db import models
from django.utils.translation import gettext_lazy as _

from curriculum.models.assessment.student_response import StudentTaskResponse


class Assessment(models.Model):
    """
    Результат оценки LLM для открытого задания.

    Назначение:
    - Хранит структурированную обратную связь по writing/speaking.
    - Используется для обновления SkillProfile и ErrorLog.

    Поля:
    - raw_output: полный ответ LLM (для аудита)
    - structured_feedback: нормализованный JSON (см. пример ниже)

    Пример structured_feedback:
    {
      "score_grammar": 0.7,
      "score_vocabulary": 0.85,
      "errors": [{"type": "tense", "example": "I have went", "correction": "I went"}],
      "strengths": ["clear structure", "good IT vocabulary"],
      "suggestions": ["review past tenses"]
    }
    """
    objects = models.Manager()

    task_response = models.OneToOneField(StudentTaskResponse, on_delete=models.CASCADE, verbose_name=_("Task Response"))
    llm_version = models.CharField(max_length=50, blank=True, verbose_name=_("LLM Version"))
    raw_output = models.JSONField(verbose_name=_("Raw LLM Output"))
    structured_feedback = models.JSONField(verbose_name=_("Structured Feedback"))
    created_at = models.DateTimeField(auto_now_add=True, verbose_name=_("Created At"))

    class Meta:
        verbose_name = _("Assessment")
        verbose_name_plural = _("Assessments")
        indexes = [models.Index(fields=['task_response'])]

    def __str__(self):
        return f"Assessment for {self.task_response}"


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\models\assessment\diagnostic_session.py
from django.db import models
from django.utils.translation import gettext_lazy as _

from users.models import CEFRLevel, Student


class DiagnosticSession(models.Model):
    """
    Сессия адаптивной диагностики — охватывает все 8 блоков.

    Назначение:
    - Связывает студента, его ответы, итоговый уровень и профиль.
    - Используется для аналитики и повторной диагностики.
    """
    student = models.ForeignKey(Student, on_delete=models.CASCADE, verbose_name=_("Student"))
    started_at = models.DateTimeField(auto_now_add=True, verbose_name=_("Started At"))
    completed_at = models.DateTimeField(null=True, blank=True, verbose_name=_("Completed At"))
    final_cefr = models.CharField(max_length=2, choices=CEFRLevel, null=True, blank=True,
                                  verbose_name=_("Final CEFR"))
    skill_profile = models.ForeignKey("CurrentSkillProfile", on_delete=models.SET_NULL, null=True, blank=True,
                                      verbose_name=_("Skill Profile"))

    class Meta:
        verbose_name = _("Diagnostic Session")
        verbose_name_plural = _("Diagnostic Sessions")
        indexes = [
            models.Index(fields=['student']),
            models.Index(fields=['completed_at']),
        ]

    def __str__(self):
        return f"Diagnostic for {self.student} ({self.final_cefr or 'in skills'})"

#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\models\assessment\student_response.py
from django.db import models
from django.utils.translation import gettext_lazy as _

from curriculum.models.content.task import Task
from users.models import Student


class StudentTaskResponse(models.Model):
    """
    Ответ студента на задание.

    Назначение:
    - Хранит как текст, так и аудио.
    - Используется для автоматической и LLM-оценки.

    Поля:
    - response_text: для writing, short_text
    - audio_file: для speaking
    - is_correct: True/False для закрытых, None для открытых
    """
    student = models.ForeignKey(Student, on_delete=models.CASCADE, verbose_name=_("Student"))
    task = models.ForeignKey(Task, on_delete=models.CASCADE, verbose_name=_("Task"))
    response_text = models.TextField(blank=True, verbose_name=_("Text Response"))
    audio_file = models.FileField(upload_to='responses/', blank=True, null=True, verbose_name=_("Audio Response"))
    submitted_at = models.DateTimeField(auto_now_add=True, verbose_name=_("Submitted At"))
    is_correct = models.BooleanField(
        null=True,
        blank=True,
        verbose_name=_("Is Correct (Auto)"),
        help_text=_("True/False for closed questions, None for open-ended")
    )

    class Meta:
        verbose_name = _("Student Task Response")
        verbose_name_plural = _("Student Task Responses")
        indexes = [
            models.Index(fields=['student']),
            models.Index(fields=['task']),
            models.Index(fields=['submitted_at']),
        ]

    def __str__(self):
        return f"Response by {self.student} to {self.task}"

#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\models\content\course.py
from django.db import models
from django.utils.translation import gettext_lazy as _

from curriculum.models.systematization.learning_objective import LearningObjective
from users.models import CEFRLevel


class Course(models.Model):
    """
    Учебный курс — структурированная последовательность уроков.
    Может быть диагностическим (is_diagnostic=True) или обучающим.

    Назначение:
    - Диагностический курс: содержит 8 блоков из плана.
    - Обучающий курс: тематический путь (например, "English for Backend Engineers").

    Поля:
    - title: название курса
    - target_cefr_from/to: диапазон CEFR
    - estimated_duration: общая длительность в минутах
    - learning_objectives: цели, которые покрывает курс
    - required_skills: список навыков/уровней, необходимых для старта (JSON)
    """
    objects = models.Manager()

    title = models.CharField(max_length=200, verbose_name=_("Title"))
    description = models.TextField(verbose_name=_("Description"))
    target_cefr_from = models.CharField(max_length=2, choices=CEFRLevel, verbose_name=_("From CEFR"))
    target_cefr_to = models.CharField(max_length=2, choices=CEFRLevel, verbose_name=_("To CEFR"))
    estimated_duration = models.PositiveIntegerField(
        verbose_name=_("Estimated Duration (minutes)"),
        help_text=_("Total estimated time to complete the course")
    )
    learning_objectives = models.ManyToManyField(LearningObjective, verbose_name=_("Learning Objectives"))
    required_skills = models.JSONField(
        default=list,
        verbose_name=_("Required Skills"),
        help_text=_("e.g., ['grammar:B1', 'listening:A2']")
    )

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    is_active = models.BooleanField(default=True, verbose_name=_("Is Active"))

    class Meta:
        verbose_name = _("Course")
        verbose_name_plural = _("Courses")

    def __str__(self):
        return f"{self.title} ({self.get_target_cefr_from_display()} → {self.get_target_cefr_to_display()})"


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\models\content\lesson.py
from django.core.validators import MaxValueValidator, MinValueValidator
from django.db import models
from django.utils.translation import gettext_lazy as _

from curriculum.models.content.course import Course
from curriculum.models.systematization.learning_objective import LearningObjective

from curriculum.validators import validate_skill_focus
from users.models import CEFRLevel


class Lesson(models.Model):
    """
    Урок — логическая единица внутри курса (например, "Listening: Stand-up Meetings").

    Назначение:
    - Соответствует одному из 8 блоков диагностики или теме в обучении.
    - Содержит задания (Tasks).

    Поля:
    - duration_minutes: сколько времени займёт
    - skill_focus: навыки, на которые направлен (["listening", "vocabulary"])
    - adaptive_parameters: правила адаптации (например, пороги для усложнения)
    """
    objects = models.Manager()

    course = models.ForeignKey(Course, on_delete=models.CASCADE, related_name='lessons', verbose_name=_("Course"))
    title = models.CharField(max_length=200, verbose_name=_("Title"))
    description = models.TextField(verbose_name=_("Description"))
    order = models.PositiveIntegerField(verbose_name=_("Order"))
    content = models.JSONField(
        verbose_name=_("Content"),
        help_text=_("Optional structured lesson instructions or narrative for AI")
    )
    duration_minutes = models.PositiveIntegerField(
        validators=[MinValueValidator(1), MaxValueValidator(120)],
        verbose_name=_("Duration (minutes)")
    )
    required_cefr = models.CharField(max_length=2, choices=CEFRLevel, verbose_name=_("Required CEFR"))
    learning_objectives = models.ManyToManyField(LearningObjective, verbose_name=_("Learning Objectives"))
    skill_focus = models.JSONField(
        default=list,
        validators=[validate_skill_focus],
        verbose_name=_("Skill Focus"),
        help_text=_("e.g., ['listening', 'vocabulary']")
    )
    adaptive_parameters = models.JSONField(
        default=dict,
        verbose_name=_("Adaptive Parameters"),
        help_text=_("e.g., {'min_correct_ratio': 0.7, 'max_items': 10}")
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    is_active = models.BooleanField(default=True, verbose_name=_("Is Active"))

    class Meta:
        verbose_name = _("Lesson")
        verbose_name_plural = _("Lessons")
        ordering = ['course', 'order']
        indexes = [models.Index(fields=['course', 'order'])]
        unique_together = [['course', 'order']]

    def __str__(self):
        return f"{self.course.title} → {self.title}"

#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\models\content\task.py
from django.db import models
from django.utils.translation import gettext_lazy as _

from curriculum.models.systematization.professional_tag import ProfessionalTag
from users.models import CEFRLevel
from curriculum.models.content.lesson import Lesson
from curriculum.validators import validate_task_content_schema


class TaskType(models.TextChoices):
    """Типы вопросов."""
    GRAMMAR = "mcq", "Multiple Choice"
    VOCABULARY = ('vocabulary', _('Vocabulary'))
    READING = ('reading', _('Reading'))
    LISTENING = ('listening', _('Listening'))
    WRITING = ('writing', _('Writing'))
    SPEAKING = ('speaking', _('Speaking'))


class ResponseFormat(models.TextChoices):
    """Типы ответов"""

    MULTIPLE_CHOICE = ('multiple_choice', _('Multiple Choice – выбор одного или нескольких вариантов'))
    SINGLE_CHOICE = ('single_choice', _('Single Choice – выбор одного варианта'))
    SHORT_TEXT = ('short_text', _('Short Text – краткий текстовый ответ, 1–3 слова'))
    FREE_TEXT = ('free_text', _('Free Text – развёрнутый ответ, абзац или текст'))
    AUDIO = ('audio', _('Audio – голосовое сообщение'))


class Task(models.Model):
    """
    Задание — самая мелкая единица взаимодействия.
    Полностью покрывает все 8 блоков диагностики.

    Назначение:
    - Закрытые вопросы: MCQ по грамматике, reading comprehension.
    - Открытые: writing warm-up, speaking probe.

    Ключевые поля:
    - task_type: тип навыка (грамматика, listening и т.д.)
    - response_format: как отвечает студент (выбор, текст, аудио)
    - content: структурированное содержимое (см. примеры ниже)
    - professional_tags: релевантность роли студента
    - is_diagnostic: используется ли в диагностике

    Примеры content:

    1. Multiple Choice (Grammar):
    {
      "prompt": "Which sentence is correct?",
      "options": ["I have went...", "I went...", "I have go..."],
      "correct_idx": 1,
      "explanation": "Past Simple for completed past actions."
    }

    2. Short Text (Listening):
    {
      "prompt": "What was the main issue mentioned in the audio?",
      "correct": ["deployment failed", "build error"],
      "case_sensitive": false
    }

    3. Free Text (Writing Warm-up):
    {
      "prompt": "What did you do at work yesterday?",
      "max_length_words": 50,
      "expected_skills": ["past_simple", "work_vocabulary"]
    }

    4. Audio (Speaking):
    {
      "prompt": "Record 20–30 seconds about your current task.",
      "max_duration_sec": 30
    }
    """
    objects = models.Manager()

    lesson = models.ForeignKey(Lesson, on_delete=models.CASCADE, null=True, blank=True, verbose_name=_("Lesson"),
                               related_name="tasks")
    task_type = models.CharField(max_length=20, choices=TaskType, verbose_name=_("Task Type"))
    response_format = models.CharField(max_length=20, choices=ResponseFormat, verbose_name=_("Response Format"))
    content = models.JSONField(verbose_name=_("Content"))
    # схема задается в engageai_core/curriculum/schemas.py:TASK_CONTENT_SCHEMAS
    content_schema_version = models.CharField(default="v1", verbose_name=_("Content Schema"))
    difficulty_cefr = models.CharField(max_length=2, choices=CEFRLevel, verbose_name=_("Difficulty CEFR"))
    is_diagnostic = models.BooleanField(default=False, verbose_name=_("Used in Diagnostic"))
    professional_tags = models.ManyToManyField(ProfessionalTag, blank=True, verbose_name=_("Professional Tags"))
    is_active = models.BooleanField(default=True, verbose_name=_("Задание актуально"))
    order = models.PositiveIntegerField(
        default=0,
        verbose_name=_("Порядок задачи в уроке"),
        help_text=_("Порядок задания в уроке (чем меньше число, тем раньше задание)")
    )

    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        verbose_name = _("Task")
        verbose_name_plural = _("Tasks")
        ordering = ['lesson', 'order']
        indexes = [
            models.Index(fields=['lesson', 'order']),
            models.Index(fields=['task_type']),
            models.Index(fields=['response_format']),
        ]

    def __str__(self):
        return f"{self.get_task_type_display()} ({self.get_response_format_display()}) — {self.difficulty_cefr}"

    def clean(self):
        validate_task_content_schema(
            self.content,
            self.content_schema_version
        )

    def save(self, *args, **kwargs):
        """Автоматическая установка порядка при создании"""
        if not self.pk and self.order == 0:
            # Получаем максимальный order в этом уроке и добавляем 1
            max_order = Task.objects.filter(lesson=self.lesson).aggregate(
                max_order=models.Max('order')
            )['max_order'] or 0
            self.order = max_order + 1
        super().save(*args, **kwargs)


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\models\content\task_media.py
from django.db import models
from django.utils.translation import gettext_lazy as _

from curriculum.models.content.task import Task


class MediaType(models.TextChoices):
    """Тип медиа файла"""

    TEXT = ('text', _('Raw text snippet or prompt'))
    AUDIO = ('audio', _('Audio file (e.g., MP3, WAV)'))
    VIDEO = ('video', _('Video file (e.g AVI, MP4)'))
    IMAGE = ('image', _('Image (e.g., diagram, screenshot)'))
    DOC = ('document', _('PDF, DOC, or other document'))


class TaskMedia(models.Model):
    """
    Медиафайл, прикреплённый к заданию.

    Назначение:
    - Аудио для listening (блок 6),
    - Изображение для reading (например, скрин тикета),
    - Текстовый фрагмент.

    Поля:
    - file: путь к файлу
    - media_type: тип контента
    - order: порядок, если файлов несколько
    """
    task = models.ForeignKey(Task, on_delete=models.CASCADE, related_name='media_files', verbose_name=_("Task"))
    file = models.FileField(upload_to='task_media/', verbose_name=_("File"))
    media_type = models.CharField(max_length=20, choices=MediaType, verbose_name=_("Media Type"))
    order = models.PositiveSmallIntegerField(default=0, verbose_name=_("Order"))

    class Meta:
        verbose_name = _("Task Media")
        verbose_name_plural = _("Task Media")
        indexes = [
            models.Index(fields=['task']),
            models.Index(fields=['media_type']),
        ]

    def __str__(self):
        return f"{self.get_media_type_display()} for {self.task}"


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\models\governance\teacher_override.py
from django.db import models
from django.utils.translation import gettext_lazy as _

from curriculum.models.content.lesson import Lesson
from users.models import Teacher, Student


class TeacherOverride(models.Model):
    """
    Ручное вмешательство преподавателя в решение системы.

    Назначение:
    - Фиксирует факт переопределения
    - Хранит причину
    - Используется для аналитики и обучения системы
    """

    objects = models.Manager()

    teacher = models.ForeignKey(
        Teacher,
        on_delete=models.CASCADE,
        related_name="overrides"
    )

    student = models.ForeignKey(
        Student,
        on_delete=models.CASCADE,
        related_name="teacher_overrides"
    )

    lesson = models.ForeignKey(
        Lesson,
        on_delete=models.CASCADE
    )

    original_decision = models.CharField(
        max_length=32
    )

    overridden_decision = models.CharField(
        max_length=32
    )

    reason = models.TextField(
        help_text="Объяснение преподавателя"
    )

    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        verbose_name = "Teacher Override"
        verbose_name_plural = "Teacher Overrides"
        indexes = [
            models.Index(fields=["student"]),
            models.Index(fields=["lesson"]),
        ]

    def __str__(self):
        return (
            f"{self.teacher} override "
            f"{self.original_decision} → {self.overridden_decision}"
        )


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\models\progress\lesson_transition.py
from django.db import models

from curriculum.models.assessment.assessment import Assessment
from curriculum.models.content.lesson import Lesson
from curriculum.models.content.task import Task
from curriculum.models.skills.skill_snapshot import SkillSnapshot
from curriculum.models.student.enrollment import Enrollment


class LessonTransition(models.Model):
    """
    LessonTransition — неизменяемый факт перехода в учебном процессе.

    Создаётся TransitionRecorder.
    Используется:
    - explainability
    - аналитикой
    - отладкой решений
    """
    objects = models.Manager()

    enrollment = models.ForeignKey(
        Enrollment,
        on_delete=models.CASCADE,
        related_name="lesson_transitions",
    )

    from_lesson = models.ForeignKey(
        Lesson,
        on_delete=models.PROTECT,
        related_name="outgoing_transitions",
    )

    to_lesson = models.ForeignKey(
        Lesson,
        on_delete=models.PROTECT,
        null=True,
        blank=True,
        related_name="incoming_transitions",
    )

    task = models.ForeignKey(
        Task,
        on_delete=models.PROTECT,
        null=True,
        blank=True,
        related_name="lesson_transitions",
        help_text="Task, на основании которого было принято решение (если применимо)",
    )

    assessment = models.ForeignKey(
        Assessment,
        on_delete=models.PROTECT,
        related_name="lesson_transitions",
    )

    skill_snapshot = models.ForeignKey(
        SkillSnapshot,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="lesson_transitions",
    )

    decision_code = models.CharField(
        max_length=128,
        help_text="Код решения decision engine (advance, repeat, remedial, etc.)",
    )

    teacher_override = models.BooleanField(
        default=False,
        help_text="Было ли решение переопределено преподавателем",
    )

    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ["created_at"]

    def __str__(self) -> str:
        return (
            f"LessonTransition("
            f"enrollment={self.enrollment_id}, "
            f"{self.from_lesson_id} → {self.to_lesson_id}, "
            f"decision={self.decision_code}"
            f")"
        )

    # --- DOMAIN CONTRACT ---
    # ПИШЕТ:
    #   - TransitionRecorder
    #
    # ЧИТАЕТ:
    #   - LessonExplainer
    #   - ExplainabilityEngine
    #   - Analytics / Admin
    #
    # ИНВАРИАНТЫ:
    #   - объект НЕ редактируется после создания
    #   - assessment всегда есть
    #   - decision_code обязателен


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\models\skills\error_log.py
from django.db import models
from django.utils.translation import gettext_lazy as _

from curriculum.models.content.task import Task
from users.models import Student


class ErrorLog(models.Model):
    """
    Журнал типичных ошибок — для цели №3: «Выявить типичные ошибки».

    Назначение:
    - Формирует Error Profile студента.
    - Используется для рекомендаций и подбора практики.

    Примеры:
    - error_type: "tense"
    - example: "I have went to the meeting"
    - correction: "I went to the meeting"
    """
    student = models.ForeignKey(Student, on_delete=models.CASCADE, verbose_name=_("Student"))
    error_type = models.CharField(max_length=30, verbose_name=_("Error Type"))
    example = models.TextField(verbose_name=_("Example"))
    correction = models.TextField(blank=True, verbose_name=_("Correction"))
    context_task = models.ForeignKey(Task, on_delete=models.SET_NULL, null=True, blank=True,
                                     verbose_name=_("Context Task"))
    detected_at = models.DateTimeField(auto_now_add=True, verbose_name=_("Detected At"))
    resolved = models.BooleanField(default=False, verbose_name=_("Resolved"))

    class Meta:
        verbose_name = _("Error Log")
        verbose_name_plural = _("Error Logs")
        indexes = [
            models.Index(fields=['student']),
            models.Index(fields=['error_type']),
            models.Index(fields=['resolved']),
        ]

    def __str__(self):
        return f"{self.error_type} — {self.student}"

#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\models\skills\skill_curent.py
from django.db import models

from curriculum.validators import SkillDomain
from users.models import Student


class CurrentSkill(models.Model):
    """
    Текущее состояние конкретного навыка студента.

    Используется для:
    - адаптивных решений
    - выбора сложности
    - маршрутизации по курсу
    """
    objects = models.Manager()

    student = models.ForeignKey(
        Student,
        on_delete=models.CASCADE,
        related_name="current_skills"
    )

    skill = models.CharField(
        max_length=32,
        choices=SkillDomain.choices
    )

    score = models.FloatField(default=0.0)
    confidence = models.FloatField(default=0.0)

    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ("student", "skill")


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\models\skills\skill_profile.py
from django.core.validators import MinValueValidator, MaxValueValidator
from django.db import models
from django.utils.translation import gettext_lazy as _

from users.models import Student


#
# class SkillProfile(models.Model):
#     """
#     Профиль навыков — результат диагностики или промежуточной оценки.
#
#     Назначение:
#     - Соответствует цели №2 из плана: «Сформировать первичный профиль навыков».
#     - Используется для Goal Setting и подбора курсов.
#
#     Поля:
#     - grammar, vocabulary, listening, reading, writing, speaking: float от 0.0 до 1.0
#     - snapshot_at: момент оценки (можно хранить историю прогресса)
#     """
#     student = models.ForeignKey(Student, on_delete=models.CASCADE, verbose_name=_("Student"))
#     grammar = models.FloatField(default=0.0, verbose_name=_("Grammar Score"))
#     vocabulary = models.FloatField(default=0.0, verbose_name=_("Vocabulary Score"))
#     listening = models.FloatField(default=0.0, verbose_name=_("Listening Score"))
#     reading = models.FloatField(default=0.0, verbose_name=_("Reading Score"))
#     writing = models.FloatField(default=0.0, verbose_name=_("Writing Score"))
#     speaking = models.FloatField(default=0.0, verbose_name=_("Speaking Score"))
#     snapshot_at = models.DateTimeField(auto_now_add=True, verbose_name=_("Snapshot Timestamp"))
#
#     class Meta:
#         verbose_name = _("Skill Profile")
#         verbose_name_plural = _("Skill Profiles")
#         indexes = [
#             models.Index(fields=['student']),
#             models.Index(fields=['snapshot_at']),
#         ]
#
#     def __str__(self):
#         return f"Skill Profile for {self.student} at {self.snapshot_at.date()}"


class CurrentSkillProfile(models.Model):
    """
    Текущее состояние навыков студента.
    Заменяет CurrentSkill и SkillProfile.
    """
    objects = models.Manager()

    student = models.OneToOneField(
        Student,
        on_delete=models.CASCADE,
        related_name="skill_profile"
    )
    grammar = models.FloatField(default=0.0, validators=[MinValueValidator(0.0), MaxValueValidator(1.0)])
    vocabulary = models.FloatField(default=0.0, validators=[MinValueValidator(0.0), MaxValueValidator(1.0)])
    listening = models.FloatField(default=0.0, validators=[MinValueValidator(0.0), MaxValueValidator(1.0)])
    reading = models.FloatField(default=0.0, validators=[MinValueValidator(0.0), MaxValueValidator(1.0)])
    writing = models.FloatField(default=0.0, validators=[MinValueValidator(0.0), MaxValueValidator(1.0)])
    speaking = models.FloatField(default=0.0, validators=[MinValueValidator(0.0), MaxValueValidator(1.0)])
    last_updated = models.DateTimeField(auto_now=True)

    def to_dict(self):
        """Вспомогательный метод для работы со всеми навыками как со словарем"""
        return {
            'grammar': self.grammar,
            'vocabulary': self.vocabulary,
            'listening': self.listening,
            'reading': self.reading,
            'writing': self.writing,
            'speaking': self.speaking,
        }

    def update_from_dict(self, skills_dict):
        """Обновление навыков из словаря"""
        for skill, value in skills_dict.items():
            if hasattr(self, skill):
                setattr(self, skill, max(0.0, min(1.0, float(value))))

#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\models\skills\skill_snapshot.py
from django.db import models

from users.models import Student


class SkillSnapshot(models.Model):
    """
    Снимок навыков студента после оценки.
    Используется как вход для SkillTrajectoryUpdater.
    """
    objects = models.Manager()

    student = models.ForeignKey(Student, on_delete=models.CASCADE, related_name="skill_snapshots")
    grammar = models.FloatField(default=0.0)
    vocabulary = models.FloatField(default=0.0)
    listening = models.FloatField(default=0.0)
    reading = models.FloatField(default=0.0)
    writing = models.FloatField(default=0.0)
    speaking = models.FloatField(default=0.0)
    snapshot_at = models.DateTimeField(auto_now_add=True)

    def to_dict(self):
        return {
            'grammar': self.grammar,
            'vocabulary': self.vocabulary,
            'listening': self.listening,
            'reading': self.reading,
            'writing': self.writing,
            'speaking': self.speaking,
        }

    def __str__(self) -> str:
        return f"SkillSnapshot({self.student}, {self.snapshot_at})"


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\models\skills\skill_trajectory.py
from django.db import models
from curriculum.validators import SkillDomain
from users.models import Student


class SkillTrajectory(models.Model):
    """
    Агрегирует историю SkillSnapshot и Assessment
    и используется для стратегических решений.

    ЧИТАЕТСЯ:
    - ExplainabilityEngine
    - AdminExplainabilityService

    ПИШЕТСЯ:
    - SkillTrajectoryUpdater
    """
    objects = models.Manager()

    student = models.ForeignKey(Student, on_delete=models.CASCADE, related_name="skill_trajectories")
    skill = models.CharField(max_length=32, choices=SkillDomain.choices)
    trend = models.FloatField(default=0.0)
    stability = models.FloatField(default=0.0)
    plateau_detected = models.BooleanField(default=False)
    last_updated = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ("student", "skill")

    def __str__(self) -> str:
        return f"{self.student} → {self.skill}"


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\models\student\enrollment.py
from django.db import models
from django.utils import timezone
from django.utils.translation import gettext_lazy as _

from curriculum.models.content.course import Course
from curriculum.models.content.lesson import Lesson
from curriculum.models.content.task import Task
from curriculum.models.skills.skill_snapshot import SkillSnapshot
from users.models import Student


class Enrollment(models.Model):
    """
    Зачисление студента на курс с полным отслеживанием прогресса.
    """
    objects = models.Manager()

    student = models.ForeignKey(Student, on_delete=models.CASCADE, verbose_name=_("Student"))
    course = models.ForeignKey(Course, on_delete=models.CASCADE, verbose_name=_("Course"))
    started_at = models.DateTimeField(auto_now_add=True, verbose_name=_("Started At"))
    completed_at = models.DateTimeField(null=True, blank=True, verbose_name=_("Completed At"))

    # Текущее состояние обучения
    current_lesson = models.ForeignKey(
        Lesson,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        verbose_name=_("Current Lesson"),
        related_name="active_enrollments"
    )
    current_task = models.ForeignKey(
        Task,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        verbose_name=_("Current Task"),
        related_name="active_enrollments"
    )

    # Прогресс и состояние
    progress_snapshot = models.ForeignKey(
        SkillSnapshot,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        verbose_name=_("Progress Snapshot"),
        help_text=_("Последний зафиксированный снимок навыков")
    )
    is_active = models.BooleanField(default=True, verbose_name=_("Is Active"))
    last_activity = models.DateTimeField(auto_now=True, verbose_name=_("Last Activity"))

    class Meta:
        verbose_name = _("Enrollment")
        verbose_name_plural = _("Enrollments")
        indexes = [
            models.Index(fields=['student', 'course']),
            models.Index(fields=['is_active']),
            models.Index(fields=['last_activity']),
        ]
        constraints = [
            models.UniqueConstraint(
                fields=['student', 'course', 'is_active'],
                condition=models.Q(is_active=True),
                name='unique_active_enrollment'
            )
        ]

    def __str__(self):
        status = "active" if self.is_active else "completed"
        return f"{self.student} → {self.course} ({status})"

    def complete(self):
        """Завершает зачисление"""
        self.is_active = False
        self.completed_at = timezone.now()
        self.save(update_fields=['is_active', 'completed_at'])

    def get_current_skills(self):
        """Возвращает текущее состояние навыков"""
        if self.progress_snapshot:
            return self.progress_snapshot.to_dict()
        # Создаем базовый snapshot если нет
        from curriculum.services.skills.skill_snapshot_creator import SkillSnapshotCreator
        snapshot = SkillSnapshotCreator().create(student=self.student)
        self.progress_snapshot = snapshot
        self.save(update_fields=['progress_snapshot'])
        return snapshot.to_dict()


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\models\student\student.py
# from django.contrib.auth import get_user_model
# from django.db import models
# from django.utils.translation import gettext_lazy as _
#
# from users.models import CEFRLevel
#
#
# User = get_user_model()
#
#
# class Student(models.Model):
#     """
#     Профиль студента — расширение User.
#
#     Назначение:
#     - Хранит профессиональный контекст (из мини-анкеты, блок 2),
#     - Текущий CEFR-уровень,
#     - Используется для персонализации.
#
#     Поля:
#     - systematization: свободное текстовое поле или JSON с ролью/целями
#     - cefr_level: текущий уровень (обновляется после диагностики)
#     """
#     user = models.OneToOneField(User, on_delete=models.CASCADE, verbose_name=_("User"))
#     cefr_level = models.CharField(
#         max_length=2, choices=CEFRLevel, null=True, blank=True,
#         verbose_name=_("Current CEFR Level")
#     )
#     professional_context = models.TextField(
#         blank=True,
#         verbose_name=_("Professional Context"),
#         help_text=_("e.g., 'Backend developer in fintech. Need English for stand-ups and documentation.'")
#     )
#     created_at = models.DateTimeField(auto_now_add=True)
#
#     class Meta:
#         verbose_name = _("Student")
#         verbose_name_plural = _("Students")
#         indexes = [models.Index(fields=['cefr_level'])]
#
#     def __str__(self):
#         return f"{self.user.get_full_name() or self.user.username} ({self.cefr_level or '–'})"

#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\models\systematization\learning_objective.py
from django.db import models
from django.utils.translation import gettext_lazy as _

from users.models import CEFRLevel


class LearningObjective(models.Model):
    """
    Учебная цель — педагогически сформулированное умение, которое должен развить студент.

    Вместо ручного кода (например, "B1-G-01") используется структурированное описание:
    - CEFR-уровень,
    - область навыка (грамматика, лексика и т.д.),
    - порядковый номер в рамках уровня и области.

    Идентификатор (`identifier`) генерируется автоматически и гарантирует уникальность.

    Примеры:
    - "Use Past Simple and Present Perfect correctly in work contexts" → grammar, B1, order=1 → identifier="grammar-B1-01"
    - "Understand technical stand-up meetings" → listening, B1, order=1 → identifier="listening-B1-01"
    """

    # TODO промпт для генерации уроков

    """
    You are an expert English curriculum designer for IT professionals.
Your task is to generate a structured LESSON and TASKS that help the student achieve a specific LEARNING OBJECTIVE.

The student:
- Role: backend developer
- Weakness: confuses Past Simple and Present Perfect (e.g., "I have fixed it yesterday")
- Target objective: {
"identifier": "grammar-B1-01",
 "name": "Use Past Simple and Present Perfect correctly in work contexts",
  "cefr_level": "B1",
   "skill_domain": "grammar"
   }

Output JSON with two keys: "lesson" and "tasks".

LESSON FORMAT:
{
  "title": "string",
  "description": "string",
  "lesson_type": "grammar",
  "duration_minutes": int (5-15),
  "required_cefr": "B1",
  "skill_focus": ["grammar"],
  "content": { /* optional narrative for student */ }
}

TASK FORMAT (array of 3–4 tasks):
Each task must have:
- "task_type": "grammar"
- "response_format": one of ["single_choice", "multiple_choice", "short_text"]
- "difficulty_cefr": "B1"
- "content": structured per platform rules (see examples below)
- "professional_tags": ["backend", "standup-meetings"] (relevant to student)

Content examples:
- MCQ: {"prompt": "...", "options": [...], "correct_idx": 1}
- Short text: {"prompt": "...", "correct": ["expected answer"], "case_sensitive": false}

DO NOT include file uploads or audio. Keep tasks text-based.

Output ONLY valid JSON. No explanations.
    """
    # TODO system_prompt
    """
    You are an expert AI tutor and curriculum designer for IT professionals learning English.
You generate structured lessons and tasks that align with specific learning objectives.
You NEVER invent fake audio, video, or file content. Instead, you specify media requirements clearly so the system can provide real media.

All output must be valid JSON and follow the exact schema described below.
    """
    # TODO user_prompt
    """
    Generate a lesson and tasks for the following student and learning objective(s).

STUDENT CONTEXT:
- Professional role: {{ student_profession }}
- CEFR level: {{ student_cefr }}
- Learning goals: {{ student_goals }}
- Weaknesses: {{ student_weaknesses }} (e.g., ["confuses past tenses", "struggles with listening to native speakers"])
- Strengths: {{ student_strengths }} (e.g., ["strong vocabulary", "good reading comprehension"])

LEARNING OBJECTIVE(S) TO TARGET:
[ 
  {
    "identifier": "string",       // e.g., "grammar-B1-01"
    "name": "string",             // e.g., "Use Past Simple and Present Perfect correctly in work contexts"
    "skill_domain": "string",     // one of: grammar, vocabulary, reading, listening, writing, speaking
    "cefr_level": "string"        // e.g., "B1"
  },
  ... (1–3 objectives max)
]

INSTRUCTIONS:
1. Generate ONE lesson and 2–4 tasks.
2. Choose lesson_type = skill_domain of the PRIMARY objective.
3. For each task:
   - Set task_type = skill_domain
   - Choose response_format appropriately:
        • grammar/vocabulary/reading → "single_choice", "multiple_choice", or "short_text"
        • writing → "free_text"
        • speaking → "audio"
        • listening → "short_text" or "multiple_choice" (audio will be provided separately)
   - If the task requires media (e.g., listening needs audio), set:
        "media_required": true,
        "media_type": "audio|text|image",
        "media_description": "Clear description for content team (e.g., '30s stand-up audio about deployment')"
   - Do NOT include actual file paths or fake URLs.
4. Use professional context in prompts: mention stand-ups, tickets, PRs, incidents, etc.
5. Keep language supportive, clear, and professional.

OUTPUT FORMAT (strict JSON):
{
  "lesson": {
    "title": "string",
    "description": "string",
    "lesson_type": "string",           // skill_domain
    "duration_minutes": integer (5–20),
    "required_cefr": "string",
    "skill_focus": ["string"],         // e.g., ["grammar", "writing"]
    "content": { "intro": "string" }   // optional
  },
  "tasks": [
    {
      "task_type": "string",
      "response_format": "string",
      "difficulty_cefr": "string",
      "professional_tags": ["string"],  // e.g., ["backend", "standup-meetings"]
      "content": { ... },               // structured per task type (see examples below)
      "media_required": boolean,        // optional
      "media_type": "string",           // only if media_required=true
      "media_description": "string"     // only if media_required=true
    }
  ]
}

CONTENT SCHEMAS BY RESPONSE FORMAT:
- single_choice / multiple_choice:
    { "prompt": "string", "options": ["a", "b", "c"], "correct_idx": 1 }
- short_text:
    { "prompt": "string", "correct": ["answer1", "answer2"], "case_sensitive": false }
- free_text:
    { "prompt": "string", "max_length_words": 50, "expected_elements": ["past_tense", "IT_vocab"] }
- audio:
    { "prompt": "string", "max_duration_sec": 30 }

OUTPUT ONLY VALID JSON. NO MARKDOWN. NO EXPLANATIONS.
    """
    """
    📌 Как система использует этот промпт
Собирает контекст студента из Student, SkillProfile, ErrorLog.
Выбирает 1–3 LearningObjective (например, из рекомендаций адаптивного сервиса).
Подставляет данные в шаблон промпта (через Jinja или f-strings).
Отправляет в LLM → получает JSON.
Обрабатывает ответ:
Создаёт Lesson.
Для каждого Task:
сохраняет content,
если media_required == true — создаёт задачу для контент-команды или использует существующий TaskMedia (если речь о диагностике),
привязывает ProfessionalTag по совпадению (например, "backend" → ищет тег в БД).
Привязывает все задания к Lesson, а Lesson — к целям (learning_objectives).

🌟 Преимущества такого подхода
Возможность - Как реализована
Поддержка всех 6 навыков - Через skill_domain и правильный response_format
Профессиональная релевантность - professional_tags + контекст в промпте
Безопасная работа с медиа - LLM описывает, что нужно, но не выдумывает файлы
Точная привязка к целям - Используется identifier из LearningObjective
Готовность к диагностике и обучению - Один промпт работает и для Warm-up, и для глубокого урока

    """
    # === Структурированные поля ===
    cefr_level = models.CharField(
        max_length=2,
        choices=CEFRLevel,
        verbose_name=_("CEFR Level"),
        help_text=_("Уровень CEFR, на котором эта цель актуальна")
    )
    skill_domain = models.CharField(
        max_length=20,
        choices=[
            ('grammar', _('Grammar')),
            ('vocabulary', _('Vocabulary')),
            ('listening', _('Listening')),
            ('reading', _('Reading')),
            ('writing', _('Writing')),
            ('speaking', _('Speaking')),
        ],
        verbose_name=_("Skill Domain"),
        help_text=_("Область языкового навыка")
    )
    order_in_level = models.PositiveSmallIntegerField(
        default=1,
        verbose_name=_("Order within level and domain"),
        help_text=_("Порядковый номер цели в рамках уровня и области (для сортировки)")
    )

    # === Человекочитаемые поля ===
    name = models.CharField(
        max_length=200,
        verbose_name=_("Name"),
        help_text=_("Clear, actionable objective — e.g., 'Use Past Simple correctly in work emails'")
    )
    description = models.TextField(
        blank=True,
        verbose_name=_("Description"),
        help_text=_("Optional detailed explanation for methodologists")
    )

    # === Автоматически генерируемый идентификатор (для API, логики, LLM) ===
    identifier = models.SlugField(
        max_length=50,
        unique=True,
        editable=False,
        verbose_name=_("Machine Identifier"),
        help_text=_("Auto-generated unique ID like 'grammar-B1-01'")
    )

    # === Служебные поля ===
    is_active = models.BooleanField(default=True, verbose_name=_("Is Active"))
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        verbose_name = _("Learning Objective")
        verbose_name_plural = _("Learning Objectives")
        unique_together = [
            ['cefr_level', 'skill_domain', 'order_in_level']
        ]
        ordering = ['cefr_level', 'skill_domain', 'order_in_level']
        indexes = [
            models.Index(fields=['cefr_level', 'skill_domain']),
            models.Index(fields=['identifier']),
        ]

    def save(self, *args, **kwargs):
        # Генерируем идентификатор вида: grammar-B1-01
        self.identifier = f"{self.skill_domain}-{self.cefr_level}-{self.order_in_level:02d}"
        super().save(*args, **kwargs)

    def __str__(self):
        return f"[{self.identifier}] {self.name}"

#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\models\systematization\professional_tag.py
from django.db import models
from django.utils.translation import gettext_lazy as _


class ProfessionalTag(models.Model):
    """
    Профессиональный тег — обозначает сферу или тип задач, релевантных заданию.
    Примеры: "backend", "qa", "incident-response", "technical-writing".

    Назначение:
    - Позволяет персонализировать диагностику и обучение под роль студента (из мини-анкеты).
    - Используется для фильтрации заданий по релевантности.

    Примеры наполнения:
    - "backend"
    - "qa"
    - "devops"
    - "product-interviews"
    - "api-documentation"
    - "standup-meetings"
    - "ticket-writing"

    Рекомендация:
    - Теги создаются кураторами/методистами.
    - Студент выбирает 1–3 тега при регистрации или в мини-анкете.
    """
    name = models.CharField(
        max_length=50,
        unique=True,
        verbose_name=_("Tag Name"),
        help_text=_("Short, machine-readable name (e.g., 'backend', 'standup-meetings')")
    )
    description = models.CharField(
        max_length=200,
        blank=True,
        verbose_name=_("Description"),
        help_text=_("Human-readable explanation for admins")
    )
    is_active = models.BooleanField(default=True, verbose_name=_("Is Active"))

    class Meta:
        verbose_name = _("Professional Tag")
        verbose_name_plural = _("Professional Tags")
        indexes = [models.Index(fields=['name'])]

    def __str__(self):
        return self.name


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\models\teacher\teacher.py
# from django.contrib.auth import get_user_model
# from django.db import models
# from django.utils.translation import gettext_lazy as _
#
#
# User = get_user_model()
#
#
# class Teacher(models.Model):
#     """
#     Профиль учителя — расширение User.
#
#
#     """
#     user = models.OneToOneField(User, on_delete=models.CASCADE, verbose_name=_("User"))
#
#     created_at = models.DateTimeField(auto_now_add=True)
#
#     class Meta:
#         verbose_name = _("Учитель")
#         verbose_name_plural = _("Учителя")


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\curriculum_query.py
from typing import Optional

from curriculum.models import StudentTaskResponse
from curriculum.models.student.enrollment import Enrollment
from curriculum.models.content.lesson import Lesson
from curriculum.models.content.task import Task


class CurriculumQueryService:
    """
    Read-only сервис доступа к учебному контенту.

    Инкапсулирует правила:
    - выбора текущего урока
    - порядка заданий
    - фильтрации неактивного контента

    TODO (CurriculumQueryService):

    1. Поддержка diagnostic lessons
    2. Фильтрация задач по ProfessionalTag (через weighting, не exclude)
    3. Поддержка branching curriculum
    4. Предзагрузка related (performance)
    """

    # ------------------------------------------------------------------
    # LESSON
    # ------------------------------------------------------------------

    def get_current_lesson(self, enrollment: Enrollment) -> Lesson:
        """
        Возвращает текущий урок для enrollment.

        Если текущий урок не установлен — выбирается первый доступный.
        """

        if enrollment.current_lesson:
            return enrollment.current_lesson

        first_lesson = (
            Lesson.objects
            .filter(course=enrollment.course, is_active=True)
            .order_by("order")
            .first()
        )

        return first_lesson

    # TASKS

    def get_next_task(self, enrollment: Enrollment) -> Optional[Task]:
        """
        Возвращает следующее невыполненное задание для студента в текущем уроке.
        """
        if not enrollment.current_lesson:
            return None

        completed_task_ids = StudentTaskResponse.objects.filter(
            student=enrollment.student,
            task__lesson=enrollment.current_lesson
        ).values_list('task_id', flat=True)

        return Task.objects.filter(
            lesson=enrollment.current_lesson,
            is_active=True
        ).exclude(
            id__in=completed_task_ids
        ).order_by('order').first()

    def get_lesson_history(self, enrollment: Enrollment, lesson: Lesson) -> list:
        """
        Возвращает историю ответов студента по уроку.

        Возвращает список словарей с информацией о каждом задании и ответе:
        {
            'task': Task,
            'response': StudentTaskResponse,
            'assessment': Assessment,
            'is_completed': bool,
            'score': float,
            'feedback': str
        }
        """
        # Получаем все задания урока
        tasks = list(Task.objects.filter(lesson=lesson, is_active=True).order_by('order'))

        # Получаем все ответы студента по уроку
        responses = StudentTaskResponse.objects.filter(
            student=enrollment.student,
            task__lesson=lesson
        ).select_related(
            'task', 'assessment'
        ).prefetch_related(
            'assessment__error_tags'
        ).order_by('created_at')

        # Создаем словарь для быстрого поиска ответов по task_id
        responses_by_task = {response.task_id: response for response in responses}

        # Формируем результат
        history = []
        for task in tasks:
            response = responses_by_task.get(task.id)
            assessment = response.assessment if response else None

            history.append({
                'task': task,
                'response': response,
                'assessment': assessment,
                'is_completed': response is not None,
                'score': assessment.score if assessment else None,
                'feedback': assessment.feedback.get('message', '') if assessment and assessment.feedback else '',
                'created_at': response.created_at if response else None
            })

        return history

    def get_completed_lessons(self, enrollment: Enrollment) -> list:
        """
        Возвращает список пройденных уроков с информацией о прогрессе.

        Возвращает список словарей:
        {
            'lesson': Lesson,
            'completed_tasks': int,
            'total_tasks': int,
            'completion_percent': float,
            'last_response_date': datetime
        }
        """
        if not enrollment.current_lesson:
            return []

        # Получаем все уроки курса до текущего
        completed_lessons = Lesson.objects.filter(
            course=enrollment.course,
            is_active=True,
            order__lt=enrollment.current_lesson.order
        ).order_by('order').prefetch_related('tasks')

        result = []
        for lesson in completed_lessons:
            # Считаем общее количество заданий в уроке
            total_tasks = lesson.tasks.filter(is_active=True).count()

            # Считаем количество выполненных заданий
            completed_tasks = StudentTaskResponse.objects.filter(
                student=enrollment.student,
                task__lesson=lesson,
                task__is_active=True
            ).count()

            # Получаем дату последнего ответа
            last_response = StudentTaskResponse.objects.filter(
                student=enrollment.student,
                task__lesson=lesson
            ).order_by('-created_at').first()

            completion_percent = round((completed_tasks / total_tasks) * 100, 1) if total_tasks > 0 else 0

            result.append({
                'lesson': lesson,
                'completed_tasks': completed_tasks,
                'total_tasks': total_tasks,
                'completion_percent': completion_percent,
                'last_response_date': last_response.created_at if last_response else None
            })

        return result


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\enrollment_service.py
from django.db import transaction
from django.utils import timezone

from curriculum.models.student.enrollment import Enrollment
from curriculum.models.content.course import Course
from curriculum.services.curriculum_query import CurriculumQueryService
from users.models import Student


class EnrollmentService:
    """
    Service для управления зачислением студентов на курсы.
    """

    def __init__(self, curriculum_query: CurriculumQueryService):
        self.curriculum_query = curriculum_query

    def enroll_student(self, student: Student, course: Course) -> Enrollment:
        """
        Зачисляет студента на курс.

        Args:
            student: Студент для зачисления
            course: Курс, на который нужно зачислить студента

        Returns:
            Enrollment: Объект зачисления

        Raises:
            ValueError: Если курс не имеет активных уроков
        """
        # Проверяем, не зачислен ли уже студент на этот курс
        existing_enrollment = Enrollment.objects.filter(
            student=student,
            course=course,
            is_active=True
        ).first()

        if existing_enrollment:
            return existing_enrollment

        # Создаем новое зачисление
        enrollment = Enrollment(
            student=student,
            course=course,
        )

        first_lesson = self.curriculum_query.get_current_lesson(enrollment)

        if not first_lesson:
            raise ValueError(f"Course {course.pk} has no active lessons")

        enrollment.current_lesson = first_lesson
        enrollment.save()

        return enrollment

    @transaction.atomic
    def complete_course(self, enrollment: Enrollment) -> Enrollment:
        """
        Завершает курс для студента.

        Args:
            enrollment: Объект зачисления для завершения

        Returns:
            Enrollment: Обновленный объект зачисления
        """
        enrollment.is_active = False
        enrollment.completed_at = timezone.now()  # Добавляем время завершения
        enrollment.save(update_fields=['is_active', 'completed_at'])
        return enrollment

    def get_student_enrollments(self, student: Student) -> list[Enrollment]:
        """
        Возвращает все активные зачисления студента.

        Args:
            student: Студент

        Returns:
            list[Enrollment]: Список активных зачислений
        """
        return Enrollment.objects.filter(
            student=student,
            is_active=True
        ).select_related(
            'course',
            'current_lesson',
            'current_lesson__course'
        ).prefetch_related(
            'current_lesson__tasks'
        ).order_by('course__target_cefr_from')

    # def calculate_progress(self, enrollment: Enrollment) -> float:
    #     """
    #     Рассчитывает процент прогресса студента в курсе.
    #
    #     Args:
    #         enrollment: Объект зачисления
    #
    #     Returns:
    #         float: Процент прогресса (0.0 - 100.0)
    #     """
    #     if not enrollment.current_lesson:
    #         return 0.0
    #
    #     # Получаем общее количество активных уроков в курсе
    #     total_lessons = enrollment.course.lessons.filter(is_active=True).count()
    #     if not total_lessons:
    #         return 0.0
    #
    #     # Рассчитываем прогресс на основе порядка текущего урока
    #     current_lesson_order = enrollment.current_lesson.order
    #     return (current_lesson_order / total_lessons) * 100.0

    def get_course_progress(self, enrollment: Enrollment) -> dict:
        """
        Возвращает детальную информацию о прогрессе в курсе.

        Корректная семантика:
        - completed_lessons: количество ПОЛНОСТЬЮ ЗАВЕРШЕННЫХ уроков
        - current_lesson: текущий активный урок (может быть не завершен)
        - progress_percent: процент завершенных уроков

        Пример:
        - 5 уроков в курсе
        - Студент на уроке 3
        - completed_lessons = 2 (уроки 1 и 2 завершены)
        - progress_percent = 40% (2/5)
        """
        # Получаем все активные уроки курса
        active_lessons = enrollment.course.lessons.filter(is_active=True).order_by('order')
        total_lessons = active_lessons.count()

        if not total_lessons:
            return {
                'progress_percent': 0,
                'completed_lessons': 0,
                'total_lessons': 0,
                'current_lesson': None,
                'next_lesson': None,
                'is_course_completed': False
            }

        current_lesson = enrollment.current_lesson

        # Рассчитываем завершенные уроки
        completed_lessons = 0
        if current_lesson:
            # Все уроки с order < текущего считаются завершенными
            completed_lessons = active_lessons.filter(order__lt=current_lesson.order).count()

        # Рассчитываем прогресс (только завершенные уроки)
        progress_percent = (completed_lessons / total_lessons) * 100 if total_lessons > 0 else 0

        # Определяем следующий урок (только если текущий завершен)
        next_lesson = None
        is_course_completed = False

        if current_lesson:
            # Проверяем, завершен ли текущий урок
            # (в реальной системе здесь должна быть логика проверки завершенности урока)
            current_lesson_completed = self._is_lesson_completed(enrollment, current_lesson)

            if current_lesson_completed:
                # Ищем следующий урок
                next_lesson = active_lessons.filter(order__gt=current_lesson.order).first()
                if not next_lesson:
                    is_course_completed = True
        else:
            # Если нет текущего урока, начинаем с первого
            next_lesson = active_lessons.first()
        return {
            'progress_percent': int(progress_percent),
            'completed_lessons': completed_lessons,
            'total_lessons': total_lessons,
            'current_lesson': current_lesson,
            'next_lesson': next_lesson,
            'is_course_completed': is_course_completed,
            'all_lessons_completed': completed_lessons == total_lessons
        }

    def _is_lesson_completed(self, enrollment: Enrollment, lesson) -> bool:
        """
        Проверяет, завершен ли урок для данного зачисления.

        В реальной системе здесь должна быть логика:
        - Проверка завершения всех заданий в уроке
        - Проверка достижения минимального score
        - Проверка прохождения всех required заданий

        Для MVP возвращаем False, чтобы не усложнять логику.
        """
        # TODO: Реализовать реальную проверку завершенности урока
        return False


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\learning_service.py
import logging
from typing import Any, Dict

from django.utils import timezone

from curriculum.exceptions import InvalidResponseError, InvalidTaskError, LearningProcessError, AssessmentError
from curriculum.infrastructure.adapters.auto_assessment_adapter import AutoAssessorAdapter
from curriculum.infrastructure.adapters.llm_assessment_adapter import LLMAssessmentAdapter
from curriculum.models.assessment.assessment import Assessment
from curriculum.models.progress.lesson_transition import LessonTransition
from curriculum.models.skills.skill_snapshot import SkillSnapshot
from curriculum.models.student.enrollment import Enrollment
from curriculum.models.content.task import Task, ResponseFormat
from curriculum.models.assessment.student_response import StudentTaskResponse
from curriculum.services.assessment.assessment_service import AssessmentService


from curriculum.services.curriculum_query import CurriculumQueryService
from curriculum.services.decisions.decision_service import DecisionService, Decision
from curriculum.services.enrollment_service import EnrollmentService
from curriculum.services.progression.progression_service import ProgressionService, ProgressionResult
from curriculum.services.progression.transition_recorder import TransitionRecorder
from curriculum.services.skills.skill_update_service import SkillUpdateService, SkillUpdateResult

logger = logging.getLogger(__name__)


class LearningService:
    """
    LearningService — stateless координатор одного шага обучения.

    Он НЕ:
    - хранит состояние
    - принимает бизнес-решения
    - знает про UI / LLM / Orchestrator

    Он:
    - извлекает текущее состояние обучения
    - координирует оценку, обновление навыков и прогресса
    - возвращает структурированный результат шага
    """

    def __init__(
            self,
            curriculum_query: CurriculumQueryService | None = None,
            assessment_service: AssessmentService | None = None,
            skill_update_service: SkillUpdateService | None = None,
            decision_service: DecisionService | None = None,
            progression_service: ProgressionService | None = None,
            transition_recorder: TransitionRecorder | None = None,
            enrollment_service: EnrollmentService | None = None,
    ):
        """
        Все зависимости внедряются явно.

        Это позволяет:
        - тестировать сервис изолированно
        - подменять реализации (auto → llm)
        - не привязываться к DI-фреймворку
        """

        self.curriculum_query = curriculum_query or CurriculumQueryService()
        self.assessment_service = assessment_service or AssessmentService(
            llm_adapter=LLMAssessmentAdapter(),
            auto_adapter=AutoAssessorAdapter(),
        )
        self.skill_update_service = skill_update_service or SkillUpdateService()
        self.decision_service = decision_service or DecisionService()
        self.progression_service = progression_service or ProgressionService()
        self.transition_recorder = transition_recorder or TransitionRecorder()
        self.enrollment_service = enrollment_service or EnrollmentService(
            curriculum_query=self.curriculum_query
        )

    # ---------------------------------------------------------------------
    # READ API
    # ---------------------------------------------------------------------

    def get_current_state(self, enrollment_id: int) -> Dict[str, Any]:
        """
        Возвращает текущее состояние обучения для Orchestrator / UI.

        Используется для:
        - восстановления сессии
        - отображения прогресса

        Пример входа / выхода
        {
          "enrollment_id": 42,
          "task_id": 101,
          "response": {
            "text": "I has finished my work"
          }
        }
        ==>
        {
          "decision": "REPEAT",
          "next_action": "RETRY_TASK",
          "next_task_id": 101,
          "feedback": {
            "error_type": "grammar",
            "hint": "Check verb agreement"
          }
        }

        TODO (LearningService):
        - учитывать TeacherOverride перед DecisionService
        - расширить get_current_state для explainability
        - добавить support multi-task lessons
        """

        enrollment = Enrollment.objects.select_related(
            "student",
            "course",
            "current_lesson"
        ).get(id=enrollment_id)

        # Получаем последний SkillSnapshot для студента
        latest_snapshot = SkillSnapshot.objects.filter(
            student=enrollment.student
        ).order_by('-snapshot_at').first()

        # Формируем данные урока с нужными полями
        lesson_data = None
        if enrollment.current_lesson:
            lesson_data = {
                "id": enrollment.current_lesson.id,
                "order": enrollment.current_lesson.order,  # Критически важно для UI!
                "title": enrollment.current_lesson.title,
                "total_tasks": enrollment.current_lesson.tasks.count()
            }

        # Формируем данные задачи
        task_data = None
        if hasattr(enrollment, 'current_task') and enrollment.current_task:
            task_data = {
                "id": enrollment.current_task.id,
                "type": enrollment.current_task.task_type,
                # "position": enrollment.current_task.position
            }

        skills_data = latest_snapshot.to_dict() if latest_snapshot else {
            "grammar": 0.0,
            "vocabulary": 0.0,
            "listening": 0.0,
            "reading": 0.0,
            "writing": 0.0,
            "speaking": 0.0
        }

        # return {
        #     "enrollment_id": enrollment.id,
        #     "course": enrollment.course_id,
        #     "current_lesson": enrollment.current_lesson_id if enrollment.current_lesson else None,
        #     "current_task": enrollment.current_task_id if hasattr(enrollment, 'current_task') else None,
        #     "skills": skills_data,
        # }

        return {
            "enrollment_id": enrollment.id,
            "course": {
                "id": enrollment.course.id,
                "title": enrollment.course.title,
            },
            "current_lesson": lesson_data,
            "current_task": task_data,
            "skills": skills_data,
            # "progress": {
            #     "lesson_progress": enrollment.lesson_progress,
            #     "course_completion": enrollment.course_completion
            # }
        }

    def get_next_task(self, enrollment_id: int) -> Task:
        """
        Возвращает следующее задание, которое студент должен выполнить.

        Важно:
        - НЕ принимает решений
        - только читает текущее состояние
        """

        enrollment = Enrollment.objects.get(id=enrollment_id)

        return self.curriculum_query.get_next_task(enrollment)

    # ---------------------------------------------------------------------
    # WRITE API (основной flow)
    # ---------------------------------------------------------------------

    def submit_task_response(
            self,
            enrollment_id: int,
            task_id: int,
            response_payload: Dict[str, Any],
    ) -> Dict[str, Any]:
        """
        Основной метод учебного шага с полной функциональностью.

        Алгоритм:
        1. Валидация входных данных
        2. Фиксация ответа студента (event)
        3. Запуск assessment с обработкой ошибок
        4. Обновление skills с логированием изменений
        5. Принятие решения с учетом контекста
        6. Обновление progression с защитой от некорректных состояний
        7. Запись transition для аудита и объяснимости
        8. Возврат структурированного результата с метаданными

        Args:
            enrollment_id: ID зачисления студента
            task_id: ID задания
            response_payload: Ответ студента:
                - Для текста: {"text": "ответ студента"}
                - Для аудио: {"audio_file": file_object}

        Returns:
            Dict[str, Any]: Результат обработки:
                {
                    "decision": "ADVANCE_TASK",
                    "next_action": "NEXT_TASK",
                    "next_task_id": 102,
                    "feedback": {...},
                    "assessment": Assessment,
                    "transition": LessonTransition
                }

        Raises:
            LearningProcessError: При ошибках в учебном процессе
            AssessmentError: При ошибках оценки
            SkillUpdateError: При ошибках обновления навыков
        """

        print(f"{enrollment_id=}")
        print(f"{task_id=}")
        print(f"{response_payload=}")
        try:
            # 1. Валидация и получение данных
            enrollment = self._get_enrollment_with_prefetch(enrollment_id)
            task = self._get_task_with_validation(task_id, enrollment)

            # 2. Фиксируем ответ студента (event)
            student_response = self._create_student_response(
                enrollment=enrollment,
                task=task,
                response_payload=response_payload
            )

            # 3. Assessment с детальным логированием
            assessment_result = self._perform_assessment(
                student_response=student_response,
                task=task
            )

            # 4. Update skills & error logs
            skill_update_result = self._update_skills(
                enrollment=enrollment,
                task=task,
                assessment_result=assessment_result
            )

            # 5. Decision с учетом всех факторов
            decision = self._make_decision(
                enrollment=enrollment,
                skill_update_result=skill_update_result
            )

            # 6. Apply progression
            progression_result = self._apply_progression(
                enrollment=enrollment,
                decision=decision
            )

            # 7. Record transition (audit & explainability)
            transition = self._record_transition(
                enrollment=enrollment,
                task=task,
                decision=decision,
                assessment_result=assessment_result,
                skill_update_result=skill_update_result
            )

            # 8. Обновление времени последней активности
            self._update_last_activity(enrollment)

            # 9. Возвращаем полный результат
            return {
                "decision": decision.code,
                "next_action": progression_result.next_action,
                "next_task_id": progression_result.next_task_id,
                "feedback": assessment_result.structured_feedback,
                "assessment": assessment_result,
                "transition": transition,
                "skill_updates": skill_update_result.updated_skills
            }

        except Exception as e:
            logger.error(
                f"Error in LearningService.submit_task_response: {str(e)}",
                extra={
                    "enrollment_id": enrollment_id,
                    "task_id": task_id,
                    "error_type": type(e).__name__
                },
                exc_info=True
            )
            raise LearningProcessError(f"Failed to process task response: {str(e)}",
                                       enrollment_id=enrollment_id) from e

    def get_course_history(self, enrollment_id: int) -> dict:
        """
        Возвращает историю пройденных уроков в курсе.

        Args:
            enrollment_id: ID зачисления

        Returns:
            dict: {
                'course': Course,
                'completed_lessons': list,  # Список пройденных уроков
                'enrollment': Enrollment,
                'overall_progress': float
            }
        """
        enrollment = Enrollment.objects.get(id=enrollment_id, is_active=True)
        completed_lessons = self.curriculum_query.get_completed_lessons(enrollment)
        overall_progress = self.enrollment_service.get_course_progress(enrollment)

        return {
            'course': enrollment.course,
            'completed_lessons': completed_lessons,
            'enrollment': enrollment,
            'overall_progress': overall_progress
        }

    def _get_enrollment_with_prefetch(self, enrollment_id: int) -> Enrollment:
        """Получение зачисления с предзагрузкой связанных данных"""
        return Enrollment.objects.select_related(
            "student",
            "course",
            "current_lesson",
            "current_lesson__course"
        ).prefetch_related(
            "current_lesson__tasks",
            "current_lesson__learning_objectives",
            "student__skill_profile"
        ).get(id=enrollment_id, is_active=True)

    def _get_task_with_validation(self, task_id: int, enrollment: Enrollment) -> Task:
        """Получение и валидация задания"""
        task = Task.objects.select_related(
            "lesson",
            "lesson__course"
        ).prefetch_related(
            "professional_tags",
            "media_files"
        ).get(id=task_id)

        # Проверка принадлежности задания к текущему уроку
        if task.lesson != enrollment.current_lesson:
            raise InvalidTaskError(
                f"Task {task_id} does not belong to current lesson {enrollment.current_lesson_id}"
            )

        return task

    def _create_student_response(
            self,
            enrollment: Enrollment,
            task: Task,
            response_payload: Dict[str, Any]
    ) -> StudentTaskResponse:
        """Создание ответа студента с валидацией"""
        if task.response_format == ResponseFormat.AUDIO:
            if 'audio_file' not in response_payload:
                raise InvalidResponseError("Audio response requires 'audio_file' field")

            # Валидация файла
            audio_file = response_payload['audio_file']
            if not hasattr(audio_file, 'content_type') or audio_file.content_type not in ['audio/mpeg', 'audio/wav',
                                                                                          'audio/ogg']:
                raise InvalidResponseError("Invalid audio file format")

            # Ограничение размера файла
            if hasattr(audio_file, 'size') and audio_file.size > settings.MAX_AUDIO_FILE_SIZE:
                raise InvalidResponseError(
                    f"Audio file exceeds maximum size of {settings.MAX_AUDIO_FILE_SIZE // 1024 // 1024}MB")

            return StudentTaskResponse.objects.create(
                student=enrollment.student,
                task=task,
                audio_file=audio_file
            )

        # Для текстовых ответов
        text_response = response_payload.get('text', '').strip()
        if not text_response:
            raise InvalidResponseError("Text response cannot be empty")

        # Ограничение длины для разных форматов
        if task.response_format == ResponseFormat.FREE_TEXT:
            if len(text_response) > settings.MAX_FREE_TEXT_LENGTH:
                raise InvalidResponseError(
                    f"Text response exceeds maximum length of {settings.MAX_FREE_TEXT_LENGTH} characters")
        elif task.response_format == ResponseFormat.SHORT_TEXT:
            if len(text_response) > settings.MAX_SHORT_TEXT_LENGTH:
                raise InvalidResponseError(
                    f"Text response exceeds maximum length of {settings.MAX_SHORT_TEXT_LENGTH} characters")

        return StudentTaskResponse.objects.create(
            student=enrollment.student,
            task=task,
            response_text=text_response
        )

    def _perform_assessment(
            self,
            student_response: StudentTaskResponse,
            task: Task
    ) -> Assessment:
        """Выполнение оценки с обработкой ошибок"""
        try:
            assessment = self.assessment_service.assess(
                student_response=student_response
            )

            return assessment
        except AssessmentError as e:
            logger.warning(f"Assessment failed, using fallback: {str(e)}")
            # Создаем fallback assessment
            return self._create_fallback_assessment(student_response, task, str(e))
        except Exception as e:
            logger.error(f"Critical assessment error: {str(e)}")
            raise AssessmentError(f"Critical assessment error: {str(e)}") from e

    def _create_fallback_assessment(
            self,
            student_response: StudentTaskResponse,
            task: Task,
            error: str
    ) -> Assessment:
        """Создание fallback assessment при ошибках"""
        return Assessment.objects.create(
            task_response=student_response,
            score=0.5,  # Нейтральная оценка
            is_correct=None,
            error_tags=["assessment_failed", "fallback_used"],
            feedback={
                "message": "Произошла временная ошибка при оценке. Ваш ответ будет проверен дополнительно.",
                "error": error
            },
            raw_output={
                "error": error,
                "fallback": True,
                "timestamp": timezone.now().isoformat()
            },
            llm_version="fallback"
        )

    def _update_skills(
            self,
            enrollment: Enrollment,
            task: Task,
            assessment_result: Assessment
    ) -> SkillUpdateResult:
        """Обновление навыков с логированием"""
        try:
            return self.skill_update_service.update(
                enrollment=enrollment,
                task=task,
                assessment_result=assessment_result,
            )
        except Exception as e:
            logger.error(f"Skill update failed: {str(e)}")
            # Не прерываем процесс обучения при ошибках обновления навыков
            return SkillUpdateResult(
                updated_skills={},
                deltas={},
                snapshot=None,
                error_events=[str(e)]
            )

    def _make_decision(
            self,
            enrollment: Enrollment,
            skill_update_result: SkillUpdateResult
    ) -> Decision:
        """Принятие решения с учетом всех факторов"""
        try:
            return self.decision_service.decide(
                enrollment=enrollment,
                lesson=enrollment.current_lesson,
                skill_profile_update=skill_update_result,
            )
        except Exception as e:
            logger.error(f"Decision making failed: {str(e)}")
            # Fallback решение - продолжать обучение
            return Decision(
                code="ADVANCE_TASK",
                confidence=0.5,
                rationale={
                    "reason": "fallback_decision",
                    "error": str(e)
                }
            )

    def _apply_progression(
            self,
            enrollment: Enrollment,
            decision: Decision
    ) -> ProgressionResult:
        """Применение решения к прогрессу"""
        try:
            return self.progression_service.apply_decision(
                enrollment=enrollment,
                decision=decision,
            )
        except Exception as e:
            logger.error(f"Progression update failed: {str(e)}")
            # Fallback - оставляем текущее состояние
            return ProgressionResult(
                next_action="RETRY_TASK",
                next_task_id=enrollment.current_task.pk if enrollment.current_task else None
            )

    def _record_transition(
            self,
            enrollment: Enrollment,
            task: Task,
            decision: Decision,
            assessment_result: Assessment,
            skill_update_result: SkillUpdateResult
    ) -> LessonTransition:
        """Запись перехода для аудита и объяснимости"""
        try:
            return self.transition_recorder.record(
                enrollment=enrollment,
                task=task,
                decision=decision,
                assessment_result=assessment_result,
                skill_update_result=skill_update_result.snapshot
            )
        except Exception as e:
            logger.warning(f"Failed to record transition: {str(e)}")
            return None

    def _update_last_activity(self, enrollment: Enrollment):
        """Обновление времени последней активности"""
        try:
            enrollment.last_activity = timezone.now()
            enrollment.save(update_fields=["last_activity"])
        except Exception as e:
            logger.warning(f"Failed to update last activity: {str(e)}")


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\SERVICES.md
# curriculum.services — Application services

Этот документ описывает **application‑слой** модуля `curriculum`.

Services:
- координируют поток обучения
- работают поверх domain‑моделей
- НЕ хранят состояние
- НЕ принимают UI / LLM‑решений

Их задача — **соединить доменные факты в корректный flow**.

---

## 1. Роль services в архитектуре

`services` — это **application layer**, а не domain и не infrastructure.

Они:
- получают входные данные (response, enrollment, context)
- вызывают доменные операции
- сохраняют результаты (через models)
- возвращают структурированный результат

❗ Services не должны:
- держать состояние между вызовами
- напрямую обращаться к LLM
- формировать UI‑ответы

---

## 2. Общий flow (service‑level)

```
LearningService
    ↓
AssessmentService
    ↓
SkillUpdateService
    ↓
DecisionService
    ↓
TransitionRecorder
```

Дополнительно:
- `CurriculumQuery` используется для чтения структуры
- `ProgressionService` управляет выбором следующего шага

---

## 3. Основные сервисы

### LearningService

**Роль:**
- основной entrypoint обучающего процесса
- связывает response → assessment → decision

**Типичный вход:**
- enrollment
- student_response

**Типичный выход:**
- decision_code
- next_lesson / task
- explanation (через explainability)

---

### AssessmentService

**Роль:**
- оценка StudentResponse

**Гарантии:**
- всегда создаёт Assessment
- Assessment неизменяем

---

### SkillUpdateService

**Роль:**
- координация обновления навыков

**Что делает:**
- создаёт SkillSnapshot
- вызывает SkillTrajectoryUpdater

**Важно:**
- не содержит формул
- делегирует расчёты специализированным компонентам

---

### SkillTrajectoryUpdater

**Роль:**
- обновление SkillTrajectory

**Использует:**
- Assessment
- SkillSnapshot

**Гарантии:**
- один trajectory на (student, skill)

---

### DecisionService

**Роль:**
- выбор следующего шага обучения

**Вход:**
- Assessment
- SkillTrajectory
- context

**Выход:**
- decision_code

❗ DecisionService не знает, как выполняется переход.

---

### ProgressionService

**Роль:**
- интерпретация decision_code
- выбор следующего Lesson / Task

---

### TransitionRecorder

**Роль:**
- запись LessonTransition

**Гарантии:**
- LessonTransition immutable
- запись происходит один раз

---

## 4. Вспомогательные сервисы

### CurriculumQuery

**Роль:**
- чтение структуры курса

Используется:
- LearningService
- ProgressionService

---

## 5. Взаимодействие с explainability

Services:
- НЕ формируют объяснения
- передают факты в explainability слой

Explainability:
- читает LessonTransition
- читает Assessment / SkillSnapshot
- возвращает dict

---

## 6. Инварианты

- Services stateless
- Один сервис — одна ответственность
- Нет циклических вызовов
- Нет сохранения состояния между шагами

---

## 8. TODO / точки развития

- Policy‑based DecisionService
- Replay flow на основе LessonTransition
- Simulation / what‑if режим



#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\SERVICES_SCHEMA.md
┌─────────────────────────────────────────────┐
│          EXTERNAL / ORCHESTRATION           │
│                                             │
│  (Chat, UI, Agent, Orchestrator, API)       │
│                                             │
│  decides WHEN to start learning flow        │
└───────────────────────┬─────────────────────┘
                        │
                        │ calls
                        │
┌───────────────────────▼─────────────────────┐
│              LearningService                │
│                                             │
│  Entry point учебного процесса              │
│                                             │
│  handle_response(enrollment, response)      │
└───────────────────────┬─────────────────────┘
                        │
                        │ sequential orchestration
                        │
        ┌───────────────┼───────────────────────────┐
        │               │                           │
        ▼               ▼                           ▼
┌──────────────┐ ┌──────────────┐         ┌─────────────────┐
│AssessmentSvc │ │SkillUpdateSvc│         │DecisionService  │
│              │ │              │         │                 │
│ response →   │ │ assessment → │         │ assessment +    │
│ Assessment   │ │ SkillSnapshot│         │ trajectories →  │
└──────┬───────┘ │              │         │ decision_code   │
       │         └──────┬───────┘         └────────┬────────┘
       │                │                            │
       ▼                ▼                            ▼
┌──────────────┐  ┌──────────────────┐      ┌──────────────────┐
│ Assessment   │  │ SkillSnapshot    │      │ decision_code    │
│ (immutable)  │  │ (immutable)      │      │ (string)         │
└──────────────┘  └──────────────────┘      └──────────────────┘
                        │
                        │ updates
                        ▼
              ┌─────────────────────────┐
              │ SkillTrajectoryUpdater  │
              │                         │
              │ snapshot → trajectory   │
              └───────────┬─────────────┘
                          │
                          ▼
                ┌─────────────────────┐
                │ SkillTrajectory     │
                │ (aggregated state)  │
                └─────────────────────┘

                        │
                        │ interprets decision
                        ▼
┌─────────────────────────────────────────────┐
│           ProgressionService                │
│                                             │
│ decision_code → next lesson / task          │
└───────────────────────┬─────────────────────┘
                        │
                        │ records fact
                        ▼
┌─────────────────────────────────────────────┐
│           TransitionRecorder                │
│                                             │
│ creates LessonTransition (audit fact)       │
└───────────────────────┬─────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────┐
│           LessonTransition                  │
│           (immutable, audit)                │
└─────────────────────────────────────────────┘


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\assessment\assessment_service.py
# import logging
#
# from django.utils import timezone
#
# from curriculum.application.ports.assessment_port import AssessmentPort
# from curriculum.infrastructure.adapters.auto_assessment_adapter import AutoAssessorAdapter
# from curriculum.infrastructure.adapters.llm_assessment_adapter import LLMAssessmentAdapter
# from curriculum.infrastructure.repositories.assessment_repository import AssessmentRepository
# from curriculum.models.assessment.assessment import Assessment
# from curriculum.models.assessment.student_response import StudentTaskResponse
# from curriculum.models.content.task import Task
#
# logger = logging.getLogger(__name__)
#
#
# class AssessmentService:
#     """
#     AssessmentService координирует процесс оценки ответа студента.
#
#     Он:
#     - выбирает стратегию оценки
#     - нормализует результат
#     - сохраняет Assessment как факт
#
#     TODO (AssessmentService):
#
#     1. LLM-based assessment
#     2. Hybrid assessment (auto + llm)
#     3. Teacher validation of assessment
#     4. Confidence scoring
#     5. Bias tracking by ProfessionalTag
#     """
#
#     def __init__(
#             self,
#             auto_adapter: AutoAssessorAdapter,
#             llm_adapter: LLMAssessmentAdapter
#     ):
#         self.assessment_port = auto_adapter
#         self.llm_adapter = llm_adapter
#
#     def assess(self, student_response: StudentTaskResponse) -> Assessment:
#         """
#         Полный цикл оценки с нормализацией результатов.
#         """
#         task = student_response.task
#
#         try:
#             assessment_result = self.assessment_port.assess_task(task, student_response)
#             print(f"Assessment service assess{assessment_result=}")
#
#             raw_output = {
#                 "source": assessment_result.source,  # "llm", "rule_based", "hybrid"
#                 "confidence": assessment_result.confidence,
#                 "raw_response": assessment_result.raw_response,  # полный ответ от LLM
#                 "processing_time": assessment_result.processing_time,
#                 "model_version": assessment_result.model_version,
#                 "metadata": assessment_result.metadata,
#                 "timestamp": timezone.now().isoformat()
#             }
#
#             assessment = Assessment.objects.create(
#                 task_response=student_response,
#                 score=assessment_result.score,
#                 is_correct=assessment_result.is_correct,
#                 error_tags=assessment_result.error_tags,
#                 feedback=assessment_result.feedback,
#                 raw_output=raw_output,  # ПОЛНЫЕ СЫРЫЕ ДАННЫЕ
#                 llm_version=assessment_result.model_version or "auto"
#             )
#
#             return assessment
#
#         except Exception as e:
#             logger.error(f"Assessment failed for task {task.id}, response {student_response.id}: {str(e)}")
#             return self._create_error_assessment(
#                 task=task,
#                 response=student_response,
#                 error=str(e),
#                 exception_type=type(e).__name__
#             )
#
#     def _create_error_assessment(
#             self,
#             task: Task,
#             response: StudentTaskResponse,
#             error: str,
#             exception_type: str = None
#     ) -> Assessment:
#         """
#         Создает Assessment с информацией об ошибке, но НЕ прерывает учебный процесс
#         """
#         logger.error(f"Assessment error for task {task.id}: {error}")
#
#         # Формируем детальное raw_output для ошибки
#         raw_output = {
#             "error": error,
#             "exception_type": exception_type,
#             "task_id": task.id,
#             "response_id": response.id,
#             "timestamp": timezone.now().isoformat(),
#             "retry_count": getattr(response, 'retry_count', 0) + 1
#         }
#
#         # Создаем Assessment с пометкой об ошибке
#         assessment = Assessment.objects.create(
#             task_response=response,
#             score=0.5,  # Нейтральное значение вместо 0.0
#             is_correct=None,  # Не определено из-за ошибки
#             error_tags=["processing_error", exception_type.lower() if exception_type else "unknown"],
#             feedback={
#                 "error": f"Ошибка при автоматической оценке: {error}",
#                 "message": "Ваш ответ был сохранен и будет проверен преподавателем вручную.",
#                 "note": "Это не повлияет на ваш прогресс в обучении."
#             },
#             raw_output=raw_output,
#             llm_version="error-handler"
#         )
#
#         # Отправляем уведомление администратору
#         self._notify_admin_about_assessment_error(task, response, error)
#
#         return assessment
#
#     def _notify_admin_about_assessment_error(self, task, response, error):
#         """Отправка уведомления администратору об ошибке"""
#         try:
#             # В реальной системе здесь будет отправка email
#             admin_email = "admin@edu-platform.com"
#             subject = f"Ошибка оценки задания #{task.id}"
#             message = f"""
#             Произошла ошибка при автоматической оценке ответа студента:
#             - Задание: {task.id}
#             - Студент: {response.student.id}
#             - Ошибка: {error}
#             - Ответ сохранен в БД: {response.id}
#             """
#             # TODO send_mail(admin_email, subject, message)  # Реальная отправка
#             logger.warning(f"Admin notification sent about error: {error}")
#         except Exception as notify_error:
#             logger.error(f"Failed to notify admin: {str(notify_error)}")


import logging
from django.utils import timezone
from curriculum.application.ports.assessment_port import AssessmentPort
from curriculum.infrastructure.adapters.auto_assessment_adapter import AutoAssessorAdapter
from curriculum.infrastructure.adapters.llm_assessment_adapter import LLMAssessmentAdapter
from curriculum.models.assessment.assessment import Assessment
from curriculum.models.assessment.student_response import StudentTaskResponse
from curriculum.models.content.task import Task, ResponseFormat

logger = logging.getLogger(__name__)


class AssessmentService:
    """
    AssessmentService координирует процесс оценки ответа студента.

    Он:
    - выбирает стратегию оценки на основе типа задания
    - сохраняет результаты в формате, соответствующем модели Assessment
    - обрабатывает ошибки без прерывания учебного процесса

    Архитектурные принципы:
    1. Соответствие модели: сохраняет данные в формате structured_feedback
    2. Полиморфизм: выбирает адаптер в зависимости от типа задания
    3. Отказоустойчивость: обработка ошибок с созданием заглушки
    4. Аудит: сохранение полных сырых данных в raw_output
    """

    def __init__(
            self,
            auto_adapter: AutoAssessorAdapter,
            llm_adapter: LLMAssessmentAdapter
    ):
        """
        Инициализация сервиса с двумя адаптерами для разных типов заданий

        Args:
            auto_adapter: Для закрытых заданий (MCQ, short text)
            llm_adapter: Для открытых заданий (writing, speaking)
        """
        self.auto_adapter = auto_adapter
        self.llm_adapter = llm_adapter

    def assess(self, student_response: StudentTaskResponse) -> Assessment:
        """
        Основной метод оценки ответа.

        Выбирает стратегию оценки на основе формата задания:
        - Закрытые форматы (SINGLE_CHOICE, MULTIPLE_CHOICE, SHORT_TEXT) → auto_adapter
        - Открытые форматы (FREE_TEXT, AUDIO) → llm_adapter

        Возвращает Assessment с данными в правильном формате.
        """
        task = student_response.task

        try:
            # Выбор адаптера в зависимости от формата задания
            adapter = self._select_adapter(task)

            # Получение результата оценки
            assessment_result = adapter.assess_task(task, student_response)

            # Формирование raw_output для аудита
            raw_output = {
                "source": assessment_result.source,
                "confidence": assessment_result.confidence,
                "raw_response": assessment_result.raw_response,
                "processing_time": assessment_result.get("processing_time", 0),
                "model_version": assessment_result.get("model_version", "unknown"),
                "metadata": assessment_result.get("metadata", {}),
                "timestamp": timezone.now().isoformat()
            }

            # Формирование structured_feedback в формате модели
            structured_feedback = self._build_structured_feedback(assessment_result, task)

            # Создание Assessment
            assessment = Assessment.objects.create(
                task_response=student_response,
                llm_version=assessment_result.get("model_version", "auto"),
                raw_output=raw_output,
                structured_feedback=structured_feedback
            )

            logger.info(
                f"Assessment created successfully: {assessment.id}, "
                f"task: {task.id}, source: {assessment_result.get('source')}"
            )

            return assessment

        except Exception as e:
            logger.error(
                f"Assessment failed for task {task.id}, response {student_response.id}: {str(e)}",
                exc_info=True
            )
            return self._create_error_assessment(
                task=task,
                response=student_response,
                error=str(e),
                exception_type=type(e).__name__
            )

    def _select_adapter(self, task: Task) -> AssessmentPort:
        """
        Выбирает адаптер для оценки в зависимости от формата задания

        Returns:
            AssessmentPort: Выбранный адаптер
        """
        # Для закрытых форматов используем auto_adapter
        if task.response_format in [
            ResponseFormat.SINGLE_CHOICE,
            ResponseFormat.MULTIPLE_CHOICE,
            ResponseFormat.SHORT_TEXT
        ]:
            return self.auto_adapter

        # Для открытых форматов используем llm_adapter
        return self.llm_adapter

    def _build_structured_feedback(self, assessment_result: dict, task: Task) -> dict:
        """
        Формирует structured_feedback в формате, ожидаемом моделью Assessment

        Формат structured_feedback:
        {
          "score_grammar": 0.7,
          "score_vocabulary": 0.85,
          "errors": [{"type": "tense", "example": "I have went", "correction": "I went"}],
          "strengths": ["clear structure", "good IT vocabulary"],
          "suggestions": ["review past tenses"]
        }

        Args:
            assessment_result: Результат от адаптера
            task: Задание для контекста

        Returns:
            dict: structured_feedback в правильном формате
        """
        feedback = assessment_result.get("feedback", {})

        # Базовая структура
        structured = {
            "score_grammar": 0.5,
            "score_vocabulary": 0.5,
            "errors": [],
            "strengths": [],
            "suggestions": []
        }

        # Обработка результатов в зависимости от типа задания
        if task.task_type == "grammar":
            structured["score_grammar"] = assessment_result.get("score", 0.5)
            if assessment_result.get("is_correct") is False:
                structured["errors"] = [{"type": "grammar", "example": "", "correction": ""}]

        elif task.task_type == "vocabulary":
            structured["score_vocabulary"] = assessment_result.get("score", 0.5)
            if assessment_result.get("is_correct") is False:
                structured["errors"] = [{"type": "vocabulary", "example": "", "correction": ""}]

        # Для открытых форматов используем детальную обратную связь
        elif task.response_format in [ResponseFormat.FREE_TEXT, ResponseFormat.AUDIO]:
            # Извлекаем оценки по навыкам
            skills_scores = assessment_result.get("skills_scores", {})
            structured["score_grammar"] = skills_scores.get("grammar", 0.5)
            structured["score_vocabulary"] = skills_scores.get("vocabulary", 0.5)

            # Обработка ошибок
            error_tags = assessment_result.get("error_tags", [])
            for error_tag in error_tags:
                structured["errors"].append({
                    "type": error_tag,
                    "example": feedback.get("example", ""),
                    "correction": feedback.get("correction", "")
                })

            # Добавляем сильные стороны и предложения
            structured["strengths"] = feedback.get("strengths", [])
            structured["suggestions"] = feedback.get("suggestions", [])

        # Добавляем общий score в metadata для совместимости
        structured["metadata"] = {
            "overall_score": assessment_result.get("score", 0.5),
            "confidence": assessment_result.get("confidence", 0.8),
            "is_correct": assessment_result.get("is_correct")
        }

        return structured

    def _create_error_assessment(
            self,
            task: Task,
            response: StudentTaskResponse,
            error: str,
            exception_type: str = None
    ) -> Assessment:
        """
        Создает Assessment с информацией об ошибке.

        Возвращает Assessment с заглушкой в формате модели.
        """
        logger.error(f"Assessment error for task {task.id}: {error}")

        # Формируем raw_output для ошибки
        raw_output = {
            "error": error,
            "exception_type": exception_type,
            "task_id": task.id,
            "response_id": response.id,
            "timestamp": timezone.now().isoformat(),
            "retry_count": getattr(response, 'retry_count', 0) + 1
        }

        # Создаем structured_feedback в правильном формате
        structured_feedback = {
            "score_grammar": 0.5,
            "score_vocabulary": 0.5,
            "errors": [{
                "type": "processing_error",
                "example": error,
                "correction": "Будет проверено преподавателем"
            }],
            "strengths": [],
            "suggestions": ["Ваш ответ был сохранен и будет проверен вручную"],
            "metadata": {
                "overall_score": 0.5,
                "confidence": 0.3,
                "is_correct": None,
                "error_type": exception_type or "unknown"
            }
        }

        assessment = Assessment.objects.create(
            task_response=response,
            llm_version="error-handler",
            raw_output=raw_output,
            structured_feedback=structured_feedback
        )

        # Отправляем уведомление администратору (асинхронно в продакшене)
        self._notify_admin_about_assessment_error(task, response, error)

        return assessment

    def _notify_admin_about_assessment_error(self, task, response, error):
        """Отправка уведомления администратору об ошибке"""
        try:
            # В реальной системе здесь будет отправка email/уведомления
            logger.warning(
                f"Admin notification about assessment error - "
                f"task: {task.id}, student: {response.student.id}, error: {error}"
            )
        except Exception as notify_error:
            logger.error(f"Failed to notify admin: {str(notify_error)}")

#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\decisions\adaptive_decision.py
class AdaptiveDecision:
    """
    Структурированное решение системы.
    """

    def __init__(self, outcome, confidence, reasons):
        self.outcome = outcome
        self.confidence = confidence
        self.reasons = reasons


class AdaptiveDecisionEngine:
    """
    Принимает решение по уроку на основе метрик.
    """

    def decide(self, metrics) -> AdaptiveDecision:
        if metrics.failure_streak >= 3:
            return AdaptiveDecision(
                outcome="SIMPLIFY",
                confidence=0.85,
                reasons=["Высокая серия неудач"]
            )

        if metrics.success_ratio > 0.9:
            return AdaptiveDecision(
                outcome="ADVANCE",
                confidence=0.92,
                reasons=["Высокая успешность"]
            )

        return AdaptiveDecision(
            outcome="REPEAT",
            confidence=0.6,
            reasons=["Недостаточная устойчивость"]
        )


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\decisions\decision_service.py
from dataclasses import dataclass
from typing import Dict, Any, Optional

from curriculum.models.student.enrollment import Enrollment
from curriculum.models.content.lesson import Lesson
from curriculum.models.governance.teacher_override import TeacherOverride
from curriculum.services.skills.skill_update_service import SkillUpdateResult

"""
Пример решения

Вход
{
  "updated_skills": {
    "grammar": 0.42
  },
  "deltas": {
    "grammar": -0.1
  }
}
Выход

{
  "code": "ADVANCE_TASK",
  "confidence": 0.6,
  "rationale": {
    "reason": "default_progression"
  }
}
"""


@dataclass
class Decision:
    """
    Value object, описывающий принятое решение.
    """

    code: str
    confidence: float
    rationale: Dict[str, Any]


class DecisionService:
    """
    DecisionService интерпретирует состояние обучения
    и принимает решение о следующем шаге.

    TODO (DecisionService):

    1. Weighting decisions by ProfessionalTag
    2. LearningObjective-aware completion logic
    3. Probabilistic decision model
    4. Confidence calibration
    5. Decision simulation / replay
    """

    def decide(
        self,
        enrollment: Enrollment,
        lesson: Lesson,
        skill_profile_update: SkillUpdateResult,
    ) -> Decision:
        """
        Основной метод принятия решения.

        Алгоритм (v1):
        1. Проверка TeacherOverride
        2. Проверка completion урока
        3. Анализ skill deltas
        """

        # 1️⃣ Teacher override — абсолютный приоритет
        override = self._get_active_teacher_override(enrollment)
        if override:
            return Decision(
                code=override.decision_code,
                confidence=1.0,
                rationale={
                    "source": "teacher_override",
                    "override_id": override.id,
                },
            )

        # 2️⃣ Проверка завершения урока
        if self._lesson_completed(lesson, skill_profile_update):
            return Decision(
                code="ADVANCE_LESSON",
                confidence=0.8,
                rationale={
                    "reason": "lesson_completed",
                    "skills": skill_profile_update.updated_skills,
                },
            )

        # 3️⃣ Анализ ухудшения навыков
        if self._significant_skill_drop(skill_profile_update):
            return Decision(
                code="REPEAT_LESSON",
                confidence=0.7,
                rationale={
                    "reason": "skill_regression",
                    "deltas": skill_profile_update.deltas,
                },
            )

        # 4️⃣ По умолчанию — двигаемся дальше по заданиям
        return Decision(
            code="ADVANCE_TASK",
            confidence=0.6,
            rationale={
                "reason": "default_progression",
            },
        )

    # ------------------------------------------------------------------
    # Internal helpers
    # ------------------------------------------------------------------

    def _get_active_teacher_override(
        self,
        enrollment: Enrollment
    ) -> Optional[TeacherOverride]:
        """
        Возвращает активный teacher override, если есть.
        """

        return (
            TeacherOverride.objects
            .filter(
                enrollment=enrollment,
                is_active=True
            )
            .order_by("-created_at")
            .first()
        )

    def _lesson_completed(
        self,
        lesson: Lesson,
        skill_update: SkillUpdateResult
    ) -> bool:
        """
        Проверяет, можно ли считать урок завершённым.

        ⚠️ v1: эвристика
        """

        # Используем skill_focus урока, если он есть
        if hasattr(lesson, "skill_focus") and lesson.skill_focus:
            for skill in lesson.skill_focus:
                if skill_update.updated_skills.get(skill, 0) < 0.6:
                    return False
            return True

        # Fallback: если нет явного фокуса
        return True

    def _significant_skill_drop(
        self,
        skill_update: SkillUpdateResult
    ) -> bool:
        """
        Проверяет, есть ли существенная деградация навыков.
        """

        for delta in skill_update.deltas.values():
            if delta < -0.2:
                return True
        return False


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\explainability\admin_explainer.py
from typing import Dict, Any

from curriculum.models.skills.skill_trajectory import SkillTrajectory
from curriculum.models.student.enrollment import Enrollment
from curriculum.services.explainability.explainability_engine import ExplainabilityEngine


class AdminExplainabilityService:
    """
    Сервис объяснимости для преподавателя / администратора.

    Назначение:
    - агрегирует explainability данные в одном месте
    - не содержит HTTP логики
    - не сериализует данные
    - используется в views и (позже) background reports
    """

    def build_for_student(self, student) -> Dict[str, Any]:
        """
        Собирает полный explainability-контекст по студенту.

        Используется:
        - админка
        - teacher dashboard
        - audit logs
        """

        enrollment = Enrollment.objects.filter(
            student=student,
            is_active=True
        ).select_related(
            "course", "current_lesson"
        ).first()

        if not enrollment:
            return {
                "error": "Student is not enrolled in any active course"
            }

        # Последний outcome урока (результат адаптации)
        last_outcome = enrollment.last_lesson_outcome

        explanation = ExplainabilityEngine().explain_lesson_outcome(
            student=student,
            outcome=last_outcome
        )

        trajectories = SkillTrajectory.objects.filter(
            student=student
        )

        return {
            "student": student,
            "course": enrollment.course,
            "current_lesson": enrollment.current_lesson,
            "last_outcome": last_outcome,
            "explanation": explanation,
            "skill_trajectories": trajectories,
        }


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\explainability\explainability_engine.py
from curriculum.models.skills.skill_trajectory import SkillTrajectory


class ExplainabilityEngine:
    """
    Интерпретирует SkillTrajectory и объясняет решения системы.

  - читает SkillTrajectory
    - объясняет решения AdaptiveDecisionEngine
    - возвращает структурированные причины
    - НЕ принимает решений
    - НЕ изменяет данные
    - Только объясняет.

    SkillSnapshot
    ↓
    SkillTrajectory
    ↓
    ExplainabilityEngine   ← ТЫ ЗДЕСЬ
    ↓
    AdaptiveDecisionEngine
    ↓
    FeedbackBuilder / UI / Logs
    ↓
    ToneAdapter
    ↓
    YAML template
    ↓
    User message

    пример выдачи
    {
        "decision": "SIMPLIFY",
        "primary_reason": "Обнаружено снижение навыков: grammar, listening",
        "supporting_factors": [
            {
                  "type": "decline",
                  "skills": ["grammar", "listening"]
            },
            {
                  "type": "instability",
                  "skills": ["speaking"]
            }
        ],
        "skill_insights": [
            {"skill": "grammar", "direction": "declining"},
            {"skill": "listening", "direction": "declining"},
            {"skill": "speaking", "direction": "stable"}
        ],
        "confidence": 0.81
    }
    """

    def explain_lesson_outcome(self, student, outcome):
        """Формирует полное объяснение принятого решения на основе траекторий навыков."""

        trajectories = SkillTrajectory.objects.filter(student=student)

        skill_insights = []
        unstable_skills = []
        declining_skills = []

        for traj in trajectories:
            insight = self._analyze_skill(traj)
            skill_insights.append(insight)

            if insight["trend"] < -0.1:
                declining_skills.append(traj.skill)

            if insight["stability"] < 0.4:
                unstable_skills.append(traj.skill)

        explanation = {
            "decision": outcome,
            "primary_reason": self._primary_reason(outcome, declining_skills, unstable_skills),
            "supporting_factors": self._supporting_factors(declining_skills, unstable_skills),
            "skill_insights": skill_insights,
            "confidence": self._explanation_confidence(skill_insights),
        }

        return explanation

    def _analyze_skill(self, trajectory):
        """
        Переводит числовые параметры навыка в человекочитаемое состояние.
        """

        if trajectory.trend > 0.15:
            direction = "improving"
        elif trajectory.trend < -0.15:
            direction = "declining"
        else:
            direction = "stable"

        return {
            "skill": trajectory.skill,
            "trend": trajectory.trend,
            "stability": trajectory.stability,
            "direction": direction,
        }

    def _primary_reason(self, outcome, declining, unstable):
        """Определяет главную причину решения.

        """
        if outcome == "SIMPLIFY" and declining:
            return f"Обнаружено снижение навыков: {', '.join(declining)}"

        if outcome == "REPEAT" and unstable:
            return f"Навыки нестабильны: {', '.join(unstable)}"

        if outcome == "ADVANCE":
            return "Навыки растут стабильно"

        return "Недостаточно данных для чёткого вывода"

    def _supporting_factors(self, declining, unstable):
        """Добавляет вторичные факторы, подтверждающие решение."""
        factors = []

        if declining:
            factors.append({
                "type": "decline",
                "skills": declining
            })

        if unstable:
            factors.append({
                "type": "instability",
                "skills": unstable
            })

        return factors

    def _explanation_confidence(self, insights):
        """
        Оценивает, насколько можно доверять объяснению.
        Текущая логика
        средняя stability по навыкам
        0.0 → мало данных
        1.0 → стабильная картина
                """
        if not insights:
            return 0.0

        avg_stability = sum(i["stability"] for i in insights) / len(insights)
        return round(avg_stability, 2)




#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\explainability\explainability_service.py
from curriculum.models.progress.lesson_transition import LessonTransition
from curriculum.services.explainability.admin_explainer import AdminExplainabilityService
from curriculum.services.explainability.lesson_explainer import LessonExplainer
from curriculum.services.feedback.student_explanation_builder import StudentExplanationBuilder


class ExplainabilityService:
    def __init__(
            self,
            lesson_explainer: LessonExplainer,
            admin_explainer: AdminExplainabilityService,
            student_explainer: StudentExplanationBuilder
    ):
        self.lesson_explainer = lesson_explainer
        self.admin_explainer = admin_explainer
        self.student_explainer = student_explainer

    def explain_for_admin(self, transition_id):
        transition = LessonTransition.objects.get(id=transition_id)
        return self.lesson_explainer.explain(transition)

    def explain_for_student(self, transition_id, tone_strategy):
        transition = LessonTransition.objects.get(id=transition_id)
        metrics = self._extract_metrics(transition)
        decision = self._get_decision(transition)
        return self.student_explainer.build(decision, metrics, tone_strategy)

#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\explainability\lesson_explainer.py
from curriculum.models.assessment.assessment import Assessment
from curriculum.models.content.lesson import Lesson
from curriculum.models.progress.lesson_transition import LessonTransition
from curriculum.models.skills.skill_snapshot import SkillSnapshot


class LessonExplainer:
    """
    LessonExplainer формирует объяснение transition.
    """

    def explain(
        self,
        transition: LessonTransition
    ) -> dict:
        """
        Основной метод объяснения.
        """

        assessment: Assessment = transition.assessment
        snapshot: SkillSnapshot | None = transition.skill_snapshot
        lesson: Lesson = transition.from_lesson

        objectives = [
            obj.identifier
            for obj in lesson.learning_objectives.all()
        ]

        professional_context = [
            tag.name
            for task in lesson.tasks.all()
            for tag in task.professional_tags.all()
        ]

        skill_changes = snapshot.to_dict()

        return {
            "lesson_id": lesson.pk,
            "decision_code": transition.decision_code,
            "objectives": objectives,
            "professional_context": professional_context,
            "skill_changes": skill_changes if skill_changes else {},
            "assessment_summary": assessment.structured_feedback,
        }


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\feedback\feedback_builder.py
import random

from curriculum.services.feedback.template_loader import FeedbackTemplateLoader


class FeedbackBuilder:
    """
    Формирует мотивационную и объясняющую обратную связь для студента
    на основе результатов урока и принятого решения.

    Использует:
    - решение адаптивного движка (LessonOutcome)
    - метрики урока (LessonMetrics)
    - тон общения (ToneAdapter)

    Не влияет на логику обучения.

    {
      "title": "Хорошая работа!",
      "message": "Ты уверенно справился с заданием и можешь двигаться дальше.",
      "highlights": [
        "Грамматика: стабильно",
        "Словарный запас: выше среднего"
      ],
      "next_step_hint": "Следующий урок будет чуть сложнее."
    }

    📍 Это оперативная обратная связь, а не объяснение логики.
    Он отвечает на вопрос студента:
    «Как я справился и что дальше?»
    ❗ Он НЕ отвечает:
    почему система приняла именно это решение
    почему урок упростился / повторился
    что это значит в долгосрочном плане
    """

    def __init__(self):
        self.templates = FeedbackTemplateLoader()

    def _build(self, template_name, tone, highlights):
        tpl = self.templates.load(template_name)

        return {
            "title": tpl["title"],
            "message": f"{tone} {random.choice(tpl['messages'])}",
            "highlights": highlights,
            "next_step_hint": random.choice(tpl["next_step"]),
        }

    def _success_feedback(self, tone, metrics):
        return self._build(
            template_name="success",
            tone=tone.praise(),
            highlights=metrics.top_skills(),
        )

    def _supportive_feedback(self, tone, metrics):
        return self._build(
            template_name="simplify",
            tone=tone.support(),
            highlights=metrics.weak_spots(limit=2),
        )

    def _retry_feedback(self, tone, metrics):
        return self._build(
            template_name="retry",
            tone=tone.retry(),
            highlights=metrics.weak_spots(limit=1),
        )

    def _neutral_feedback(self, tone):
        return self._build(
            template_name="neutral",
            tone=tone.neutral(),
            highlights=[],
        )


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\feedback\student_explanation_builder.py
class StudentExplanationBuilder:
    """
    Формирует упрощённое, мотивирующее объяснение
    решений системы для студента.

    Назначение
        объяснить почему следующий шаг такой
        формирует доверие
        снижает тревожность
        подготавливает ожидания

    Содержит
        explanation (1–2 предложения)
        expectation (что будет дальше)
        reassurance (опционально)

    НЕ содержит
        highlights
        оценок
        сравнений навыков
    """

    def build(self, decision, metrics, tone):
        """
        decision: AdaptiveDecision
        metrics: LessonMetrics
        tone: ToneStrategy
        """

        if decision.outcome == "ADVANCE":
            return self._advance_explanation(tone)

        if decision.outcome == "REPEAT":
            return self._repeat_explanation(tone)

        if decision.outcome == "SIMPLIFY":
            return self._simplify_explanation(tone)

        return self._neutral_explanation(tone)

    def _advance_explanation(self, tone):
        return {
            "title": "Отличная работа 🚀",
            "message": tone.praise(),
            "explanation": (
                "Ты уверенно справляешься с этим материалом, "
                "поэтому мы идём дальше."
            ),
            "expectation": "В следующем уроке будет чуть больше вызова."
        }

    def _repeat_explanation(self, tone):
        return {
            "title": "Давай закрепим 💪",
            "message": tone.retry(),
            "explanation": (
                "Этот материал почти освоен. "
                "Повторим его ещё раз с новыми примерами."
            ),
            "expectation": "После этого станет заметно легче."
        }

    def _simplify_explanation(self, tone):
        return {
            "title": "Ничего страшного 🙂",
            "message": tone.support(),
            "explanation": (
                "Мы немного упростим следующий шаг, "
                "чтобы ты чувствовал себя увереннее."
            ),
            "expectation": "Ты быстро вернёшься к более сложным заданиям."
        }

    def _neutral_explanation(self, tone):
        return {
            "title": "Продолжаем",
            "message": tone.neutral(),
            "explanation": "Идём дальше шаг за шагом.",
            "expectation": None
        }


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\feedback\template_loader.py
import yaml
from pathlib import Path


class FeedbackTemplateLoader:
    """
    Загружает и кэширует YAML-шаблоны обратной связи.
    """

    BASE_PATH = Path(__file__).resolve().parent / "templates"

    def load(self, name: str) -> dict:
        path = self.BASE_PATH / f"{name}.yaml"
        if not path.exists():
            raise FileNotFoundError(f"Feedback template not found: {name}")

        with open(path, "r", encoding="utf-8") as f:
            return yaml.safe_load(f)


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\feedback\templates\neutral.yaml
title: "Продолжаем"
messages:
  - "Идём дальше шаг за шагом."
next_step:
  - "Продолжаем обучение."


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\feedback\templates\retry.yaml
title: "Давай закрепим"
messages:
  - "Повтор поможет лучше понять материал."
  - "Это нормально — не всё получается сразу."
  - "Иногда нужно чуть больше практики."
next_step:
  - "Повторим этот урок с новыми примерами."


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\feedback\templates\simplify.yaml
title: "Ничего страшного"
messages:
  - "Ошибки — это часть обучения."
  - "Мы сделаем следующий шаг чуть легче."
next_step:
  - "Закрепим основу перед усложнением."


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\feedback\templates\student_simplify.yaml
title: "Ничего страшного 🙂"

explanations:
  - "Мы немного упростим следующий шаг, чтобы тебе было комфортнее."
  - "Иногда полезно сделать шаг назад, чтобы потом идти быстрее."

expectations:
  - "Это поможет почувствовать уверенность."
  - "Ты быстро вернёшься к более сложным заданиям."


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\feedback\templates\success.yaml
title: "Отлично!"
messages:
  - "Ты уверенно справился с этим уроком."
  - "Отличный прогресс, продолжаем!"
next_step:
  - "Переходим к более сложным заданиям."


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\feedback\tones\base.py
class BaseTone:
    """
    Базовый интерфейс эмоционального тона.
    """

    def praise(self) -> str:
        raise NotImplementedError

    def support(self) -> str:
        raise NotImplementedError

    def retry(self) -> str:
        raise NotImplementedError

    def neutral(self) -> str:
        return "Продолжаем обучение."


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\feedback\tones\confident.py
from .base import BaseTone


class ConfidentTone(BaseTone):
    """
    Уверенный, энергичный тон для сильных студентов.
    """

    def praise(self):
        return "Отличный результат! Ты уверенно движешься вперёд."

    def support(self):
        return "Чуть сложнее, но тебе это по силам."

    def retry(self):
        return "Небольшая пауза и закрепление — и пойдём дальше."


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\feedback\tones\gentle.py
from .base import BaseTone


class GentleTone(BaseTone):
    """
    Мягкий, поддерживающий тон для студентов
    с серией неудач или низкой уверенностью.
    """

    def praise(self):
        return "Ты стараешься, и это видно. Отличная работа."

    def support(self):
        return "Ошибки — часть обучения. Давай разберёмся спокойно."

    def retry(self):
        return "Ничего страшного. Повтор поможет закрепить материал."


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\feedback\tones\neutral.py
from .base import BaseTone


class NeutralTone(BaseTone):
    """
    Нейтральный, спокойный тон по умолчанию.
    """

    def praise(self):
        return "Хорошая работа."

    def support(self):
        return "Давай продолжим шаг за шагом."

    def retry(self):
        return "Повторим материал для закрепления."


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\governance\teacher_override_service.py
from curriculum.models.governance.teacher_override import TeacherOverride


class TeacherOverrideService:
    """
    Управляет переопределениями преподавателя.
    """

    def apply_override(
        self,
        teacher,
        student,
        lesson,
        system_decision,
        overridden_decision,
        reason: str
    ) -> TeacherOverride:
        """
        Фиксирует override и возвращает его.
        """

        return TeacherOverride.objects.create(
            teacher=teacher,
            student=student,
            lesson=lesson,
            original_decision=system_decision.outcome,
            overridden_decision=overridden_decision,
            reason=reason
        )


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\progression\progression_service.py
from dataclasses import dataclass
from typing import Optional

from curriculum.models.student.enrollment import Enrollment
from curriculum.services.curriculum_query import CurriculumQueryService
from curriculum.services.decisions.decision_service import Decision


@dataclass
class ProgressionResult:
    """
    Результат применения решения к Enrollment.

    Используется:
    - LearningService
    - Orchestrator
    """

    next_action: str
    next_task_id: Optional[int] = None
    next_lesson_id: Optional[int] = None


class ProgressionService:
    """
    ProgressionService применяет решение к состоянию Enrollment.

    Он:
    - НЕ принимает решений
    - НЕ анализирует данные
    - только обновляет состояние

    TODO (ProgressionService):

    1. Поддержка branching lessons
    2. Partial lesson completion
    3. Rollback progression (teacher override)
    4. Soft reset vs hard reset lesson
    """

    def __init__(
        self,
        curriculum_query: CurriculumQueryService | None = None,
    ):
        self.curriculum_query = curriculum_query or CurriculumQueryService()

    def apply_decision(
        self,
        enrollment: Enrollment,
        decision: Decision,
    ) -> ProgressionResult:
        """
        Применяет decision к Enrollment.

        Возможные сценарии:
        - ADVANCE_TASK
        - ADVANCE_LESSON
        - REPEAT_TASK
        - REPEAT_LESSON
        - STOP
        """

        if decision.code == "ADVANCE_TASK":
            return self._advance_task(enrollment)

        if decision.code == "ADVANCE_LESSON":
            return self._advance_lesson(enrollment)

        if decision.code == "REPEAT_TASK":
            return self._repeat_task(enrollment)

        if decision.code == "REPEAT_LESSON":
            return self._repeat_lesson(enrollment)

        if decision.code == "STOP":
            return ProgressionResult(
                next_action="STOP"
            )

        raise ValueError(f"Unknown decision code: {decision.code}")

    # ------------------------------------------------------------------
    # Decision handlers
    # ------------------------------------------------------------------

    def _advance_task(self, enrollment: Enrollment) -> ProgressionResult:
        """
        Переход к следующему заданию в рамках текущего урока.
        """

        next_task = self.curriculum_query.get_next_task(enrollment)

        if not next_task:
            # Задания закончились → пусть decision engine решает дальше
            return ProgressionResult(
                next_action="NO_MORE_TASKS"
            )

        enrollment.current_task = next_task
        enrollment.save(update_fields=["current_task"])

        return ProgressionResult(
            next_action="NEXT_TASK",
            next_task_id=next_task.pk,
        )

    def _advance_lesson(self, enrollment: Enrollment) -> ProgressionResult:
        """
        Переход к следующему уроку курса.
        """

        current_lesson = enrollment.current_lesson

        next_lesson = (
            current_lesson.course.lessons
            .filter(order__gt=current_lesson.order, is_active=True)
            .order_by("order")
            .first()
        )

        if not next_lesson:
            enrollment.is_completed = True
            enrollment.save(update_fields=["is_completed"])

            return ProgressionResult(
                next_action="COURSE_COMPLETED"
            )

        # Сбрасываем task при переходе урока
        enrollment.current_lesson = next_lesson
        enrollment.current_task = None
        enrollment.save(update_fields=["current_lesson", "current_task"])

        first_task = self.curriculum_query.get_first_task(next_lesson)

        return ProgressionResult(
            next_action="NEXT_LESSON",
            next_lesson_id=next_lesson.id,
            next_task_id=first_task.pk if first_task else None,
        )

    def _repeat_task(self, enrollment: Enrollment) -> ProgressionResult:
        """
        Повтор текущего задания.
        """

        return ProgressionResult(
            next_action="RETRY_TASK",
            next_task_id=enrollment.current_task.pk,
        )

    def _repeat_lesson(self, enrollment: Enrollment) -> ProgressionResult:
        """
        Повтор текущего урока (сброс task).
        """

        enrollment.current_task = None
        enrollment.save(update_fields=["current_task"])

        first_task = self.curriculum_query.get_first_task(
            enrollment.current_lesson
        )

        return ProgressionResult(
            next_action="RESTART_LESSON",
            next_task_id=first_task.pk if first_task else None,
        )


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\progression\transition_recorder.py
from typing import Optional

from curriculum.models.governance.teacher_override import TeacherOverride
from curriculum.models.assessment.assessment import Assessment
from curriculum.models.progress.lesson_transition import LessonTransition
from curriculum.models.skills.skill_snapshot import SkillSnapshot
from curriculum.models.student.enrollment import Enrollment
from curriculum.models.content.task import Task

from curriculum.services.decisions.decision_service import Decision


class TransitionRecorder:
    """
    TransitionRecorder фиксирует факт принятия решения и его основания.

    Он НЕ:
    - принимает решения
    - изменяет progression
    - интерпретирует результаты

    Он:
    - записывает transition как audit-log

    Он записывает:
        ЧТО произошло (какое решение)
        КОГДА
        В КАКОМ КОНТЕКСТЕ
        НА ОСНОВАНИИ ЧЕГО (assessment, skills, overrides)

    TODO (TransitionRecorder):

    1. Поддержка multi-decision transitions (compound decisions)
    2. Версионирование decision engine
    3. Явное хранение metrics snapshot
    4. Поддержка rollback / correction transitions
    """

    def record(
        self,
        enrollment: Enrollment,
        task: Task,
        decision: Decision,
        assessment_result: Assessment,
        skill_update_result: Optional[SkillSnapshot] = None,
    ) -> LessonTransition:
        """
        Записывает LessonTransition.

        Параметры:
        - enrollment: текущее зачисление студента
        - task: задание, на котором было принято решение
        - decision: принятое решение (ADVANCE / REPEAT / etc)
        - assessment_result: результат оценки
        - skill_update_result: snapshot навыков после обновления
        """

        from_lesson = enrollment.current_lesson

        # Пытаемся определить целевой урок
        to_lesson = None
        if decision.code == "ADVANCE_LESSON":
            to_lesson = enrollment.current_lesson
        elif decision.code == "REPEAT_LESSON":
            to_lesson = enrollment.current_lesson
        else:
            # для task-level решений урок не меняется
            to_lesson = enrollment.current_lesson

        # Проверяем, был ли teacher override
        teacher_override = (
            TeacherOverride.objects
            .filter(
                enrollment=enrollment,
                is_active=True
            )
            .order_by("-created_at")
            .first()
        )

        transition = LessonTransition.objects.create(
            enrollment=enrollment,
            from_lesson=from_lesson,
            to_lesson=to_lesson,
            task=task,
            decision_code=decision.code,
            assessment=assessment_result,
            skill_snapshot=skill_update_result,
            teacher_override=teacher_override,
        )

        return transition


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\skills\skill_delta_calculator.py
from typing import Dict, Optional

from curriculum.models.assessment.assessment import Assessment
from curriculum.models.content.task import Task
from curriculum.models.skills.skill_trajectory import SkillTrajectory
from curriculum.models.student.enrollment import Enrollment


class SkillDeltaCalculator:
    """
    Рассчитывает изменения навыков (skill deltas)
    на основе Assessment и контекста обучения.

    v2:
    - skill-specific scores
    - baseline policy
    - stability-aware damping
    """

    BASELINE_DEFAULT = 0.6
    MAX_DELTA = 0.1

    SKILL_SCORE_MAP = {
        "grammar": "score_grammar",
        "vocabulary": "score_vocabulary",
        "listening": "score_listening",
        "reading": "score_reading",
        "writing": "score_writing",
        "speaking": "score_speaking",
    }

    def calculate(
            self,
            *,
            assessment: Assessment,
            task: Task,
            enrollment: Enrollment,
    ) -> Dict[str, float]:
        """
        Основной метод.

        Возвращает:
            skill_name → delta
        """

        deltas: Dict[str, float] = {}

        feedback = assessment.structured_feedback or {}

        for skill, score_key in self.SKILL_SCORE_MAP.items():
            score = feedback.get(score_key)
            if score is None:
                continue

            baseline = self._baseline_for_skill(
                task=task,
            )

            raw_delta = score - baseline

            stability = self._get_skill_stability(
                student=enrollment.student,
                skill=skill,
            )

            effective_delta = raw_delta * (1 - stability)

            delta = self._clamp(effective_delta)

            if delta != 0.0:
                deltas[skill] = delta

        return deltas

    def _baseline_for_skill(
            self,
            *,
            task: Task,
    ) -> float:
        """
        Policy-based baseline.

        v2 (простой вариант):
        - диагностические задания → ниже baseline
        - обычные → default
        """

        if getattr(task, "is_diagnostic", False):
            return 0.5

        return self.BASELINE_DEFAULT

    def _get_skill_stability(
            self,
            *,
            student,
            skill: str,
    ) -> float:
        """
        Возвращает stability навыка из SkillTrajectory.
        Если данных нет — считаем навык нестабильным.
        """

        try:
            trajectory = SkillTrajectory.objects.get(
                student=student,
                skill=skill
            )
            return trajectory.stability
        except SkillTrajectory.DoesNotExist:
            return 0.0

    def _clamp(self, value: float) -> float:
        """
        Ограничивает влияние одного задания.
        """

        if value > self.MAX_DELTA:
            return self.MAX_DELTA
        if value < -self.MAX_DELTA:
            return -self.MAX_DELTA
        return value


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\skills\skill_snapshot_creator.py
from curriculum.models.skills.skill_curent import CurrentSkill
from curriculum.models.skills.skill_snapshot import SkillSnapshot


class SkillSnapshotCreator:
    """
    Создаёт исторический snapshot навыков студента.
    """

    def create(self, student):
        skills = {
            cs.skill: cs.score
            for cs in CurrentSkill.objects.filter(student=student)
        }

        return SkillSnapshot.objects.create(
            student=student,
            grammar=skills.get("grammar", 0.0),
            vocabulary=skills.get("vocabulary", 0.0),
            listening=skills.get("listening", 0.0),
            reading=skills.get("reading", 0.0),
            writing=skills.get("writing", 0.0),
            speaking=skills.get("speaking", 0.0),
        )


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\skills\skill_trajectory_updater.py
from curriculum.models.skills.skill_snapshot import SkillSnapshot
from curriculum.models.skills.skill_trajectory import SkillTrajectory
from curriculum.services.skills.utils.trajectory_math import calculate_trend, calculate_stability


class SkillTrajectoryUpdater:
    """
    Обновляет SkillTrajectory на основе истории SkillSnapshot.

    Используется:
    - после завершения урока
    - после диагностики
    - периодически (batch)

    Task
    ↓
    StudentTaskResponse
    ↓
    Assessment
    ↓
    SkillStateUpdater        (CurrentSkill)
    ↓
    [Lesson completed]
    ↓
    SkillSnapshotCreator    (SkillSnapshot)
    ↓
    SkillTrajectoryUpdater  ← ВОТ ОН
    ↓
    AdaptiveDecisionEngine
    ↓
    LearningAgent
    """

    MIN_SNAPSHOTS = 3

    def update(self, student):
        snapshots = SkillSnapshot.objects.filter(
            student=student
        ).order_by("snapshot_at")

        if snapshots.count() < self.MIN_SNAPSHOTS:
            return  # недостаточно данных

        skill_values = {
            "grammar": [],
            "vocabulary": [],
            "listening": [],
            "reading": [],
            "writing": [],
            "speaking": [],
        }

        for snap in snapshots:
            for skill in skill_values.keys():
                skill_values[skill].append(getattr(snap, skill))

        for skill, values in skill_values.items():
            trend = calculate_trend(values)
            stability = calculate_stability(values)

            obj, _ = SkillTrajectory.objects.get_or_create(
                student=student,
                skill=skill
            )

            obj.trend = trend
            obj.stability = stability
            obj.save()


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\skills\skill_update_service.py
from dataclasses import dataclass
from typing import Dict, List

from curriculum.models.skills.skill_snapshot import SkillSnapshot
from curriculum.models.student.enrollment import Enrollment
from curriculum.models.content.task import Task
from curriculum.models.assessment.assessment import Assessment

from curriculum.models.skills.skill_profile import CurrentSkillProfile
from curriculum.services.skills.skill_delta_calculator import SkillDeltaCalculator
from curriculum.services.skills.skill_trajectory_updater import SkillTrajectoryUpdater


@dataclass
class SkillUpdateResult:
    """
    Результат обновления навыков.

    Используется:
    - DecisionService
    - TransitionRecorder
    - Explainability
    """

    updated_skills: Dict[str, float]
    deltas: Dict[str, float]
    snapshot: SkillSnapshot
    error_events: List[str]


class SkillUpdateService:
    """
    SkillUpdateService обновляет состояние навыков студента
    на основе результата assessment.

    TODO (SkillUpdateService):

    1. Explicit Skill model
    2. Formal mapping Task → SkillSignal
    3. Weighting by ProfessionalTag
    4. LearningObjective ↔ Skill alignment
    5. Skill decay over time
    """

    def __init__(self):
        self.trajectory_updater = SkillTrajectoryUpdater()
        self.delta_calculator = SkillDeltaCalculator()

    def update(
            self,
            enrollment: Enrollment,
            task: Task,
            assessment_result: Assessment,
    ) -> SkillUpdateResult:
        """
        Основной метод обновления навыков.

        Алгоритм (v1):
        1. Загружаем текущий SkillProfile
        2. Интерпретируем assessment → skill deltas
        3. Обновляем профиль
        4. Фиксируем snapshot и trajectory
        5. Логируем ошибки
        """

        # Получаем текущий профиль
        skill_profile, _ = CurrentSkillProfile.objects.get_or_create(
            student=enrollment.student
        )

        # Получаем текущие навыки как словарь
        current_skills = skill_profile.to_dict()

        # Рассчитываем дельты
        deltas = self.delta_calculator.calculate(
            assessment=assessment_result,
            task=task,
            enrollment=enrollment,
        )

        # Обновляем навыки
        updated_skills = {}
        for skill_name, delta in deltas.items():
            if skill_name in current_skills:
                new_value = max(0.0, min(1.0, current_skills[skill_name] + delta))
                current_skills[skill_name] = new_value
                updated_skills[skill_name] = new_value

        # Сохраняем обновленные навыки
        skill_profile.update_from_dict(current_skills)
        skill_profile.save()

        # Создаем snapshot
        snapshot = SkillSnapshot.objects.create(
            student=enrollment.student,
            **current_skills
        )

        # Обновляем траекторию
        self.trajectory_updater.update(enrollment.student)

        return SkillUpdateResult(
            updated_skills=updated_skills,
            deltas=deltas,
            snapshot=snapshot,
            error_events=[]
        )

    def _calculate_skill_deltas(
            self,
            task: Task,
            assessment: Assessment,
    ) -> Dict[str, float]:
        """
        Интерпретирует structured_feedback Assessment
        в изменения навыков.

        v1:
        - используем skill-specific scores
        - baseline = 0.6
        - delta ограничена
        """

        deltas: Dict[str, float] = {}

        feedback = assessment.structured_feedback or {}

        BASELINE = 0.6
        # Это дизайнерское допущение:
        # 0.5 — “угадал”
        # 0.6 — “продемонстрировал навык”
        MAX_DELTA = 0.1

        skill_score_map = {
            "grammar": feedback.get("score_grammar"),
            "vocabulary": feedback.get("score_vocabulary"),
            "listening": feedback.get("score_listening"),
            "reading": feedback.get("score_reading"),
            "writing": feedback.get("score_writing"),
            "speaking": feedback.get("score_speaking"),
        }

        for skill, score in skill_score_map.items():
            if score is None:
                continue

            delta = score - BASELINE
            delta = max(-MAX_DELTA, min(MAX_DELTA, delta))

            deltas[skill] = delta

        return deltas


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\services\skills\utils\trajectory_math.py
from typing import List
import numpy as np


def calculate_trend(values: List[float]) -> float:
    """
    Рассчитывает тренд навыка.
    Используется линейная регрессия по времени.

    Возвращает:
    -1.0 .. 1.0
    """
    if len(values) < 2:
        return 0.0

    x = np.arange(len(values))
    y = np.array(values)

    slope = np.polyfit(x, y, 1)[0]

    # нормализация
    return max(-1.0, min(1.0, slope))


def calculate_stability(values: List[float]) -> float:
    """
    Оценивает устойчивость навыка.
    Чем меньше разброс — тем выше стабильность.
    """
    if len(values) < 3:
        return 0.0

    std = np.std(values)
    return max(0.0, min(1.0, 1 - std))


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\templates\curriculum\course_detail.html
{% extends "base.html" %}
{% load static %}

{% block title %}{{ course.title }}{% endblock %}

{% block css %}
<link rel="stylesheet" href="{% static 'css/course-detail.css' %}">
{% endblock %}

{% block content %}
<section class="course-detail">
    <div class="course-detail__container container">

        <!-- Основной контент -->
        <div class="course-detail__layout">

            <!-- Левая колонка -->
            <main class="course-detail__main">

                <header class="course-header">
                    <h1 class="course-header__title">{{ course.title }}</h1>
                    <p class="course-header__description">
                        {{ course.description }}
                    </p>

                    <div class="course-header__meta">
                        <span>📚 {{ course.ordered_lessons|length }} уроков</span>
                        <span>⏱ ~{{ course.estimated_duration }} мин</span>
                    </div>
                </header>

                <section class="course-progress card">
                    {% if enrollment %}
                        <div class="progress">
                            <div class="progress__bar"
                                 style="width: {{ progress_percent }}%">
                                {{ progress_percent }}%
                            </div>
                        </div>

                        <div class="course-progress__current">
                            Текущий урок:
                            <strong>{{ current_lesson.title|truncatechars:50 }}</strong>
                        </div>

                        {% if next_task %}
                            <div class="course-progress__next">
                                ➜ Следующее задание:
                                <strong>{{ next_task.title }}</strong>
                            </div>
                        {% endif %}

                        <a href="{% url 'curriculum:learning_session' enrollment.id %}"
                           class="btn btn_primary course-progress__action">
                            Продолжить обучение
                        </a>
                        <a href="{% url 'curriculum:course_history' enrollment.id %}"
                           class="btn btn_primary course-progress__action">
                            Посмотреть историю
                        </a>
                    {% else %}
                        <button class="btn btn_success course-progress__action enroll-btn"
                                data-course-id="{{ course.id }}">
                            Записаться на курс
                        </button>
                    {% endif %}
                </section>

                <!-- Уроки -->
                <section class="course-lessons">
                    <h2 class="course-lessons__title">Уроки курса</h2>

                    {% for lesson in course.ordered_lessons %}
                        <article class="lesson-item">
                            <header class="lesson-item__header">
                                <h3 class="lesson-item__title">
                                    {{ lesson.order }}. {{ lesson.title }}
                                </h3>
                                <span class="lesson-item__duration">
                                    {{ lesson.duration_minutes }} мин
                                </span>
                            </header>

                            <p class="lesson-item__description">
                                {{ lesson.description|truncatechars:120 }}
                            </p>

                            <div class="lesson-item__meta">
                                <span>🌍 {{ lesson.get_required_cefr_display }}</span>

                                {% if lesson.skill_focus %}
                                    <span>🧠
                                        {% for skill in lesson.skill_focus %}
                                            {{ skill }}{% if not forloop.last %}, {% endif %}
                                        {% endfor %}
                                    </span>
                                {% endif %}
                            </div>
                        </article>
                    {% empty %}
                        <div class="course-lessons__empty">
                            В этом курсе пока нет уроков
                        </div>
                    {% endfor %}
                </section>
            </main>

            <!-- Правая колонка -->
            <aside class="course-detail__sidebar">

                <div class="course-info card">
                    <h3 class="course-info__title">Информация о курсе</h3>

                    <ul class="course-info__list">
                        <li>
                            🎯 Уровень:
                            {{ course.get_target_cefr_from_display }}
                            –
                            {{ course.get_target_cefr_to_display }}
                        </li>
                        <li>
                            ⏱ Продолжительность:
                            ~{{ course.estimated_duration }} мин
                        </li>
                        <li>
                            📘 Уроков:
                            {{ course.ordered_lessons|length }}
                        </li>
                    </ul>

                    {% if course.learning_objectives.exists %}
                        <div class="course-info__objectives">
                            <h4>Цели обучения</h4>
                            <ul>
                                {% for objective in course.learning_objectives.all %}
                                    <li>✔ {{ objective.name }}</li>
                                {% endfor %}
                            </ul>
                        </div>
                    {% endif %}

                    {% if enrollment %}
                        <div class="course-info__progress">
                            <h4>Ваш прогресс</h4>
                            <div class="progress">
                                <div class="progress__bar"
                                     style="width: {{ progress_percent }}%">
                                    {{ progress_percent }}%
                                </div>
                            </div>
                            <small>
                                Текущий урок:
                                {{ current_lesson.title|truncatechars:30 }}
                            </small>
                        </div>
                    {% endif %}
                </div>

            </aside>

        </div>
    </div>
</section>
{% endblock %}


{% block script %}
<script>
$(document).ready(function() {
    $('.enroll-btn').click(function() {
        var button = $(this);
        var courseId = button.data('course-id');
        
        button.prop('disabled', true).html('<i class="fas fa-spinner fa-spin me-2"></i>Запись...');
        
        $.ajax({
            url: '/api/enroll/' + courseId + '/',
            type: 'POST',
            headers: {
                'X-CSRFToken': '{{ csrf_token }}'
            },
            success: function(response) {
                if (response.redirect_url) {
                    window.location.href = response.redirect_url;
                } else {
                    location.reload();
                }
            },
            error: function(xhr) {
                button.prop('disabled', false).html('<i class="fas fa-plus me-2"></i>Записаться на курс');
                alert('Ошибка при записи на курс: ' + (xhr.responseJSON.error || 'Неизвестная ошибка'));
            }
        });
    });
});
</script>
{% endblock script %}


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\templates\curriculum\course_history.html
{% extends "base.html" %}
{% load static %}

{% block title %}История курса: {{ course.title }}{% endblock %}

{% block content %}
<section class="course-history">
    <div class="course-history__layout">

        <!-- Main -->
        <main class="course-history__main">
            <article class="course-history-card">
                <header class="course-history-card__header">
                    <h1 class="course-history-card__title">
                        История курса: {{ course.title }}
                    </h1>
                    <span class="course-history-card__progress">
                        {{ overall_progress }}%
                    </span>
                </header>

                <div class="course-history-card__body">
                    <p class="course-history-card__description">
                        {{ course.description }}
                    </p>

                    {% if completed_lessons %}
                        <ul class="lesson-history-list">
                            {% for item in completed_lessons %}
                                <li class="lesson-history-item">
                                    <a href="{% url 'curriculum:lesson_history' enrollment.id item.lesson.id %}"
                                       class="lesson-history-item__link">

                                        <div class="lesson-history-item__header">
                                            <h3 class="lesson-history-item__title">
                                                {{ item.lesson.order }}. {{ item.lesson.title }}
                                            </h3>
                                            <time class="lesson-history-item__date">
                                                {{ item.last_response_date|date:"d.m.Y" }}
                                            </time>
                                        </div>

                                        <p class="lesson-history-item__description">
                                            {{ item.lesson.description|truncatechars:100 }}
                                        </p>

                                        <div class="lesson-history-item__progress">
                                            <div class="progress">
                                                <div class="progress__bar"
                                                     style="width: {{ item.completion_percent }}%">
                                                    {{ item.completion_percent }}%
                                                </div>
                                            </div>
                                        </div>

                                        <div class="lesson-history-item__meta">
                                            Завершено {{ item.completed_tasks }} из {{ item.total_tasks }} заданий
                                        </div>

                                    </a>
                                </li>
                            {% endfor %}
                        </ul>
                    {% else %}
                        <div class="course-history__empty">
                            Вы еще не завершили ни одного урока в этом курсе.
                        </div>
                    {% endif %}
                </div>
            </article>
        </main>

        <!-- Sidebar -->
        <aside class="course-history__sidebar">
            <section class="course-summary">
                <h2 class="course-summary__title">Общий прогресс</h2>

                <div class="course-summary__progress">
                    <div class="progress">
                        <div class="progress__bar"
                             style="width: {{ overall_progress }}%">
                            {{ overall_progress }}%
                        </div>
                    </div>
                    <div class="course-summary__caption">
                        Завершено {{ completed_lessons|length }}
                        из {{ course.lessons.filter.is_active.count }} уроков
                    </div>
                </div>

                <ul class="course-summary__stats">
                    <li>
                        <strong>Уровень:</strong>
                        {{ enrollment.student.english_level|default:"A1" }}
                    </li>
                    <li>
                        <strong>Всего заданий:</strong>
                        {{ course.lessons.aggregate(total=Sum('tasks_count'))|default:0 }}
                    </li>
                    <li>
                        <strong>Длительность:</strong>
                        ~{{ course.estimated_duration }} мин
                    </li>
                </ul>

                <div class="course-summary__actions">
                    <a href="{% url 'curriculum:learning_session' enrollment.id %}"
                       class="btn btn_primary">
                        Продолжить обучение
                    </a>
                    <a href="{% url 'curriculum:course_list' %}"
                       class="btn btn_outline">
                        Все курсы
                    </a>
                </div>
            </section>
        </aside>

    </div>
</section>
{% endblock %}


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\templates\curriculum\course_list.html
{% extends "base.html" %}
{% load static %}

{% block title %}Курсы{% endblock %}

{% block css %}
<link rel="stylesheet" href="{% static 'css/courses.css' %}">
{% endblock %}

{% block content %}
<section class="courses">
    <div class="courses__container container">

        <header class="courses__header">
            <h1 class="courses__title">Все доступные курсы</h1>

            {% if student %}
                <div class="courses__student student-info">
                    <div class="student-info__item">
                        👋 {{ student.user.get_full_name|default:student.user.username }}
                    </div>
                    <div class="student-info__item">
                        Уровень: <strong>{{ student.cefr_level|default:"—" }}</strong>
                    </div>
                    <div class="student-info__item">
                        Контекст: {{ student.professional_context|default:"не указан" }}
                    </div>
                </div>
            {% endif %}
        </header>

        {% if courses %}
            <div class="courses__grid">
                {% for course in courses %}
                    <article class="course-card">

                        <header class="course-card__header">
                            <h3 class="course-card__title">
                                <a href="{% url 'curriculum:course_detail' course.id %}"
                                class="course-card__title-link">
                                    {{ course.title }}
                                </a>
                            </h3>
                            <div class="course-card__level">
                                {{ course.get_target_cefr_from_display }}
                                →
                                {{ course.get_target_cefr_to_display }}
                            </div>
                        </header>

                        <div class="course-card__body">
                            <p class="course-card__description">
                                {{ course.description|truncatechars:120 }}
                            </p>

                            <div class="course-card__meta">
                                <span>📚 {{ course.ordered_lessons|length }} уроков</span>
                                <span>⏱ ~{{ course.estimated_duration }} мин</span>
                            </div>

                            {% if course.enrollment %}
                                <div class="course-card__progress progress">
                                    <div class="progress__bar"
                                         style="width: {{ course.progress_percent }}%">
                                        {{ course.progress_percent }}%
                                    </div>
                                </div>

                                <div class="course-card__current">
                                    Текущий урок:
                                    <strong>
                                        {{ course.enrollment.current_lesson.title|truncatechars:40 }}
                                    </strong>
                                </div>

                                <a href="{% url 'course_detail' course.id %}"
                                   class="btn btn_primary course-card__action">
                                    Продолжить
                                </a>
                                <a href="{% url 'curriculum:course_history' course.enrollment.id %}"
                                   class="btn btn_primary course-card__action">
                                    История
                                </a>
                            {% else %}
                                {% if not request.user.is_authenticated %}
                                    <a href="{% url 'users:login' %}?next={{ request.path }}"
                                    class="btn btn_ghost course-card__action">
                                        Войти для записи
                                    </a>
                                {% else %}
                                    <button 
                                        class="btn btn_primary course-card__action enroll-btn" 
                                        data-course-id="{{ course.id }}"
                                        data-url="{% url 'curriculum:enroll_course' course.id %}">
                                        Записаться
                                    </button>
                                {% endif %}
                            {% endif %}
                        </div>
                    </article>
                {% endfor %}
            </div>

            {% if page_obj.has_other_pages %}
                <nav class="courses__pagination pagination">
                    {% if page_obj.has_previous %}
                        <a class="pagination__link"
                           href="?page={{ page_obj.previous_page_number }}">
                            ←
                        </a>
                    {% endif %}

                    {% for num in page_obj.paginator.page_range %}
                        {% if page_obj.number == num %}
                            <span class="pagination__link pagination__link--active">
                                {{ num }}
                            </span>
                        {% elif num > page_obj.number|add:'-3' and num < page_obj.number|add:'3' %}
                            <a class="pagination__link" href="?page={{ num }}">
                                {{ num }}
                            </a>
                        {% endif %}
                    {% endfor %}

                    {% if page_obj.has_next %}
                        <a class="pagination__link"
                           href="?page={{ page_obj.next_page_number }}">
                            →
                        </a>
                    {% endif %}
                </nav>
            {% endif %}

        {% else %}
            <div class="courses__empty">
                Пока нет доступных курсов
            </div>
        {% endif %}

    </div>
</section>
{% endblock %}


{% block script %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    const enrollButtons = document.querySelectorAll('.enroll-btn');

    enrollButtons.forEach(button => {
        button.addEventListener('click', function() {
            const enrollUrl = button.dataset.url; // URL для POST
            if (!enrollUrl) return;

            // Создаём спиннер
            const spinner = document.createElement('span');
            spinner.className = 'button-spinner';

            // Сохраняем исходный текст кнопки
            const originalText = button.textContent;
            button.textContent = '';
            button.appendChild(spinner);
            button.appendChild(document.createTextNode('Запись...'));
            button.disabled = true;

            fetch(enrollUrl, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': '{{ csrf_token }}',
                    'Content-Type': 'application/json'
                }
            })
            .then(async response => {
                const data = await response.json();
                if (!response.ok) {
                    // Обрабатываем ошибки от бэка
                    throw new Error(data.error || 'Неизвестная ошибка');
                }
                return data;
            })
            .then(data => {
                if (data.redirect_url) {
                    window.location.href = data.redirect_url;
                } else {
                    location.reload();
                }
            })
            .catch(error => {
                console.error('Ошибка при записи на курс:', error);
                button.disabled = false;
                button.textContent = originalText;
                alert('Ошибка при записи на курс: ' + error.message);
            });
        });
    });
});
</script>
{% endblock script %}



#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\templates\curriculum\learning_session.html
{% extends "base.html" %}
{% load static %}

{% block title %}Обучение · {{ enrollment.course.title }}{% endblock %}

{% block css %}
<link href="{% static 'css/learning-session.css' %}" rel="stylesheet">
{% endblock %}

{% block content %}
<section class="learning-session">
    <div class="learning-session__container">

        <!-- Header -->
        <header class="learning-header">
            <h2 class="learning-header__title">
                {{ enrollment.course.title }}
            </h2>
            <h3 class="learning-header__subtitle">
                {{ learning_state.current_lesson.title }}
            </h3>
            <div class="learning-header__meta">
                Урок {{ learning_state.current_lesson.order }}
                из {{ progress_details.total_lessons }}
            </div>
        </header>

        <div class="learning-layout">

            <!-- Main -->
            <main class="learning-main">

                {% if next_task %}
                    <section class="task-card">
                        <h2 class="task-card__title">
                            {{ next_task.title }}
                        </h2>

                        <p class="task-card__prompt">
                            {{ next_task.content.prompt }}
                        </p>

                        <form class="task-form"
                              id="task-response-form"
                              method="post"
                              action="{% url 'curriculum:submit_task_response' enrollment.id %}">
                            {% csrf_token %}
                            <input type="hidden" name="task_id" value="{{ next_task.id }}">

                            {% if next_task.response_format == 'single_choice' %}
                                {% for option in next_task.content.options %}
                                    <label class="task-option">
                                        <input type="radio" name="text" value="{{ forloop.counter0 }}" required>
                                        <span>{{ option }}</span>
                                    </label>
                                {% endfor %}
                            {% elif next_task.response_format == 'multiple_choice' %}
                                {% for option in next_task.content.options %}
                                    <label class="task-option">
                                        <input type="checkbox" name="text" value="{{ forloop.counter0 }}">
                                        <span>{{ option }}</span>
                                    </label>
                                {% endfor %}
                            {% elif next_task.response_format == 'short_text' %}
                                <input class="task-input"
                                       type="text"
                                       name="text"
                                       maxlength="100"
                                       placeholder="Краткий ответ"
                                       required>
                            {% elif next_task.response_format == 'free_text' %}
                                <textarea class="task-textarea"
                                          name="text"
                                          rows="4"
                                          placeholder="Введите ответ"
                                          required></textarea>
                            {% elif next_task.response_format == 'audio' %}
                                <input class="task-file"
                                       type="file"
                                       name="audio_file"
                                       accept="audio/*"
                                       required>
                            {% endif %}

                            <button class="task-submit" type="submit">
                                Отправить ответ
                            </button>
                        </form>
                    </section>
                {% else %}
                    <section class="lesson-finished">
                        <div class="lesson-finished__icon">🧠</div>
                        <h2 class="lesson-finished__title">Урок завершён</h2>
                        <p class="lesson-finished__text">
                            Этот урок больше не сопротивляется.
                            Можно двигаться дальше.
                        </p>

                        <div class="lesson-finished__actions">
                            <a href="{% url 'course_detail' enrollment.course.id %}" class="btn btn_primary">К курсу</a>
                            <a href="{% url 'course_list' %}" class="btn">Все курсы</a>
                        </div>
                    </section>
                {% endif %}

            </main>

            <!-- Sidebar -->
            <aside class="learning-sidebar">

                <section class="progress-card">
                    <div class="progress-card__title">Прогресс курса</div>

                    <div class="progress-bar">
                        <div class="progress-bar__value" style="width: {{ progress_details.progress_percent|floatformat:0 }}%"></div>
                    </div>

                    <div class="progress-card__percent">
                        {{ progress_details.progress_percent|floatformat:0 }}%
                    </div>
                </section>

                <section class="skills-card">
                    <div class="skills-card__title">Навыки</div>

                    {% for skill, value in learning_state.skills.items %}
                        <div class="skill">
                            <div class="skill__row">
                                <span>{{ skill|title }}</span>
                                <span>{{ value|floatformat:0 }}%</span>
                            </div>
                            <div class="skill__bar">
                                <div class="skill__value" style="width: {{ value|floatformat:0 }}%"></div>
                            </div>
                        </div>
                    {% endfor %}
                </section>

            </aside>

        </div>
    </div>
</section>
{% endblock %}


{% block script %}
<script src="{% static 'js/task-detail.js' %}"></script>
{% endblock %}

#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\templates\curriculum\learning_session_task.html
{% extends "base.html" %}
{% load static %}

{% block title %}Задание: {{ current_task.title }}{% endblock %}

{% block css %}
<link rel="stylesheet" href="{% static 'css/task-detail.css' %}">
{% endblock %}

{% block content %}
<section class="task-page">

    <div class="task-page__layout">

        <!-- MAIN -->
        <main class="task-main">

            <header class="task-header">
                <div class="task-header__title">
                    {{ current_task.title }}
                </div>

                <div class="task-header__meta">
                    Урок {{ progress_details.current_lesson.order }}
                    из {{ progress_details.total_lessons }}
                </div>
            </header>

            <section class="task-card">

                {% if current_task.content.prompt %}
                <h3 class="task-card__prompt">
                    {{ current_task.content.prompt }}
                </h3>
                {% endif %}

                {% if current_task.content.options %}
                <form id="task-response-form"
                      class="task-form"
                      method="POST"
                      action="{% url 'curriculum:submit_task_response' enrollment.id %}">

                    {% csrf_token %}
                    <input type="hidden" name="task_id" value="{{ current_task.id }}">

                    {% if current_task.response_format == 'single_choice' %}
                        {% for option in current_task.content.options %}
                        <label class="task-option">
                            <input type="radio" name="text" value="{{ forloop.counter0 }}" required>
                            <span>{{ option }}</span>
                        </label>
                        {% endfor %}

                    {% elif current_task.response_format == 'multiple_choice' %}
                        {% for option in current_task.content.options %}
                        <label class="task-option">
                            <input type="checkbox" name="text" value="{{ forloop.counter0 }}">
                            <span>{{ option }}</span>
                        </label>
                        {% endfor %}

                    {% elif current_task.response_format == 'short_text' %}
                        <input class="task-input"
                               type="text"
                               name="text"
                               maxlength="100"
                               placeholder="Введите краткий ответ"
                               required>
                        <div class="task-hint">Не более 3 слов</div>

                    {% elif current_task.response_format == 'free_text' %}
                        <textarea class="task-textarea"
                                  name="text"
                                  rows="4"
                                  placeholder="Введите развёрнутый ответ"
                                  required></textarea>

                    {% elif current_task.response_format == 'audio' %}
                        <input class="task-file"
                               type="file"
                               name="audio_file"
                               accept="audio/*"
                               required>
                    {% endif %}

                    <div class="task-actions">
                        <button type="submit" class="btn btn_primary">
                            Отправить ответ
                        </button>

                        <a href="{% url 'curriculum:learning_session' enrollment.id %}"
                           class="btn btn_ghost">
                            Назад к сессии
                        </a>
                    </div>

                </form>
                {% endif %}

            </section>

            {% if progress_details.completed_lessons > 0 %}
            <a class="task-history"
               href="{% url 'curriculum:lesson_history' enrollment.id progress_details.current_lesson.id %}">
                История этого урока
            </a>
            {% endif %}

        </main>

        <!-- SIDEBAR -->
        <aside class="task-sidebar">

            <section class="sidebar-card">
                <div class="sidebar-title">Прогресс курса</div>

                <div class="progress-bar">
                    <div class="progress-bar__value"
                         style="width: {{ progress_percent }}%"></div>
                </div>

                <div class="sidebar-muted">
                    {{ progress_percent }}% ·
                    урок {{ progress_details.current_lesson.order }}
                    из {{ progress_details.total_lessons }}
                </div>
            </section>

            <section class="sidebar-card">
                <div class="sidebar-title">
                    {{ progress_details.current_lesson.title }}
                </div>

                <div class="sidebar-tip">
                    {% if current_task.response_format == 'audio' %}
                        Говорите чётко и спокойно
                    {% elif current_task.response_format == 'free_text' %}
                        Используйте изученную лексику
                    {% else %}
                        Внимательно читайте варианты
                    {% endif %}
                </div>
            </section>

            <section class="sidebar-card">
                <a class="btn btn_outline"
                   href="{% url 'curriculum:course_history' enrollment.id %}">
                    История курса
                </a>
            </section>

        </aside>

    </div>
</section>

<div id="task-feedback"></div>
{% endblock %}

{% block script %}
<script src="{% static 'js/task-detail.js' %}"></script>
{% endblock %}


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\templates\curriculum\lesson_history.html
{% extends "base.html" %}
{% load static %}

{% block title %}История урока: {{ lesson.title }}{% endblock %}

{% block css %}
<link rel="stylesheet" href="{% static 'css/lesson-history.css' %}">
{% endblock %}

{% block content %}
<section class="lesson-history">

    <div class="lesson-history__layout">

        <!-- MAIN -->
        <main class="lesson-history__main">

            <header class="lesson-history__header">
                <h1 class="lesson-history__title">
                    История урока: {{ lesson.title }}
                </h1>

                <div class="lesson-history__progress">
                    {{ progress_percent }}% завершено
                </div>
            </header>

            <p class="lesson-history__description">
                {{ lesson.description }}
            </p>

            {% if history %}
                <div class="lesson-history__list">

                    {% for item in history %}
                    <details class="history-item"
                             {% if item.is_completed %}open{% endif %}>

                        <summary class="history-item__summary">
                            <span class="history-item__title">
                                Задание {{ item.task.order }}:
                                {{ item.task.title|truncatechars:50 }}
                            </span>

                            <span class="history-item__status
                                {% if item.is_completed %}
                                    history-item__status--done
                                {% else %}
                                    history-item__status--pending
                                {% endif %}">
                                {% if item.is_completed %}Выполнено{% else %}Не выполнено{% endif %}
                            </span>

                            {% if item.score is not None %}
                            <span class="history-item__score">
                                {{ item.score|floatformat:0 }}%
                            </span>
                            {% endif %}
                        </summary>

                        <div class="history-item__content">

                            <section class="history-block">
                                <h4 class="history-block__title">Текст задания</h4>
                                <p>{{ item.task.content.prompt|safe }}</p>

                                {% if item.task.content.options %}
                                <ul class="history-options">
                                    {% for option in item.task.content.options %}
                                    <li>{{ forloop.counter }}. {{ option }}</li>
                                    {% endfor %}
                                </ul>
                                {% endif %}
                            </section>

                            {% if item.is_completed %}
                            <section class="history-block">
                                <h4 class="history-block__title">Ваш ответ</h4>

                                {% if item.task.response_format == 'audio' and item.response.audio_file %}
                                    <audio controls class="history-audio">
                                        <source src="{{ item.response.audio_file.url }}">
                                    </audio>
                                {% else %}
                                    <div class="history-answer">
                                        {{ item.response.response_text|linebreaks }}
                                    </div>
                                {% endif %}
                            </section>

                            <section class="history-block">
                                <h4 class="history-block__title">Обратная связь</h4>

                                <div class="history-feedback
                                    {% if item.score and item.score >= 70 %}
                                        history-feedback--success
                                    {% else %}
                                        history-feedback--warning
                                    {% endif %}">
                                    {{ item.feedback|default:"Оценка выполнена" }}
                                </div>

                                {% if item.score is not None %}
                                <div class="progress-bar">
                                    <div class="progress-bar__value"
                                         style="width: {{ item.score|floatformat:0 }}%">
                                    </div>
                                </div>
                                {% endif %}
                            </section>

                            <div class="history-meta">
                                Ответ отправлен: {{ item.created_at|date:"d.m.Y H:i" }}
                            </div>

                            {% else %}
                            <div class="history-info">
                                Задание ещё не выполнено
                            </div>
                            {% endif %}

                        </div>
                    </details>
                    {% endfor %}

                </div>

                {% if can_return_to_lesson %}
                <a class="btn btn_primary lesson-history__back"
                   href="{% url 'curriculum:learning_session_task' enrollment.id history.0.task.id %}">
                    Вернуться к текущему заданию
                </a>
                {% endif %}

            {% else %}
                <div class="lesson-history__empty">
                    В этом уроке ещё нет выполненных заданий
                </div>
            {% endif %}

        </main>

        <!-- SIDEBAR -->
        <aside class="lesson-history__sidebar">

            <section class="sidebar-card">
                <div class="sidebar-title">Прогресс урока</div>

                <div class="progress-bar">
                    <div class="progress-bar__value"
                         style="width: {{ progress_percent }}%"></div>
                </div>

                <div class="sidebar-muted">
                    Завершено {{ completed_tasks }} из {{ total_tasks }} заданий
                </div>
            </section>

            <section class="sidebar-card">
                <div class="sidebar-title">Статистика</div>

                <ul class="lesson-stats">
                    <li>
                        <strong>Навыки:</strong>
                        {% for skill in lesson.skill_focus %}
                            <span class="lesson-skill">{{ skill }}</span>
                        {% endfor %}
                    </li>
                    <li>
                        <strong>Длительность:</strong>
                        ~{{ lesson.duration_minutes }} мин
                    </li>
                    <li>
                        <strong>Уровень:</strong>
                        {{ lesson.get_required_cefr_display }}
                    </li>
                </ul>
            </section>

            <section class="sidebar-card">
                <a class="btn btn_outline"
                   href="{% url 'curriculum:course_history' enrollment.id %}">
                    История курса
                </a>

                <a class="btn btn_ghost"
                   href="{% url 'curriculum:learning_session' enrollment.id %}">
                    Назад к сессии
                </a>
            </section>

        </aside>

    </div>
</section>
{% endblock %}


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\views\course_views.py
import time

from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth.decorators import login_required
from django.views.generic import ListView, DetailView
from django.http import JsonResponse
from django.db.models import Prefetch, Exists, OuterRef, Subquery

from curriculum.config.dependency_factory import CurriculumServiceFactory
from curriculum.models.content.course import Course
from curriculum.models.content.lesson import Lesson
from curriculum.models.student.enrollment import Enrollment
from curriculum.services.curriculum_query import CurriculumQueryService
from curriculum.config.dependency_factory import CurriculumServiceFactory


class CourseListView(LoginRequiredMixin, ListView):
    """
    Представление для отображения списка всех курсов с уроками.
    Для аутентифицированных пользователей показывает информацию о зачислении.
    """
    model = Course
    template_name = 'curriculum/course_list.html'
    context_object_name = 'courses'
    paginate_by = 10

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.learning_service = CurriculumServiceFactory().create_learning_service()

    def get_queryset(self):
        # Предзагружаем уроки для каждого курса, отсортированные по порядку
        queryset = Course.objects.filter(is_active=True).prefetch_related(
            Prefetch('lessons',
                     queryset=Lesson.objects.filter(is_active=True).order_by('order'),
                     to_attr='ordered_lessons')
        )

        # Если пользователь аутентифицирован, предзагружаем его enrollment
        if self.request.user.is_authenticated:
            student = getattr(self.request.user, 'student', None)
            if student:
                queryset = queryset.annotate(
                    has_enrollment=Exists(
                        Enrollment.objects.filter(
                            student=student,
                            course=OuterRef('pk'),
                            is_active=True
                        )
                    ),
                    enrollment_id=Subquery(
                        Enrollment.objects.filter(
                            student=student,
                            course=OuterRef('pk'),
                            is_active=True
                        ).values('id')[:1]
                    )
                )

        return queryset.order_by('title')

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)

        if hasattr(self.request.user, 'student'):
            student = self.request.user.student
            context['enrollments'] = self.learning_service.enrollment_service.get_student_enrollments(student)

        return context


class CourseDetailView(LoginRequiredMixin, DetailView):
    """
    Детальное представление курса с уроками и информацией о зачислении.
    """
    model = Course
    template_name = 'curriculum/course_detail.html'
    context_object_name = 'course'

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        factory = CurriculumServiceFactory()
        self.learning_service = factory.create_learning_service()
        self.enrollment_service = self.learning_service.enrollment_service

    def get_queryset(self):
        return Course.objects.filter(is_active=True).prefetch_related(
            Prefetch('lessons',
                     queryset=Lesson.objects.filter(is_active=True).order_by('order'),
                     to_attr='ordered_lessons')
        )

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        course = self.object
        student = getattr(self.request.user, 'student', None)

        # Получаем enrollment для текущего студента и курса
        enrollment = None
        if student:
            try:
                enrollment = Enrollment.objects.get(
                    student=student,
                    course=course,
                    is_active=True
                )
            except Enrollment.DoesNotExist:
                enrollment = None

        context['enrollment'] = enrollment
        context['student'] = student

        if enrollment:
            context['progress_percent'] = self.enrollment_service.calculate_progress(enrollment)
            context['progress_details'] = self.enrollment_service.get_course_progress(enrollment)
            context['current_lesson'] = enrollment.current_lesson

            # Получаем следующее задание
            context['next_task'] = self.learning_service.get_next_task(enrollment.id)

        return context


@login_required
def enroll_in_course(request, course_id):
    """
    Обрабатывает запрос на зачисление студента на курс.
    """
    time.sleep(5)
    student = getattr(request.user, 'student', None)
    if not student:
        return JsonResponse({'error': 'User is not a student'}, status=400)

    try:
        course = Course.objects.get(id=course_id, is_active=True)
    except Course.DoesNotExist:
        return JsonResponse({'error': 'Course not found or inactive'}, status=404)

    # Проверяем, не зачислен ли уже студент на этот курс
    existing_enrollment = Enrollment.objects.filter(
        student=student,
        course=course,
        is_active=True
    ).first()

    if existing_enrollment:
        return JsonResponse({
            'message': 'You are already enrolled in this course',
            'enrollment_id': existing_enrollment.id,
            'redirect_url': f'/curriculum/course/{course_id}/'
        })

    # Создаем новое зачисление
    enrollment = Enrollment.objects.create(
        student=student,
        course=course,
        current_lesson=course.lessons.filter(is_active=True).order_by('order').first()
    )

    return JsonResponse({
        'message': 'Successfully enrolled in course',
        'enrollment_id': enrollment.id,
        'redirect_url': f'/curriculum/course/{course_id}/'
    })


@login_required
def course_list_api(request):
    """
    API endpoint для получения списка курсов в формате JSON.
    Используется для AJAX-запросов и мобильных приложений.
    """
    student = getattr(request.user, 'student', None)

    # Предзагружаем уроки для каждого курса
    courses = Course.objects.filter(is_active=True).prefetch_related(
        Prefetch('lessons',
                 queryset=Lesson.objects.filter(is_active=True).order_by('order'),
                 to_attr='ordered_lessons')
    )

    # Аннотируем информацию о зачислении для аутентифицированных пользователей
    if student:
        courses = courses.annotate(
            has_enrollment=Exists(
                Enrollment.objects.filter(
                    student=student,
                    course=OuterRef('pk'),
                    is_active=True
                )
            ),
            enrollment_id=Subquery(
                Enrollment.objects.filter(
                    student=student,
                    course=OuterRef('pk'),
                    is_active=True
                ).values('id')[:1]
            )
        )

    # Формируем сериализованный ответ
    courses_data = []
    for course in courses.order_by('title'):
        course_data = {
            'id': course.id,
            'title': course.title,
            'description': course.description,
            'target_cefr_from': course.get_target_cefr_from_display(),
            'target_cefr_to': course.get_target_cefr_to_display(),
            'estimated_duration': course.estimated_duration,
            'lessons_count': len(course.ordered_lessons),
            'is_enrolled': getattr(course, 'has_enrollment', False),
            'enrollment_id': getattr(course, 'enrollment_id', None),
            'progress_percent': 0
        }

        # Если есть зачисление, рассчитываем прогресс
        if getattr(course, 'has_enrollment', False) and course.enrollment_id:
            try:
                enrollment = Enrollment.objects.get(id=course.enrollment_id)
                course_data['progress_percent'] = round(
                    (enrollment.current_lesson.order / course.lessons.filter(is_active=True).count()) * 100,
                    1
                ) if enrollment.current_lesson else 0
            except Enrollment.DoesNotExist:
                pass

        courses_data.append(course_data)

    return JsonResponse({'courses': courses_data})


#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\views\learning_session_views.py
import logging
from pprint import pprint

from django.contrib import messages
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth.decorators import login_required
from django.core.exceptions import PermissionDenied
from django.shortcuts import redirect
from django.views.generic import DetailView
from django.http import JsonResponse

from curriculum.config.dependency_factory import CurriculumServiceFactory
from curriculum.models import Task, Lesson
from curriculum.models.content.task import ResponseFormat
from curriculum.models.student.enrollment import Enrollment

logger = logging.getLogger(__name__)


class LearningSessionView(LoginRequiredMixin, DetailView):
    """
    Представление для сессии обучения.
    Отображает текущее задание и обрабатывает ответы студента.
    """
    model = Enrollment
    template_name = 'curriculum/learning_session.html'
    context_object_name = 'enrollment'

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        super().__init__(**kwargs)
        self.learning_service = CurriculumServiceFactory().create_learning_service()
        self.enrollment_service = self.learning_service.enrollment_service

    def get_queryset(self):
        """Фильтруем только активные зачисления текущего студента"""
        return Enrollment.objects.filter(
            student=self.request.user.student,
            is_active=True
        ).select_related(
            'course',
            'current_lesson'
        ).prefetch_related(
            'current_lesson__tasks'
        )

    def get_object(self, queryset=None):
        obj = super().get_object(queryset)
        # Проверяем, что зачисление принадлежит текущему студенту
        if obj.student != self.request.user.student:
            raise PermissionDenied("Вы не можете получить доступ к этой учебной сессии")
        return obj

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        enrollment = self.object

        # Получаем текущее состояние обучения через LearningService
        context['learning_state'] = self.learning_service.get_current_state(enrollment.id)

        # Получаем следующее задание через LearningService
        context['next_task'] = self.learning_service.get_next_task(enrollment.id)

        # Рассчитываем прогресс по курсу через EnrollmentService (ИСПРАВЛЕНО)
        # context['progress_percent'] = self.enrollment_service.calculate_progress(enrollment)

        # Получаем детальную информацию о прогрессе (опционально)
        context['progress_details'] = self.enrollment_service.get_course_progress(enrollment)
        pprint(context)
        return context


class LearningSessionTaskView(LoginRequiredMixin, DetailView):
    """
    Представление для отображения конкретного задания в сессии обучения.

    URL: /curriculum/session/<enrollment_id>/task/<task_id>/
    """
    model = Enrollment
    template_name = 'curriculum/learning_session_task.html'
    context_object_name = 'enrollment'
    pk_url_kwarg = 'enrollment_id'

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        factory = CurriculumServiceFactory()
        self.learning_service = factory.create_learning_service()
        self.enrollment_service = self.learning_service.enrollment_service
        self.curriculum_query = self.learning_service.curriculum_query

    def get_queryset(self):
        return Enrollment.objects.filter(
            student=self.request.user.student,
            is_active=True
        ).select_related('course', 'current_lesson')

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        enrollment = self.object
        task_id = self.kwargs.get('task_id')

        try:
            # Получаем конкретное задание
            context['current_task'] = Task.objects.get(
                id=task_id,
                lesson=enrollment.current_lesson,
                is_active=True
            )

            # Получаем текущее состояние
            context['learning_state'] = self.learning_service.get_current_state(enrollment.id)

            # Рассчитываем прогресс
            context['progress_details'] = self.enrollment_service.get_course_progress(enrollment)

        except Task.DoesNotExist:
            context['error'] = f"Задание {task_id} не найдено или не принадлежит текущему уроку"

        return context


class LessonHistoryView(LoginRequiredMixin, DetailView):
    """
    Представление для просмотра истории выполнения заданий в уроке.

    URL: /curriculum/session/<enrollment_id>/lesson/<lesson_id>/history/
    """
    model = Enrollment
    template_name = 'curriculum/lesson_history.html'
    context_object_name = 'enrollment'
    pk_url_kwarg = 'enrollment_id'

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        factory = CurriculumServiceFactory()
        self.learning_service = factory.create_learning_service()
        self.curriculum_query = self.learning_service.curriculum_query

    def get_queryset(self):
        return Enrollment.objects.filter(
            student=self.request.user.student,
            is_active=True
        ).select_related('course')

    def get_object(self, queryset=None):
        obj = super().get_object(queryset)
        if obj.student != self.request.user.student:
            raise PermissionDenied("You cannot access this lesson history")
        return obj

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        enrollment = self.object
        lesson_id = self.kwargs.get('lesson_id')

        try:
            # Получаем историю урока
            history_data = self.curriculum_query.get_lesson_history(enrollment.id, lesson_id)
            context.update(history_data)

            # Добавляем дополнительную информацию для шаблона
            context['current_lesson_id'] = enrollment.current_lesson.id if enrollment.current_lesson else None
            context['can_return_to_lesson'] = (
                    enrollment.current_lesson and
                    enrollment.current_lesson.id == int(lesson_id)
            )

        except Lesson.DoesNotExist:
            context['error'] = f"Lesson {lesson_id} not found or not accessible"

        return context


class CourseHistoryView(LoginRequiredMixin, DetailView):
    """
    Представление для просмотра истории пройденных уроков в курсе.

    URL: /curriculum/session/<enrollment_id>/history/
    """
    model = Enrollment
    template_name = 'curriculum/course_history.html'
    context_object_name = 'enrollment'
    pk_url_kwarg = 'enrollment_id'

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        factory = CurriculumServiceFactory()
        self.learning_service = factory.create_learning_service()

    def get_queryset(self):
        return Enrollment.objects.filter(
            student=self.request.user.student,
            is_active=True
        ).select_related('course')

    def get_object(self, queryset=None):
        obj = super().get_object(queryset)
        if obj.student != self.request.user.student:
            raise PermissionDenied("You cannot access this course history")
        return obj

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        enrollment = self.object

        try:
            # Получаем историю курса
            history_data = self.learning_service.get_course_history(enrollment.id)
            context.update(history_data)

        except Exception as e:
            context['error'] = f"Error loading course history: {str(e)}"

        return context


@login_required
def submit_task_response(request, enrollment_id):
    """
    Обрабатывает ответ студента на задание.
    Поддерживает как HTML-форму, так и AJAX-запросы.
    """
    # Проверяем права доступа к enrollment
    try:
        enrollment = Enrollment.objects.get(
            id=enrollment_id,
            student=request.user.student,
            is_active=True
        )
    except Enrollment.DoesNotExist:
        error_msg = 'Зачисление не найдено или доступ запрещен'
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest' or request.accepts('application/json'):
            return JsonResponse({'error': error_msg}, status=403)
        messages.error(request, error_msg)
        return redirect('curriculum:course_list')

    if request.method != 'POST':
        error_msg = 'Метод не разрешен'
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest' or request.accepts('application/json'):
            return JsonResponse({'error': error_msg}, status=405)
        messages.error(request, error_msg)
        return redirect('curriculum:learning_session', pk=enrollment_id)

    # Пытаемся получить task_id из запроса
    try:
        task_id = int(request.POST.get('task_id'))
    except (TypeError, ValueError):
        error_msg = 'Неверный ID задания'
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest' or request.accepts('application/json'):
            return JsonResponse({'error': error_msg}, status=400)
        messages.error(request, error_msg)
        return redirect('curriculum:learning_session', pk=enrollment_id)

    # Пытаемся получить задание
    try:
        task = Task.objects.get(id=task_id, is_active=True)
    except Task.DoesNotExist:
        error_msg = f'Задание {task_id} не найдено'
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest' or request.accepts('application/json'):
            return JsonResponse({'error': error_msg}, status=404)
        messages.error(request, error_msg)
        return redirect('curriculum:learning_session', pk=enrollment_id)

    # Валидация данных ответа
    try:
        text_response = request.POST.get('text', '').strip()
        audio_file = request.FILES.get('audio_file')

        if task.response_format == ResponseFormat.AUDIO and not audio_file:
            error_msg = 'Для задания на устную речь требуется аудиофайл'
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest' or request.accepts('application/json'):
                return JsonResponse({'error': error_msg}, status=400)
            messages.error(request, error_msg)
            return redirect('curriculum:learning_session_task', enrollment_id=enrollment_id, task_id=task_id)

        if task.response_format in [ResponseFormat.SINGLE_CHOICE, ResponseFormat.MULTIPLE_CHOICE,
                                    ResponseFormat.SHORT_TEXT] and not text_response:
            error_msg = 'Требуется текстовый ответ'
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest' or request.accepts('application/json'):
                return JsonResponse({'error': error_msg}, status=400)
            messages.error(request, error_msg)
            return redirect('curriculum:learning_session_task', enrollment_id=enrollment_id, task_id=task_id)

        response_data = {
            'text': text_response,
            'audio_file': audio_file
        }

    except Exception as e:
        error_msg = f'Ошибка при обработке данных: {str(e)}'
        logger.error(error_msg, exc_info=True)
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest' or request.accepts('application/json'):
            return JsonResponse({'error': error_msg}, status=400)
        messages.error(request, error_msg)
        return redirect('curriculum:learning_session_task', enrollment_id=enrollment_id, task_id=task_id)

    # Основная логика обработки
    try:
        factory = CurriculumServiceFactory()
        learning_service = factory.create_learning_service()

        result = learning_service.submit_task_response(
            enrollment_id=enrollment_id,
            task_id=task_id,
            response_payload=response_data
        )

        # Определяем тип ответа
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest' or request.accepts('application/json'):
            return JsonResponse(result)
        else:
            next_action = result.get('next_action')

            if next_action == 'NEXT_TASK' and result.get('next_task_id'):
                messages.success(request, 'Ответ сохранен. Переходим к следующему заданию.')
                return redirect('curriculum:learning_session_task',
                                enrollment_id=enrollment_id,
                                task_id=result['next_task_id'])

            elif next_action in ['ADVANCE_LESSON', 'COMPLETE_COURSE']:
                messages.success(request, 'Урок завершен! Переходим к следующему уроку.')
                return redirect('curriculum:learning_session', pk=enrollment_id)

            else:  # RETRY_TASK или неизвестное действие
                messages.warning(request, 'Попробуйте выполнить задание еще раз.')
                return redirect('curriculum:learning_session_task',
                                enrollment_id=enrollment_id,
                                task_id=task_id)

    except Exception as e:
        logger.error(f"Error in submit_task_response: {str(e)}", exc_info=True)
        error_msg = 'Произошла ошибка при обработке ответа. Попробуйте еще раз.'

        if request.headers.get('X-Requested-With') == 'XMLHttpRequest' or request.accepts('application/json'):
            return JsonResponse({
                'error': str(e),
                'message': error_msg
            }, status=500)
        else:
            messages.error(request, f'{error_msg}: {str(e)}')
            return redirect('curriculum:learning_session_task', enrollment_id=enrollment_id, task_id=task_id)

#######

D:\ML\Projects\Practice\engageAI_v2\engageai_core\curriculum\views\api\course_api.py
from rest_framework import viewsets, permissions, status
from rest_framework.decorators import action
from rest_framework.response import Response
from curriculum.models.content.course import Course
from curriculum.models.student.enrollment import Enrollment
from curriculum.permissions import IsStudentOrTeacher

from curriculum.views import CourseSerializer


class CourseViewSet(viewsets.ReadOnlyModelViewSet):
    """
    API endpoint для работы с курсами.
    """
    queryset = Course.objects.filter(is_active=True)
    serializer_class = CourseSerializer
    permission_classes = [permissions.IsAuthenticated, IsStudentOrTeacher]

    def get_queryset(self):
        queryset = super().get_queryset()
        # Предзагружаем уроки для каждого курса
        return queryset.prefetch_related(
            'lessons'
        ).order_by('title')

    def get_serializer_context(self):
        context = super().get_serializer_context()
        context['request'] = self.request
        return context

    @action(detail=True, methods=['post'])
    def enroll(self, request, pk=None):
        """
        Зачисление студента на курс
        """
        course = self.get_object()
        student = request.user.student

        # Проверяем, не зачислен ли уже студент на этот курс
        existing_enrollment = Enrollment.objects.filter(
            student=student,
            course=course,
            is_active=True
        ).first()

        if existing_enrollment:
            return Response({
                'message': 'You are already enrolled in this course',
                'enrollment_id': existing_enrollment.id
            }, status=status.HTTP_200_OK)

        # Создаем новое зачисление
        enrollment = Enrollment.objects.create(
            student=student,
            course=course,
            current_lesson=course.lessons.filter(is_active=True).order_by('order').first()
        )

        return Response({
            'message': 'Successfully enrolled in course',
            'enrollment_id': enrollment.id
        }, status=status.HTTP_201_CREATED)

    @action(detail=True, methods=['get'])
    def progress(self, request, pk=None):
        """
        Получение информации о прогрессе студента в курсе
        """
        course = self.get_object()
        student = request.user.student

        try:
            enrollment = Enrollment.objects.get(
                student=student,
                course=course,
                is_active=True
            )

            total_lessons = course.lessons.filter(is_active=True).count()
            completed_lessons = 0

            if enrollment.current_lesson:
                completed_lessons = enrollment.current_lesson.order - 1

            progress_percent = round((completed_lessons / total_lessons) * 100, 1) if total_lessons > 0 else 0

            return Response({
                'enrollment_id': enrollment.id,
                'current_lesson': {
                    'id': enrollment.current_lesson.id if enrollment.current_lesson else None,
                    'title': enrollment.current_lesson.title if enrollment.current_lesson else None,
                    'order': enrollment.current_lesson.order if enrollment.current_lesson else None
                },
                'progress_percent': progress_percent,
                'completed_lessons': completed_lessons,
                'total_lessons': total_lessons
            })
        except Enrollment.DoesNotExist:
            return Response({
                'message': 'Not enrolled in this course'
            }, status=status.HTTP_404_NOT_FOUND)

#######

